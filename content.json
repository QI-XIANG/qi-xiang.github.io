{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Qi Xiang,Zhang","url":"https://qi-xiang.github.io","root":"/"},"pages":[{"title":"","date":"2021-05-06T09:48:14.284Z","updated":"2021-05-06T09:48:14.284Z","comments":true,"path":"about/CSS_homepage/rwd.css","permalink":"https://qi-xiang.github.io/about/CSS_homepage/rwd.css","excerpt":"","text":"/*完美支援320、375、425、768、1440、1536、1920px*/ /**********************************Design for Phone*************************************/ @media screen and (min-width: 320px){ #inner-experience{ margin:0px 0px !important; } #mail_jumbo{ padding-top: 0px; } #mail pre{ margin-left: 0px !important; } #inner-education{ margin: 0px 0px !important; } } @media screen and (min-width: 375px){ #inner-experience{ margin:0px 0px !important; } #mail_jumbo{ padding-top: 0px; } #mail pre{ margin-left: 0px !important; } #inner-education{ margin: 0px 0px !important; } } @media screen and (min-width: 425px) { /*Done*/ #inner-experience{ margin:0px 0px !important; } #mail_jumbo{ padding-top: 0px; } #mail pre{ margin-left: 0px !important; } #inner-education{ margin: 0px 0px !important; } } /***************************************************************************************/ @media screen and (min-width: 768px) { /*Done*/ #inner-education{ margin:0px 24px !important; margin-left: 8%; } #inner-experience{ margin:0px 24px !important; } #mail pre{ margin: 0px !important; } #mail_jumbo{ padding-top: 0px !important; } #icon{ padding-bottom: 0px; } } @media screen and (min-width: 1440px) { /*Done*/ #inner-education{ padding:0px 141px !important; } #contact{ padding-left: 150px; } #inner-experience{ padding:0px 141px !important; } #mail{ padding-left: 165px; padding-top: 64px; } #icon{ padding: 0px 150px; } } @media screen and (min-width: 1536px) { /*Done*/ #inner-education{ padding:0px 0px 0px 189px !important; } #inner-experience{ padding: 0px 189px !important; margin-right:0px !important; } #contact{ padding-left: 198px; } #icon{ padding-left: 198px; } #mail{ padding-top: 64px; padding-left: 213px; } } @media screen and (min-width: 1920px) { /*Done*/ #inner-education{ padding:0px 0px 0px 381px !important; } #inner-experience{ padding-left: 381px !important; margin-right:0px !important; } #contact{ padding-left: 390px; } #icon{ padding-left: 390px; } #mail{ padding-top: 64px; padding-left: 405px; } }"},{"title":"","date":"2020-12-22T13:28:52.860Z","updated":"2020-12-22T13:28:52.860Z","comments":true,"path":"about/README.html","permalink":"https://qi-xiang.github.io/about/README.html","excerpt":"","text":"qi-xiang.github.io"},{"title":"","date":"2021-05-13T04:00:18.992Z","updated":"2021-05-13T04:00:18.992Z","comments":true,"path":"about/CSS_homepage/rwd2.css","permalink":"https://qi-xiang.github.io/about/CSS_homepage/rwd2.css","excerpt":"","text":"div .row{ background-color: #E9ECEF; } #foot{ background-color: #5569DC; } .marquee { width: 300px; /* the plugin works for responsive layouts so width is not necessary */ overflow: hidden; border:1px solid #ccc; }"},{"title":"","date":"2021-04-22T15:24:39.596Z","updated":"2021-04-22T15:24:39.596Z","comments":true,"path":"about/CSS_homepage/style.css","permalink":"https://qi-xiang.github.io/about/CSS_homepage/style.css","excerpt":"","text":"#myBtn { display: none; position: fixed; bottom: 10px; right: 10px; z-index: 99; font-size: 18px; border: none; outline: none; background-color: red; color: white; cursor: pointer; padding: 15px; border-radius: 4px; opacity: 0.5; } #myBtn:hover { background-color: #555; } a{ text-decoration: none; } /* Style all font awesome icons */ .fa { padding: 0px 25px 0px 0px; font-size: 20px; width: 20px; text-align: center; text-decoration: none; margin: 5px 2px; } /* Add a hover effect if you want */ .fa:hover { opacity: 0.7; } /* Set a specific color for each brand */ /* Facebook */ .fa-facebook { color: black; } /* LinkedIn */ .fa-linkedin { color: black; } /*Instagram*/ .fa-instagram { color: black; } /*Style for a:hover*/ .about a:hover{ color: aqua !important; } .education a:hover{ color: aqua !important; } .skills a:hover{ color: aqua !important; }.awards a:hover{ color: aqua !important; }"},{"title":"","date":"2021-05-13T04:02:27.460Z","updated":"2021-05-13T04:02:27.460Z","comments":true,"path":"about/JS_homepage/FadeIn_Animation.js","permalink":"https://qi-xiang.github.io/about/JS_homepage/FadeIn_Animation.js","excerpt":"","text":"$(document).ready(function(){ $(\"#fadeArea1 p\").hide() $(\"#fadeArea2 pre\").hide() $(\"#fadeArea2 p\").hide() $(\"#fadeArea3 pre\").hide() $(\"#fadeArea3 p\").hide() $(\"#fadeArea4 pre\").hide() $(\"#fadeArea4 p\").hide() $(\"#fadeArea5 pre\").hide() $(\"#fadeArea5 p\").hide() for(var i = 1;i=$('#about').offset().top){ $(\"#fadeArea1 p\").fadeIn(1000); } if($(window).scrollTop()+330>=$('#education').offset().top){ $(\"#fadeArea2 p\").fadeIn(1000); $(\"#fadeArea2 pre\").fadeIn(1000); } if($(window).scrollTop()+420>=$('#experience').offset().top){ $(\"#fadeArea3 p\").fadeIn(1000); $(\"#fadeArea3 pre\").fadeIn(1000); } if($(window).scrollTop()+440>=$('#skills').offset().top){ for(var i = 1;i=$('#awards').offset().top){ $(\"#fadeArea4 p\").fadeIn(1200); $(\"#fadeArea4 pre\").fadeIn(1200); } if($(window).scrollTop()+600>=$('#interests').offset().top){ $(\"#fadeArea5 p\").fadeIn(1300); $(\"#fadeArea5 pre\").fadeIn(1300); } }) $('.marquee').marquee({ //duration in milliseconds of the marquee duration: 8000, //gap in pixels between the tickers gap: 50, //time in milliseconds before the marquee will start animating delayBeforeStart: 0, //'left' or 'right' direction: 'left', //true or false - should the marquee be duplicated to show an effect of continues flow duplicated: true }); })"},{"title":"","date":"2021-04-22T14:37:21.604Z","updated":"2021-04-22T14:37:21.603Z","comments":true,"path":"about/animation/animation.css","permalink":"https://qi-xiang.github.io/about/animation/animation.css","excerpt":"","text":"@charset \"utf-8\"; h1{ text-align: center; color: darkorchid; padding-bottom: 15px; margin-top: 25px; margin-bottom: 25px; } body{ background-image: url(img/2.png); background-repeat: repeat-x; background-color: wheat; } a{ text-decoration: none; } a:hover{ color: red; } a:active{ color: blue; } .more{ text-align: right; padding: 20px 24px 20px 20px; background-image: url(img/icon.png); background-repeat: no-repeat; background-position: right center; clear: left; } h2{ border: black 1px solid; border-left: gray 15px solid; width: 180px; } table{ width: 50%; border: violet 1px solid; } th,td{ padding: 5px 10px; border: violet 1px solid; border-collapse: collapse; } #wrap{ width: 798px; margin: 40px auto; padding: 40px 80px; border: white 1px solid; background-color: white; } #a,#b,#c{ background-color: wheat; background-image: url(img/30.jpg); background-repeat: repeat-x; margin: 20px 0; padding: 35px 30px 30px 30px; } .ph{ float: left; margin-right: 30px; } .data{ width: 300px; float: left; } dt{ clear: left; float: left; font-weight: bold; } @keyframes marquee{ 0%{ left: 0%; } 100%{ left:-100%; } } div.marquee{ overflow: hidden; width: 420px; position: relative;margin: auto; height: 25px; } .marquee div{ display: block; overflow: hidden; width:200%; height: 25px; position: absolute; animation: marquee 10s linear infinite; } .marquee div span{ width: 50%; float: left; font-weight: bold; }"},{"title":"","date":"2021-04-22T14:37:30.908Z","updated":"2021-04-22T14:37:30.907Z","comments":true,"path":"about/animation/feedback.html","permalink":"https://qi-xiang.github.io/about/animation/feedback.html","excerpt":"","text":"feedback for animation 回饋表單 性別: 男生 女生 年齡: 請選擇 喜歡的角色: 最喜歡的女主角: 雪之下雪乃 由比濱結衣 川崎沙希 一色伊呂波 網站改善意見: 最後確認:"},{"title":"","date":"2021-04-22T14:40:14.530Z","updated":"2021-04-22T14:40:14.530Z","comments":true,"path":"about/animation/animation.html","permalink":"https://qi-xiang.github.io/about/animation/animation.html","excerpt":"","text":"animation 果然我的青春戀愛喜劇搞錯了! 果然我的青春戀愛喜劇搞錯了!完~2020年7月放送開始! 果然我的青春戀愛喜劇搞錯了!完~2020年7月放送開始! 來介紹一下我喜歡的作品! 作品概要 劇情大綱 登場人物 網站作者資訊 回饋表單 作品概要 《果然我的青春戀愛喜劇搞錯了。》（日語：やはり俺の青春ラブコメはまちがっている。 是日本輕小說作家渡航所創作的輕小說，插畫由ぽんかん⑧負責，簡體簡稱《春物》(我的青春戀愛物語果然有問題)，繁體簡稱《果青》(果然我的青春戀愛喜劇搞錯了)（日語：俺ガイル）。由GAGAGA文庫（小學館）於2011年3月至2019年11月間發行全14卷（本篇），日本地區累計發行量已突破900萬本。於2013年4月至6月播放第1季動畫，2015年4月至6月播放第2季動畫。原定於2020年4月9日首播第3期完結動畫，後因嚴重特殊傳染性肺炎疫情影響延期至同年7月。 劇情大綱 高中生比企谷八幡生性彆扭，不屈服於孤獨，沒有半個朋友，更不用提女朋友。對那些享受著青春的同班同學，他詛咒：「他們都是現充，通通給我爆炸吧！」——這樣一個傢伙，被導師帶去全校第一美少女雪之下雪乃加入的「侍奉社」。平凡無奇的八幡與美少女的奇妙邂逅，然而，雪乃和八幡個性上的缺陷讓他們無法擦出愛情的火花。這是一則充滿錯誤的青春故事。 登場人物(主要) 比企谷 八幡 年齡:17歲。 生日:8月8日，獅子座。 血型:A型。 喜歡的食物:蜂蜜炒花生及Max咖啡。 興趣:閱讀、玩遊戲、看動畫。 座右銘:「強求不來就放棄。」。 更多介紹 雪之下雪乃 年齡:17歲。 生日:1月3日，摩羯座。 血型:B型。 喜歡的食物:龍蝦和紅茶。 更多介紹 由比濱結衣 年齡:17歲。 生日:6月18日，雙子座。 血型:O型。 喜歡的食物:甜食。 更多介紹 網頁作者介紹 暱稱:翔翔 職業:中央大學資訊管理學系學生 E-mail:a0905716188@gmail.com WEB:建置中 敬請期待!! 回饋表單 回饋表單連結... Copyright &copy; GAGAGA文庫 All Rights Reserved. alert(\"該網站還處於測試階段!!\");"},{"title":"","date":"2021-10-21T16:12:18.300Z","updated":"2021-10-21T16:12:18.300Z","comments":true,"path":"about/index.html","permalink":"https://qi-xiang.github.io/about/index.html","excerpt":"","text":"My Homepage document.addEventListener('click', musicPlay); function musicPlay() { document.getElementById('music').play(); document.removeEventListener('click', musicPlay); } Top Welcome to my website! About Education & Experience Skills & Languages Awards & Interests QI-XIANG, ZHANG MIS in International Information & System Taoyuan, Taiwan qixiang1009@gmail.com https://github.com/QI-XIANG About MY BACKGROUND With a passion for computer science, web design, and all things programming, I have both the skill set and professional background necessary to dive deep into the programming world. As an upbeat, self-motivated team player with excellent communication, I envision an exciting future in the industry. Browse my site to see all that I have to offer. Education WHAT I’VE LEARNED 2019 - Present National Central University, TaiwanManagement in Information System 2016 - 2019 Taichung First Senior High School Experience WHERE I’VE WORKED Mar. 2021 - Present NCU Coding Club, Member Jan. 2020 - Present NCU Traditional Chinese Music Club, Erhu Group Leader Oct. 2019 - Dec. 2019 NCU MIS Carnival, Curation Group Member Sep. 2019 - Jan. 2020 NCU Traditional Chinese Music Club, Member Skills & Languages WHAT I BRING TO THE TABLE Java 20% Complete80% HTML & CSS 20% Complete70% JavaScript & JQuery 20% Complete50% Python 20% Complete45% Bootstrap 4 20% Complete40% Stock Analysis 20% Complete35% Git 20% Complete25% Chinese 20% Complete100% Taiwanese 20% Complete90% English 20% Complete80% Japanese 20% Complete35% Awards WHERE I SHINE Mayor Prize, Taichung City NCU College of Management,United Classes of Calculus 2019 Exam3 [21th place] JLPT N5 Certificate Interests OUT OF OFFICE Animation Reading Coding Web Design Stock Computer Science I'd love to hearfrom you qixiang1009@gmail.comhttps://github.com/QI-XIANG &copy; 2021 By Qi-Xiang Zhang.Proudly created with Bootstrap 4. //Get the button var mybutton = document.getElementById(\"myBtn\"); // When the user scrolls down 20px from the top of the document, show the button window.onscroll = function() {scrollFunction()}; function scrollFunction() { if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) { mybutton.style.display = \"block\"; } else { mybutton.style.display = \"none\"; } } // When the user clicks on the button, scroll to the top of the document function topFunction() { document.body.scrollTop = 0; document.documentElement.scrollTop = 0; } if (top.location !== self.location) { top.location.href = \"https://www.google.com\"; // 很不負責的轉給Google... XD } //audio play var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor); if (!isChrome){ $('#iframeAudio').remove() } else { $('#playAudio').remove() // just to make sure that it will not have 2x audio in the background }"}],"posts":[{"title":"JS30 全攻略 第十三天","slug":"ironman2021D13","date":"2021-10-22T06:53:12.000Z","updated":"2021-10-22T07:00:08.624Z","comments":true,"path":"2021/10/22/ironman2021D13/","link":"","permalink":"https://qi-xiang.github.io/2021/10/22/ironman2021D13/","excerpt":"","text":"前言JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標當捲動捲軸到一定位置，原本隱藏的圖片會由右或左方滑入原本的空白格顯現出來；當捲軸捲動量超過圖片的底部，圖片就會向左或右方滑出並重新的被隱藏。 解析程式碼本次的結構由&lt;p&gt;標籤的假文和穿插其中向左或向右對齊的&lt;img&gt;標籤的圖片所組成。在 CSS 裡，我們透過float:right;和float:left;刻意去產生文繞圖效果並讓圖片的透明度為0，因此出現一個個空格，但這些空格一開始並不是四四方方的，所以我們又設定text-align:justify;，讓文字向兩側對齊，也讓圖片留下的空格變成完美的方形。 HTML 部分1234567891011121314151617181920212223242526272829303132&lt;div class=&quot;site-wrap&quot;&gt; &lt;h1&gt;Slide in on Scroll&lt;/h1&gt; &lt;p&gt;Consectetur adipisicing elit. Tempore tempora rerum, est autem cupiditate, corporis a qui libero ipsum delectus quidem dolor at nulla, adipisci veniam in reiciendis aut asperiores omnis blanditiis quod quas laborum nam! Fuga ad tempora in aspernatur pariaturlores sunt esse magni, ut, dignissimos.&lt;/p&gt; &lt;p&gt;Lorem ipsum cupiditate, corporis a qui libero ipsum delectus quidem dolor at nulla, adipisci veniam in reiciendis aut asperiores omnis blanditiis quod quas laborum nam! Fuga ad tempora in aspernatur pariatur fugit quibusdam dolores sunt esse magni, ut, dignissimos.&lt;/p&gt; &lt;p&gt;Adipisicing elit. Tempore tempora rerum..&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempore tempora rerum, est autem cupiditate, corporis a qui libero ipsum delectus quidem dolor at nulla, adipisci veniam in reiciendis aut asperiores omnis blanditiis quod quas laborum nam! Fuga ad tempora in aspernatur pariatur fugit quibusdam dolores sunt esse magni, ut, dignissimos.&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempore tempora rerum, est autem cupiditate, corporis a qui libero ipsum delectus quidem dolor at nulla, adipisci veniam in reiciendis aut asperiores omnis blanditiis quod quas laborum nam! Fuga ad tempora in aspernatur pariatur fugit quibusdam dolores sunt esse magni, ut, dignissimos.&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempore tempora rerum, est autem cupiditate, corporis a qui libero ipsum delectus quidem dolor at nulla, adipisci veniam in reiciendis aut asperiores omnis blanditiis quod quas laborum nam! Fuga ad tempora in aspernatur pariatur fugit quibusdam dolores sunt esse magni, ut, dignissimos.&lt;/p&gt; &lt;img src=&quot;http://unsplash.it/400/400&quot; class=&quot;align-left slide-in&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptates, deserunt facilis et iste corrupti omnis tenetur est. Iste ut est dicta dolor itaque adipisci, dolorum minima, veritatis earum provident error molestias. Ratione magni illo sint vel velit ut excepturi consectetur suscipit, earum modi accusamus voluptatem nostrum, praesentium numquam, reiciendis voluptas sit id quisquam. Consequatur in quis reprehenderit modi perspiciatis necessitatibus saepe, quidem, suscipit iure natus dignissimos ipsam, eligendi deleniti accusantium, rerum quibusdam fugit perferendis et optio recusandae sed ratione. Culpa, dolorum reprehenderit harum ab voluptas fuga, nisi eligendi natus maiores illum quas quos et aperiam aut doloremque optio maxime fugiat doloribus. Eum dolorum expedita quam, nesciunt&lt;/p&gt; &lt;img src=&quot;http://unsplash.it/400/401&quot; class=&quot;align-right slide-in&quot;&gt; &lt;p&gt; at provident praesentium atque quas rerum optio dignissimos repudiandae ullam illum quibusdam. Vel ad error quibusdam, illo ex totam placeat. Quos excepturi fuga, molestiae ea quisquam minus, ratione dicta consectetur officia omnis, doloribus voluptatibus? Veniam ipsum veritatis architecto, provident quas consequatur doloremque quam quidem earum expedita, ad delectus voluptatum, omnis praesentium nostrum qui aspernatur ea eaque adipisci et cumque ab? Ea voluptatum dolore itaque odio. Eius minima distinctio harum, officia ab nihil exercitationem. Tempora rem nemo nam temporibus molestias facilis minus ipsam quam doloribus consequatur debitis nesciunt tempore officiis aperiam quisquam, molestiae voluptates cum, fuga culpa. Distinctio accusamus quibusdam, tempore perspiciatis dolorum optio facere consequatur quidem ullam beatae architecto, ipsam sequi officiis dignissimos amet impedit natus necessitatibus tenetur repellendus dolor rem! Dicta dolorem, iure, facilis illo ex nihil ipsa amet officia, optio temporibus eum autem odit repellendus nisi. Possimus modi, corrupti error debitis doloribus dicta libero earum, sequi porro ut excepturi nostrum ea voluptatem nihil culpa? Ullam expedita eligendi obcaecati reiciendis velit provident omnis quas qui in corrupti est dolore facere ad hic, animi soluta assumenda consequuntur reprehenderit! Voluptate dolor nihil veniam laborum voluptas nisi pariatur sed optio accusantium quam consectetur, corrupti, sequi et consequuntur, excepturi doloremque. Tempore quis velit corporis neque fugit non sequi eaque rem hic. Facere, inventore, aspernatur. Accusantium modi atque, asperiores qui nobis soluta cumque suscipit excepturi possimus doloremque odit saepe perferendis temporibus molestiae nostrum voluptatum quis id sint quidem nesciunt culpa. Rerum labore dolor beatae blanditiis praesentium explicabo velit optio esse aperiam similique, voluptatem cum, maiores ipsa tempore. Reiciendis sed culpa atque inventore, nam ullam enim expedita consectetur id velit iusto alias vitae explicabo nemo neque odio reprehenderit soluta sint eaque. Aperiam, qui ut tenetur, voluptate doloremque officiis dicta quaerat voluptatem rerum natus magni. Eum amet autem dolor ullam.&lt;/p&gt; &lt;img src=&quot;http://unsplash.it/200/500&quot; class=&quot;align-left slide-in&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Distinctio maiores adipisci quibusdam repudiandae dolor vero placeat esse sit! Quibusdam saepe aperiam explicabo placeat optio, consequuntur nihil voluptatibus expedita quia vero perferendis, deserunt et incidunt eveniet &lt;img src=&quot;http://unsplash.it/200/200&quot; class=&quot;align-right slide-in&quot;&gt; temporibus doloremque possimus facilis. Possimus labore, officia dolore! Eaque ratione saepe, alias harum laboriosam deserunt laudantium blanditiis eum explicabo placeat reiciendis labore iste sint. Consectetur expedita dignissimos, non quos distinctio, eos rerum facilis eligendi. Asperiores laudantium, rerum ratione consequatur, culpa consectetur possimus atque ab tempore illum non dolor nesciunt. Neque, rerum. A vel non incidunt, quod doloremque dignissimos necessitatibus aliquid laboriosam architecto at cupiditate commodi expedita in, quae blanditiis. Deserunt labore sequi, repellat laboriosam est, doloremque culpa reiciendis tempore excepturi. Enim nostrum fugit itaque vel corporis ullam sed tenetur ipsa qui rem quam error sint, libero. Laboriosam rem, ratione. Autem blanditiis&lt;/p&gt; &lt;p&gt;laborum neque repudiandae quam, cumque, voluptate veritatis itaque, placeat veniam ad nisi. Expedita, laborum reprehenderit ratione soluta velit natus, odit mollitia. Corporis rerum minima fugiat in nostrum. Assumenda natus cupiditate hic quidem ex, quas, amet ipsum esse dolore facilis beatae maxime qui inventore, iste? Maiores dignissimos dolore culpa debitis voluptatem harum, excepturi enim reiciendis, tempora ab ipsam illum aspernatur quasi qui porro saepe iure sunt eligendi tenetur quaerat ducimus quas sequi omnis aperiam suscipit! Molestiae obcaecati officiis quo, ratione eveniet, provident pariatur. Veniam quasi expedita distinctio, itaque molestiae sequi, dolorum nisi repellendus quia facilis iusto dignissimos nam? Tenetur fugit quos autem nihil, perspiciatis expedita enim tempore, alias ab maiores quis necessitatibus distinctio molestias eum, quidem. Delectus impedit quidem laborum, fugit vel neque quo, ipsam, quasi aspernatur quas odio nihil? Veniam amet reiciendis blanditiis quis reprehenderit repudiandae neque, ab ducimus, odit excepturi voluptate saepe ipsam. Voluptatem eum error voluptas porro officiis, amet! Molestias, fugit, ut! Tempore non magnam, amet, facere ducimus accusantium eos veritatis neque.&lt;/p&gt; &lt;img src=&quot;http://unsplash.it/400/400&quot; class=&quot;align-right slide-in&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Distinctio maiores adipisci quibusdam repudiandae dolor vero placeat esse sit! Quibusdam saepe aperiam explicabo placeat optio, consequuntur nihil voluptatibus expedita quia vero perferendis, deserunt et incidunt eveniet temporibus doloremque possimus facilis. Possimus labore, officia dolore! Eaque ratione saepe, alias harum laboriosam deserunt laudantium blanditiis eum explicabo placeat reiciendis labore iste sint. Consectetur expedita dignissimos, non quos distinctio, eos rerum facilis eligendi. Asperiores laudantium, rerum ratione consequatur, culpa consectetur possimus atque ab tempore illum non dolor nesciunt. Neque, rerum. A vel non incidunt, quod doloremque dignissimos necessitatibus aliquid laboriosam architecto at cupiditate commodi expedita in, quae blanditiis. Deserunt labore sequi, repellat laboriosam est, doloremque culpa reiciendis tempore excepturi. Enim nostrum fugit itaque vel corporis ullam sed tenetur ipsa qui rem quam error sint, libero. Laboriosam rem, ratione. Autem blanditiis laborum neque repudiandae quam, cumque, voluptate veritatis itaque, placeat veniam ad nisi. Expedita, laborum reprehenderit ratione soluta velit natus, odit mollitia. Corporis rerum minima fugiat in nostrum. Assumenda natus cupiditate hic quidem ex, quas, amet ipsum esse dolore facilis beatae maxime qui inventore, iste? Maiores dignissimos dolore culpa debitis voluptatem harum, excepturi enim reiciendis, tempora ab ipsam illum aspernatur quasi qui porro saepe iure sunt eligendi tenetur quaerat ducimus quas sequi omnis aperiam suscipit! Molestiae obcaecati officiis quo, ratione eveniet, provident pariatur. Veniam quasi expedita distinctio, itaque molestiae sequi, dolorum nisi repellendus quia facilis iusto dignissimos nam? Tenetur fugit quos autem nihil, perspiciatis expedita enim tempore, alias ab maiores quis necessitatibus distinctio molestias eum, quidem. Delectus impedit quidem laborum, fugit vel neque quo, ipsam, quasi aspernatur quas odio nihil? Veniam amet reiciendis blanditiis quis reprehenderit repudiandae neque, ab ducimus, odit excepturi voluptate saepe ipsam. Voluptatem eum error voluptas porro officiis, amet! Molestias, fugit, ut! Tempore non magnam, amet, facere ducimus accusantium eos veritatis neque.&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Distinctio maiores adipisci quibusdam repudiandae dolor vero placeat esse sit! Quibusdam saepe aperiam explicabo placeat optio, consequuntur nihil voluptatibus expedita quia vero perferendis, deserunt et incidunt eveniet temporibus doloremque possimus facilis. Possimus labore, officia dolore! Eaque ratione saepe, alias harum laboriosam deserunt laudantium blanditiis eum explicabo placeat reiciendis labore iste sint. Consectetur expedita dignissimos, non quos distinctio, eos rerum facilis eligendi. Asperiores laudantium, rerum ratione consequatur, culpa consectetur possimus atque ab tempore illum non dolor nesciunt. Neque, rerum. A vel non incidunt, quod doloremque dignissimos necessitatibus aliquid laboriosam architecto at cupiditate commodi expedita in, quae blanditiis. Deserunt labore sequi, repellat laboriosam est, doloremque culpa reiciendis tempore excepturi. Enim nostrum fugit itaque vel corporis ullam sed tenetur ipsa qui rem quam error sint, libero. Laboriosam rem, ratione. Autem blanditiis laborum neque repudiandae quam, cumque, voluptate veritatis itaque, placeat veniam ad nisi. Expedita, laborum reprehenderit ratione soluta velit natus, odit mollitia. Corporis rerum minima fugiat in nostrum. Assumenda natus cupiditate hic quidem ex, quas, amet ipsum esse dolore facilis beatae maxime qui inventore, iste? Maiores dignissimos dolore culpa debitis voluptatem harum, excepturi enim reiciendis, tempora ab ipsam illum aspernatur quasi qui porro saepe iure sunt eligendi tenetur quaerat ducimus quas sequi omnis aperiam suscipit! Molestiae obcaecati officiis quo, ratione eveniet, provident pariatur. Veniam quasi expedita distinctio, itaque molestiae sequi, dolorum nisi repellendus quia facilis iusto dignissimos nam? Tenetur fugit quos autem nihil, perspiciatis expedita enim tempore, alias ab maiores quis necessitatibus distinctio molestias eum, quidem. Delectus impedit quidem laborum, fugit vel neque quo, ipsam, quasi aspernatur quas odio nihil? Veniam amet reiciendis blanditiis quis reprehenderit repudiandae neque, ab ducimus, odit excepturi voluptate saepe ipsam. Voluptatem eum error voluptas porro officiis, amet! Molestias, fugit, ut! Tempore non magnam, amet, facere ducimus accusantium eos veritatis neque.&lt;/p&gt;&lt;/div&gt; JS 部分我們的目的是讓圖片隨著捲軸下滑一個個的從左或右滑進來，為了達成這個目的，我們會在視窗(window)上註冊scroll 事件的監聽器。 如果將每次觸發的scroll 事件用console.count(e)計算並印出到console上，你會發現只是稍微的滑動滾輪就觸發數次scroll 事件。而太頻繁地觸發事件的處理對瀏覽器來說是很大的負擔，也因此我們必須借助debounce()來幫我們延遲事件的處理，預設是延遲20毫秒。 1234567891011121314151617/*用來延遲執行方法*/function debounce(func, wait = 20, immediate = true) &#123; var timeout; return function() &#123; var context = this, args = arguments; var later = function() &#123; timeout = null; if (!immediate) func.apply(context, args); &#125;; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); &#125;;&#125;;window.addEventListener(&#x27;scroll&#x27;,e =&gt; console.count(e)); 宣告常數slideImages放入要滑進來的圖片們。 1const sliderImages = document.querySelectorAll(&#x27;.slide-in&#x27;); 觸發scroll 事件時，我們並沒有在第一時間處理它，而是利用debounce(checkSlide)讓checkSlide()被延遲20毫秒才執行。 在checkSlide()裡，我們首先必須決定圖片要在哪時候滑進來和滑出去。在這次的課程裡，我們決定要讓2分之1的圖片出現在視窗下緣時，讓圖片滑進來、捲軸移動超過圖片底端時，讓圖片滑出去。 我們使用sliderImages.forEach()分別計算2分之1圖片出現在下緣的距離(slideInAt)以及圖片的底端距離視窗上方的距離(imageBottom) window.scrollY(目前的捲軸捲動量) + window.innerHeight(視窗內部高度) = 視窗下緣離視窗頂部的距離。如果將這段距離再減去slideImage.height / 2(2分之1的圖片高度)，就會是實際上圖片的滑入點(slideInAt)。 slideImage.offsetTop(圖片頂部離視窗頂部的距離) + slideImage.height(圖片的高度) = 圖片底部離視窗頂部的距離(imageBottom)。 12345678910function checkSlide(e)&#123; sliderImages.forEach(slideImage =&gt;&#123; /*取得視窗下緣並預留2分之1的圖片高度*/ const slideInAt = (window.scrollY + window.innerHeight) - slideImage.height / 2; /*取得圖片底部離視窗頂部的距離*/ const imageBottom = slideImage.offsetTop + slideImage.height; &#125;);&#125;;window.addEventListener(&#x27;scroll&#x27;,debounce(checkSlide)); 宣告常數isHalfShown判斷圖片是否已有2分之1出現在視窗的下緣。 宣告常數isNotScrolledPast判斷捲軸的捲動量是否已經超過圖片的底部。 最後，利用 if 判斷圖片已經有2分之1出現在視窗下緣(isHalfShown = true)並且捲軸捲動量不超過圖片底部(isNotScrolledPast = true)就為圖片(slideImage)加上 .active選擇器，讓圖片滑入並顯示；反之則拿掉.active選擇器，讓圖片滑出並隱藏。 1234567891011121314function checkSlide(e)&#123; sliderImages.forEach(slideImage =&gt;&#123; /*上略*/ const isHalfShown = slideInAt &gt; slideImage.offsetTop; const isNotScrolledPast = window.scrollY &lt; imageBottom; if(isHalfShown &amp;&amp; isNotScrolledPast)&#123; slideImage.classList.add(&#x27;active&#x27;); &#125;else&#123; slideImage.classList.remove(&#x27;active&#x27;); &#125; &#125;);&#125;; 圖片初始都向左或右位移並隱藏，.active選擇器用來取消圖片原有的位移，讓圖片回到原始的位置(滑進來)。 12345678910111213/*CSS*/.align-left.slide-in &#123; transform: translateX(-30%) scale(0.95);&#125; .align-right.slide-in &#123; transform: translateX(30%) scale(0.95);&#125;.slide-in.active &#123; opacity: 1; transform: translateX(0%) scale(1);&#125; 補充資料:HTMLElement.offsetToptext-align 範例網頁請按此","categories":[],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第十二天","slug":"ironman2021D12","date":"2021-10-22T06:53:06.000Z","updated":"2021-10-22T06:58:26.748Z","comments":true,"path":"2021/10/22/ironman2021D12/","link":"","permalink":"https://qi-xiang.github.io/2021/10/22/ironman2021D12/","excerpt":"","text":"前言JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標預先設定一組secretCode，如果在視窗畫面內輸入的文字與secretCode相同則在視窗畫面加上圖案。 (ps.背景圖是後來改的，原版是空白畫面。) 解析程式碼這次我們需要藉助網路上別人寫好的 JavaScript API，讓他幫忙在每次視窗畫面中輸入文字等於secretCode時，在視窗畫面上新增一個生動的圖案。 觀看完整的 JavaScript API 內容 1&lt;script type=&quot;text/javascript&quot; src=&quot;https://www.cornify.com/js/cornify.js&quot;&gt;&lt;/script&gt; JS 部分宣告常數 pressed 為一個空陣列，用來存放我們在視窗畫面所輸入的值。 宣告常數secretCode作為預設的文字密碼。 12const pressed = [];const secretCode = &#x27;saber&#x27;; 我們替整個視窗註冊keyup 事件(放開按鍵時觸發)的監聽器，藉由console.log(e.key);可以在console看到我們按下的是哪一個按鍵，緊接著我們將按下的那個按鍵(key)放入陣列pressed的末端。 為了比對輸入文字是否等於secretCode，我們可以利用splice(start,deleteCount)來讓陣列的長度跟secretCode保持一樣，沒做這個處理的話，我們會發現陣列中的元素愈來愈多、長度愈來愈長，永遠沒有和secretCode相同的可能。 splice(start,deleteCount)可以刪除陣列自start索引開始的deleteCount個元素，要注意的是deleteCount要大於0才會開始刪去元素，範例中的secretCode長度是5，也就是說只有輸入到第6次才會開始刪去元素。 有趣的是我們將deleteCount指定為pressed.length - secretCode則效果和直接指定為1相同。只要pressed的長度到達6，經過計算後deleteCount是1，刪去一個元素後，pressed長度又變為5，由此周而復始(5-&gt;6；6-&gt;5)。 指定start = -secretCode.length - 1的效果是讓我們從最早被 push 進陣列(最前端)的元素開始刪除。 12345window.addEventListener(&#x27;keyup&#x27;,(e)=&gt;&#123; console.log(e.key); pressed.push(e.key); pressed.splice(-secretCode.length - 1,pressed.length - secretCode.length);&#125;); 最後，我們利用 if 判斷用pressed.join(&#39;&#39;)串聯出的字串是否有包含secretCode，如果有包含就在console印出DING DING!並呼叫 API 中的cornify_add()在視窗畫面裡加上圖片。我們也可以再補上console.log(pressed);，查看目前pressed陣列內的元素。 12345678910window.addEventListener(&#x27;keyup&#x27;,(e)=&gt;&#123; /***省略***/ /***省略***/ if(pressed.join(&#x27;&#x27;).includes(secretCode))&#123; console.log(&#x27;DING DING!&#x27;); cornify_add(); &#125; console.log(pressed);&#125;); 補充資料:keyup事件Array.prototype.splice() 範例網頁請按此","categories":[],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第十一天","slug":"ironman2021D11","date":"2021-10-22T06:53:01.000Z","updated":"2021-10-22T06:56:22.313Z","comments":true,"path":"2021/10/22/ironman2021D11/","link":"","permalink":"https://qi-xiang.github.io/2021/10/22/ironman2021D11/","excerpt":"","text":"前言JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標靈活運用 video 元素的相關屬性、方法，實作出一個擁有快進快退、播放速度倍率、控制音量大小、拖拉時間軸功能的簡易影片播放器。 解析程式碼HTML 部分.player 代表整個影片播放器，包含影片(.player__video)、播放控制列(.player__controls)兩部分。 播放控制列內部又可細分為四個部分: 1. 影片播放的時間軸 : .progress、.progress__filled2. 播放/暫停鈕 : .toggle3. 音量/播放速度倍率 : .player__slider4. 快進/快退 : .player__button1234567891011121314&lt;div class=&quot;player&quot;&gt; &lt;video class=&quot;player__video viewer&quot; src=&quot;652333414.mp4&quot;&gt;&lt;/video&gt; &lt;div class=&quot;player__controls&quot;&gt; &lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress__filled&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;button class=&quot;player__button toggle&quot; title=&quot;Toggle Play&quot;&gt;►&lt;/button&gt; &lt;input type=&quot;range&quot; name=&quot;volume&quot; class=&quot;player__slider&quot; min=&quot;0&quot; max=&quot;1&quot; step=&quot;0.05&quot; value=&quot;1&quot;&gt; &lt;input type=&quot;range&quot; name=&quot;playbackRate&quot; class=&quot;player__slider&quot; min=&quot;0.5&quot; max=&quot;2&quot; step=&quot;0.1&quot; value=&quot;1&quot;&gt; &lt;button data-skip=&quot;-10&quot; class=&quot;player__button&quot;&gt;« 10s&lt;/button&gt; &lt;button data-skip=&quot;25&quot; class=&quot;player__button&quot;&gt;25s »&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; JS 部分首先，取得所有要用到 HTML 標籤並放到對應宣告的常數中。 12345678910/*get element we need*/const player = document.querySelector(&#x27;.player&#x27;);const video = player.querySelector(&#x27;.viewer&#x27;);const progress = player.querySelector(&#x27;.progress&#x27;);const progressBar = player.querySelector(&#x27;.progress__filled&#x27;);const toggle = player.querySelector(&#x27;.toggle&#x27;);const skipButtons = player.querySelectorAll(&#x27;[data-skip]&#x27;);const ranges = player.querySelectorAll(&#x27;.player__slider&#x27;); 下面我們將各個播放器的功能一個個拆出來做 : 1. 影片的播放/暫停功能目的 : 我們希望在點擊影片或播放/暫停鈕時，播放或暫停影片。 在video(影片)、toggle(播放/暫停鈕)上都註冊click 事件監聽器，觸發事件後用togglePlay()進行處理。 在togglePlay()裡，我們宣告一個常數method，經過條件判斷，當video.paused回傳 true 則 method = play；當video.paused回傳 false 則method = pause。 這邊有一個特殊的寫法video[method]();。舉例來說，當method = play則實際效果相當於video.play();。 12345678function togglePlay()&#123; const method = video.paused ? &#x27;play&#x27; : &#x27;pause&#x27;; video[method]();&#125;/*控制影片的播放*/video.addEventListener(&#x27;click&#x27;,togglePlay);toggle.addEventListener(&#x27;click&#x27;,togglePlay); 2. 更新播放/暫停圖示功能目的 : 我們希望在影片播放/暫停的狀態下，同步更新圖示。 在video(影片)上註冊play 事件和pause 事件兩個監聽器並都以updateButton()進行事件處理。 在updateButton()裡，我們宣告一個常數icon指定當影片處於暫停狀態則icon = &#39;►&#39;，接著利用toggle.textContent = icon修改按鈕的圖示，當影片處於播放狀態的處理也是用一樣的方式。 12345678function updateButton()&#123; const icon = this.paused ? &#x27;►&#x27; : &#x27;❚ ❚&#x27;; toggle.textContent = icon;&#125;/*讓播放鍵的圖示改變*/video.addEventListener(&#x27;play&#x27;,updateButton);video.addEventListener(&#x27;pause&#x27;,updateButton); 3. 影片的快進/快退功能目的 : 我們希望在點擊快進/快退按鈕時，同步調整影片的時間軸。 在skipButtons(快進、快退按鈕)裡的所有button都註冊click 事件並以skip()進行事件處理。 在skip()裡，我們將video.currentTime(影片現在播放的時間點)加上我們要快進或快退的秒數。 由於video.currentTime本身是 float 型別，因此需要將this.dataset.skip(快進/快退的秒數)用parseFloat()轉換成float型別之後再進行運算。 123456function skip()&#123; video.currentTime += parseFloat(this.dataset.skip);&#125;/*調整影片的快進和倒退*/skipButtons.forEach(button =&gt; button.addEventListener(&#x27;click&#x27;,skip)); 4. 調整影片的播放速度(倍率)、音量大小功能目的 : 我們希望在滑鼠在倍率或音量條上移動改變數值時，同步反映到video(影片)上。 在速度倍率和音量條上都註冊change 事件和mousemove 事件，分別在數值改變和滑鼠拖曳時觸發事件，之後用handleRangeUpdate()進行事件處理。 在handleRangeUpdate()裡，我們使用和之前一樣的特殊語法video[this.name] = this.value;對video的屬性值進行調整。舉例來說，如果this.name = volume、this.value = 0，則video[this.name] = this.value;的效果和video.volume = 0;一樣。 1234567function handleRangeUpdate()&#123; video[this.name] = this.value;&#125;/*調整影片的播放速度、音量*/ranges.forEach(range =&gt; range.addEventListener(&#x27;change&#x27;,handleRangeUpdate));ranges.forEach(range =&gt; range.addEventListener(&#x27;mousemove&#x27;,handleRangeUpdate)); 5. 更新時間軸功能目的 : 我們希望在影片播放的過程中，不斷地更新時間軸。 在video(影片)上註冊timeupdate 事件的監聽器，當影片的播放時間(currentTime)有變動就觸發事件，之後用handleProgress()進行事件處理。 在handleProgress()裡，我們宣告常數percent並放入video.currentTime(影片現在時間)除以video.duration(影片的總長度)再乘以100得到的比例值。 接著用progressBar.style.flexBasis = `$&#123;percent&#125;%`;，用percent指定時間軸的長度佔比。 1234567function handleProgress()&#123; const percent = (video.currentTime / video.duration) * 100 progressBar.style.flexBasis = `$&#123;percent&#125;%`; &#125;/*持續更新時間軸*/video.addEventListener(&#x27;timeupdate&#x27;,handleProgress); 6. 用拖拉的方式移動時間軸功能目的 : 我們希望按住滑鼠拖或點擊時間軸的同時，更新video(影片)現在播放的時間。 宣告mousedown作為 flag 判斷現在是否有按住滑鼠。 我們在progress註冊click 事件、mousemove 事件、mousedown 事件、mouseup 事件監聽器。 觸發click 事件時，我們可以直接就以scrub(e)進行事件的處理。 但在觸發mousemove 事件時，我們需要先判斷是否有按住滑鼠，所以要借助mousedown 事件和mouseup 事件的幫忙，在mousedown 事件觸發地當下將 flag(mousedown) 設為 true，反之觸發mouseup 事件則將 flag(mousedown) 設為 false。最後用mousedown &amp;&amp; scrub(e)判斷是否執行scrub(e)，只有當flag(mousedown) 是 true 的時候，才接著執行scrub(e)完成事件處理。 在scrub(e)裡，我們宣告常數scrubTime放入將滑鼠在元素內部的X座標(e.offsetX)除以時間軸的長度(progress.offsetWidth)再乘以影片長度(video.duration)所得到要前往的時間點。最後將影片現在的時間(video.currentTime)指定為要前往的時間點(scrubTime)。 1234567891011function scrub(e)&#123; const scrubTime = (e.offsetX / progress.offsetWidth) * video.duration; video.currentTime = scrubTime;&#125;/*拖拉時間軸*/let mousedown = false;progress.addEventListener(&#x27;click&#x27;,scrub);progress.addEventListener(&#x27;mousemove&#x27;,(e)=&gt; mousedown &amp;&amp; scrub(e));progress.addEventListener(&#x27;mousedown&#x27;,() =&gt; mousedown = true);progress.addEventListener(&#x27;mouseup&#x27;,() =&gt; mousedown = false); 補充說明:HTMLVideoElement繼承自HTMLMediaElement所以一些video元素的屬性都可以到HTMLMediaElement查詢。 使用HTMLElement.offsetWidth所取得的元素(element)寬度包括透過 CSS 設定的width、border、padding等等…。 補充資料:HTMLMediaElement HTMLElement.dataset HTMLElement.offsetWidth JS一秒區分clientX,offsetX,screenX,pageX之間關係 範例網頁請按此","categories":[],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第十天","slug":"ironman2021D10","date":"2021-10-22T06:36:06.000Z","updated":"2021-10-22T06:43:44.988Z","comments":true,"path":"2021/10/22/ironman2021D10/","link":"","permalink":"https://qi-xiang.github.io/2021/10/22/ironman2021D10/","excerpt":"","text":"前言JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標在已經勾選一個核取方塊的前提下，按住shift鍵並勾選第二個方塊，最後將第一、二個方塊之間的方塊都勾選起來，實現同時勾選複數方塊的目的。 解析程式碼HTML 部分由最外層的 div(.inbox) 包覆住內部多個 div(.item)，每個div(.item) 都是以一個核取方塊(checkbox)搭配說明文字(p)組合而成。 1234567891011121314151617181920212223242526272829303132333435363738&lt;div class=&quot;inbox&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;This is an inbox layout.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Check one item&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Hold down your Shift key&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Check a lower item&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Everything in between should also be set to checked&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Try to do it without any libraries&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Just regular JavaScript&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Good Luck!&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Don&#x27;t forget to tweet your result!&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; JS 部分首先，宣告一個常數 checkboxes 並取得所有網頁上的核取方塊(checkbox)。 接著，宣告一個變數 lastChecked 用來幫我們記住上一次勾選的核取方塊(checkbox)。 12const checkboxes = document.querySelectorAll(&#x27;.inbox input[type=&quot;checkbox&quot;]&#x27;);let lastChecked; 我們在每個 checkbox 上都註冊 click 事件監聽器，當事件觸發就以handleCheck()進行事件處理。 在handleCheck()裡面，我們可以用lastChecked = this;來記住上一次選取的方塊。 12345function handleCheck(e)&#123; lastChecked = this;//更新上次勾選的點&#125;checkboxes.forEach(checkbox =&gt; checkbox.addEventListener(&#x27;click&#x27;,handleCheck)); 我們進行多選核取方塊的邏輯是先勾選其中一個作為起始點，之後按住shift鍵勾選終點方塊，而在起、終點之間的方塊都會被勾選。 在handleCheck()裡，可以使用 if 判斷現在是不是有按下shift鍵並同時勾選方塊，之後再做勾選間隔方塊的處理。 12345678function handleCheck(e)&#123; //檢查是否有按下shift鍵並選取方塊 if(e.shiftKey &amp;&amp; this.checked)&#123; &#125; lastChecked = this;//更新上次勾選的點 &#125; 宣告一個變數inBetween判斷checkbox是否處在起、終點的checkbox之間。 在checkboxes上呼叫forEach()對其下的每一個checkbox進行判斷。當這個checkbox是剛剛按住shift鍵勾選的checkbox，此時將inBetween設為 true；當這個checkbox是lastChecked，此時改將inBetween設為 false。 最後一個 if 判斷用來幫我們將起、終點之間的方塊通通勾選起來。 12345678910111213141516171819function handleCheck(e)&#123; let inBetween = false;//用來判斷checkbox是否被夾在起、終點之間 //檢查是否有按下shift鍵並選取方塊 if(e.shiftKey &amp;&amp; this.checked)&#123; checkboxes.forEach(checkbox =&gt; &#123; //將起始點的inBetween設為true、結束點的inBetewwn設為false作為斷點 if(checkbox === this || checkbox === lastChecked)&#123; inBetween = !inBetween; &#125; if(inBetween)&#123;//打勾夾在起點和終點的checkbox checkbox.checked = true; &#125; &#125;) &#125; lastChecked = this;//更新上次勾選的點&#125; 舉例說明:假設現在先勾選第一個方塊，之後按住shift鍵並勾選第八個方塊，此時第一個方塊就會是lastChecked，而第八個方塊則是this剛剛勾選的。 在checkboxes上呼叫forEach()對其下的每一個checkbox進行判斷時，遇到第一個方塊也就是lastChecked就將inBetween改成 true，遇到第八個方塊也就是this則將inBetween改成 false。 最後，第一個方塊到第七個方塊的inBetween都會是 true，第八個方塊則是 false。作 if 判斷時，我們將inBetween是 true 的勾選起來，勾到第八個剛好inBetween是 false 成為一個勾選的終止點，成功地一次勾選八個方塊。 補充資料:KeyboardEvent.shiftKey 範例網頁請點此","categories":[],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第九天","slug":"ironman2021D9","date":"2021-10-22T06:36:01.000Z","updated":"2021-10-22T06:42:30.935Z","comments":true,"path":"2021/10/22/ironman2021D9/","link":"","permalink":"https://qi-xiang.github.io/2021/10/22/ironman2021D9/","excerpt":"","text":"前言JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標學會使用一些操作 console 的 JS 方法。 在網頁元素上設置斷點在下面的例子中，只要我們點擊文字，文字就會變大並且顏色變為綠色。 現在假設我們知道這個效果是經由 JS 之手做出來，但不知道實際上是 JS 的哪一部分發揮功能。這個時候，我們可以利用網頁的檢查功能來設定 JS 執行時的 break point，讓它在觸發效果的那一行 JS 程式碼停下來。 首先打開網頁的檢查功能，將要查看變化的元素標籤選起來並按右鍵選擇 break on -&gt; attribute modification。 接著點擊文字，會發現文字的顏色改變，但文字大小卻沒有改變。 這是因為我們在這個元素標籤上設定了一個只要屬性值改變就觸發的斷點，所以執行到 JS 的 p.style.color = &#39;#BADA55&#39;; 修改到標籤屬性就停止繼續往下執行下一行 JS。 如果想要繼續執行下一行 JS，只要按圖片中的藍色播放鈕，它就會跳到下一行繼續執行，同時也可以發現文字變大。 總而言之，在元素標籤上設定斷點是 debug 的一個好方法，我們可以逐步觀察程式碼的執行過程並快速找出問題點。 一些有關 console 的 JS 方法1. console.log()Regular: 直接輸出字串到 console 上。 Interpolated: 格式化輸出字串到 console 上，類似 Java 的 printf 方法。 Styled: 在輸出字串到 console 的同時，用指定的 CSS 修飾字串。 12345678// Regularconsole.log(&#x27;Hello World&#x27;)// Interpolatedconsole.log(&#x27;I am very interested in %s animation.&#x27;,&#x27;Japanese&#x27;);// Styledconsole.log(&#x27;%c I am very interested in Japanese animation.&#x27;,&#x27;font-weight: bold;background: skyblue;color:white;font-size:20px;&#x27;); 2. console.warn()呼叫console.warn()在 console 輸出警告訊息。 12// warning!console.warn(&#x27;Something is wrong!&#x27;); 3. console.error()呼叫console.error()在 console 輸出錯誤訊息。 12// Errorconsole.error(&#x27;There is a fatal error!&#x27;); 4. console.info()呼叫console.info()在 console 輸出提示訊息。 12// Infoconsole.info(&#x27;info message&#x27;); 5. console.assert()呼叫console.assert()時，若前方的判斷結果回傳 false 則印出後方字串到 console 上。 123// Testingconst p = document.querySelector(&#x27;p&#x27;);console.assert(p.classList.contains(&#x27;ouch&#x27;),&#x27;That is wrong!&#x27;); 6. console.clear()呼叫console.clear()清空 console 的內容。 12// clearingconsole.clear(); 7. console.dir()呼叫console.log(DOM Element)輸出該元素標籤到 console 上。 呼叫console.dir(DOM Element)以 JSON 格式將該元素的 property 全部輸出到 console 上。 不過我在 console 看到的結果是相同的。 123// Viewing DOM Elementsconsole.log(p);console.dir(p); 8. console.group()/groupEnd()呼叫console.group(label);進行分組、console.groupEnd(label);結束分組。 label: 組別名稱 如果初始呼叫的是console.groupCollapsed(label)，則會預設以摺疊方式呈現。 123456789// Grouping togetherdogs.forEach(dog =&gt; &#123; //console.groupCollapsed(`$&#123;dog.name&#125;`); console.group(`$&#123;dog.name&#125;`); console.log(`This is $&#123;dog.name&#125;.`); console.log(`$&#123;dog.name&#125; is $&#123;dog.age&#125; years old.`); console.log(`$&#123;dog.name&#125; is $&#123;dog.age * 7&#125; years old.`); console.groupEnd(`$&#123;dog.name&#125;`);&#125;) 呼叫console.group(label) 呼叫console.groupCollapsed(label) 9. console.count()呼叫console.count(label);可以得到 label 出現過的次數。 1234567// countingconsole.count(&#x27;Saber&#x27;);console.count(&#x27;Saber&#x27;);console.count(&#x27;Saber&#x27;);console.count(&#x27;Miku&#x27;);console.count(&#x27;Saber&#x27;);console.count(&#x27;Miku&#x27;); 10. console.time()/timeEnd()呼叫console.time()/timeEnd()可以取得執行到某一行 JS 經過的時間。 12345678// timingconsole.time(&#x27;fetching data&#x27;);fetch(&#x27;https://api.github.com/users/wesbos&#x27;) .then(data =&gt; data.json()) .then(data =&gt; &#123; console.timeEnd(&#x27;fetching data&#x27;); console.log(data); &#125;); 補充資料:Console API reference","categories":[],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第八天","slug":"ironman2021D8","date":"2021-10-22T06:35:55.000Z","updated":"2021-10-22T06:40:30.257Z","comments":true,"path":"2021/10/22/ironman2021D8/","link":"","permalink":"https://qi-xiang.github.io/2021/10/22/ironman2021D8/","excerpt":"","text":"前言JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標使用 JavaScript 實作出能在 HTML Canvas 上用筆刷畫圖的極簡版小畫家。 解析程式碼HTML 部分在 body 內放入 canvas 標籤作為我們的畫布，這裡雖然指定大小為 800*800，但之後會利用 JS 把它改成跟視窗(window)一樣大。 1&lt;canvas id=&quot;draw&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; JS 部分取得 canvas 標籤後，將畫布的寬、高，將其改成跟視窗內部的寬、高一樣的數值。 123const canvas = document.querySelector(&#x27;#draw&#x27;);canvas.width = window.innerWidth;canvas.height = window.innerHeight; canvas 只是一個空白的畫布，實際上我們需要“取得畫布的渲染環境(rendering context)”才能在渲染環境上作畫。 我們呼叫 canvas 的 getContext() 方法並放入 “2d” 作為參數，順利取得 canvas 的 2D 渲染環境，若是要取得 3D 渲染環境只要放入 “3d” 作為參數就好。 緊接著，我們調整 context 的 strokeStyle 屬性值，更改作畫時的畫筆顏色。 context 的 lineJoin 是用來設定兩條長度不為0的線段如何在接合處連接，把值設定為 “round” 則在相連部分以扇形連接。 context 的 lineCap 是用來設定線段末端的呈現方式，把值設定為 “round” 則在末端部分以扇形呈現。 context 的 lineWidth 用來設定線條的粗細。 12345const ctx = canvas.getContext(&#x27;2d&#x27;);ctx.strokeStyle = &#x27;#BADASS&#x27;;ctx.lineJoin = &#x27;round&#x27;;ctx.lineCap = &#x27;round&#x27;;ctx.lineWidth = 100; 我們希望在視窗下按住滑鼠拖曳時作畫，所以在 canvas 上註冊4個事件監聽器。 觸發’mousedown’事件時，設定 isDrawing = true，表示現在可以作畫；設定 [lastX,lastY] = [e.offsetX,e.offsetY]，更新作畫的起始點。 觸發’mousemove’事件時，用 draw() 方法持續的進行作畫。 觸發’mouseup’、’mouseout’時，皆設定 isDrawing = false，表示在滑鼠沒被按住和滑鼠離開視窗的情況下都停止作畫。 123456789101112let isDrawing = false;//flaglet lastX = 0;let lastY = 0;canvas.addEventListener(&#x27;mousemove&#x27;,draw);canvas.addEventListener(&#x27;mousedown&#x27;,(e)=&gt; &#123; isDrawing = true; [lastX,lastY] = [e.offsetX,e.offsetY]; &#125;);canvas.addEventListener(&#x27;mouseup&#x27;,()=&gt; isDrawing = false);canvas.addEventListener(&#x27;mouseout&#x27;,()=&gt; isDrawing = false); 事件處理方法 draw()，在最初就先判斷現在能不能作畫，不能的話(isDrawing = false)就直接返回。 ctx.beginPath() 用來建立一個新的作畫路徑。ctx.moveTo() 用來移動路徑起始點的座標。ctx.lineTo() 用來指定這條路徑的終點座標。ctx.stroke() 將這條路徑描出來。 [lastX,lastY] = [e.offsetX,e.offset] 用來不斷更新”此次”按住滑鼠拖曳作畫過程中持續變動的路徑起始點。 1234567891011function draw(e)&#123; if(!isDrawing) return; ctx.beginPath(); //start from ctx.moveTo(lastX,lastY); //go to ctx.lineTo(e.offsetX,e.offsetY); ctx.stroke(); [lastX,lastY] = [e.offsetX,e.offsetY];&#125; HSL 的 H(Hue，色相角度)，是由 0~360 為止的色相循環，0是紅色、120是綠色、240是藍色，Hue 本身不加單位，詳細說明可以參考下方補充資料 CSS Coke 大大的文章。 宣告 hue 變數指定畫筆顏色，並持續的將 hue + 1，當 hue &gt;= 360時，代表顏色已經循環過一次，故將其重設為0。 宣告 direction 變數作為目前該加粗畫筆還是讓畫筆變細的判斷，direction 的初始值是 true 也就是讓畫筆變粗。第一個 if 判斷目前的畫筆粗細是不是 &gt;= 100 或 &lt;= 1，如果條件符合就將 direction 變為相反值(true 變 false)。在第二個的 if-else 判斷，如果 direction = true 就加粗畫筆、反之則讓畫筆變得更細。 123456789101112131415161718192021let hue = 0;let direction = true;function draw(e)&#123; /*.......省略*/ ctx.strokeStyle = `hsl($&#123;hue&#125;,100%,50%)`; /*.......省略*/ hue++; if(hue &gt;= 360)&#123; hue = 0; &#125; if(ctx.lineWidth &gt;= 100 || ctx.lineWidth &lt;= 1)&#123; direction = !direction; &#125; if(direction)&#123; ctx.lineWidth++; &#125;else&#123; ctx.lineWidth--; &#125;&#125; 最後來介紹一個特別的東西，ctx 的 globalCompositeOperation，主要用來處理疊圖(線段重疊)的情況，若將其設定為 ‘multiply’ 則將上層像素與相對應的下層像素相乘，整體效果是讓顏色更加趨於黑色。 1ctx.globalCompositeOperation = &#x27;multiply&#x27;; 補充資料:Canvas 基本用途CanvasRenderingContext2D.strokeStyleCanvasRenderingContext2D.lineJoinCanvasRenderingContext2D.lineCapCanvasRenderingContext2D.lineWidthCanvasRenderingContext2D.beginPath()CanvasRenderingContext2D.moveTo()CanvasRenderingContext2D.lineTo()RGB、HSL、Hex 網頁色彩碼，看完這篇全懂了JS一秒區分clientX,offsetX,screenX,pageX之間關係CanvasRenderingContext2D.globalCompositeOperation 範例網頁請按此","categories":[],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第七天","slug":"ironman2021D7","date":"2021-10-22T06:35:50.000Z","updated":"2021-10-22T06:38:41.490Z","comments":true,"path":"2021/10/22/ironman2021D7/","link":"","permalink":"https://qi-xiang.github.io/2021/10/22/ironman2021D7/","excerpt":"","text":"前言JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標練習使用JS Array 的 some()、every()、find()、findIndex()。 解析程式碼JS 部分練習題使用到的資料: 1234567891011121314const people = [ &#123; name: &#x27;Wes&#x27;, year: 1988 &#125;, &#123; name: &#x27;Kait&#x27;, year: 1986 &#125;, &#123; name: &#x27;Irv&#x27;, year: 1970 &#125;, &#123; name: &#x27;Lux&#x27;, year: 2015 &#125;];const comments = [ &#123; text: &#x27;Love this!&#x27;, id: 523423 &#125;, &#123; text: &#x27;Super good&#x27;, id: 823423 &#125;, &#123; text: &#x27;You are the best&#x27;, id: 2039842 &#125;, &#123; text: &#x27;Ramen is my fav food ever&#x27;, id: 123523 &#125;, &#123; text: &#x27;Nice Nice Nice!&#x27;, id: 542328 &#125;]; 1. Is at least one person 19 or older?Array.prototype.some() some() 可以給定一個函式，測試陣列中是否至少有一個元素符合指定的條件，該方法回傳的是布林值。 Date 建立一個 JavaScript Date 物件來取得某個時間點。Date 物件是從世界標準時間（UTC） 1970 年 1 月 1 日開始算起。 第一題，我們檢查是否至少有一個 person 的年紀大於 19歲。指定一個 function 到 some() 中，在 function 裡面，我們宣告一個常數 currentYear來存放現在的年份，之後透過 if 判斷用現在的年份減去 person 的出生年，是否大於19，如果大於19就返回 true。 基本版:12345const isAdult = people.some(function(person)&#123; const currentYear = (new Date()).getFullYear(); if(currentYear - person.year &gt;= 19) return true;&#125;); 簡化版:1234const isAdult = people.some(person =&gt; &#123; const currentYear = (new Date()).getFullYear(); return currentYear - person.year &gt; 19;&#125;); 更簡化版:123const isAdult = people.some(person =&gt; (new Date().getFullYear()) - person.year &gt;= 19 );console.log(isAdult); 2. Is everyone 19 or older?Array.prototype.every() every() 方法會測試陣列中的所有元素是否都符合函式所指定的條件，若全部元素都符合則返回 true，反之則返回 false。 我們使用 every() 方法，將陣列元素一個個的拿出來做條件判斷，若是有其中一個元素經過計算不符合設定的規則就 return false。 123const allAdults = people.every(person =&gt; (new Date().getFullYear()) - person.year &gt;= 19 );console.log(allAdults); 3. Find the comment with the ID of 823423.Array.prototype.find() find() 方法會回傳第一個符合函式定義條件的元素值，若沒有元素符合條件就回傳undefined。 下面我們使用 find() 找出 comment id 是 823423 的 comment。這邊是用===而不是==進行相等運算，因為在 js 中使用 == 進行相等運算，js 會幫你偷偷地轉換型別再進行比較，例如: &#39;99&#39; == 99 的結果就會是 true。===則是嚴格的相等運算，js 不會偷偷的做資料轉型，兩邊資料型態只要不一致，自然就會回傳 false。 基本版: 12345const comment = comments.find(function(comment)&#123; if(comment.id === 823423)&#123; return true; &#125;&#125;); 簡化版: 123const comment = comments.find(comment =&gt; comment.id === 823423);console.log(comment); 4. Delete the comment with the ID of 823423.Array.prototype.findIndex() findIndex()方法將按照指定的函式，尋找陣列中第一個符合條件的元素，並回傳元素的 index（索引）。如果沒有找到符合的元素就回傳 -1 。 Array.prototype.slice() slice()方法會回傳一個新的陣列，它會切割出原陣列從索引 begin 至 end（不含 end）的元素。原本的陣列不會被影響。 我們使用 findIndex() 尋找到第一個 comment id 是 823423 的元素並取得該元素的索引值(index)。 透過 slice()將陣列進行切割，我們可以將找出的元素值從陣列中移除並宣告常數承接回傳的新陣列。(複習一下，前面說過...可以把陣列中的元素一個個地展開。) 1234567891011const index = comments.findIndex(comment =&gt; comment.id === 823423);console.log(index);const newComments = [ ...comments.slice(0,index), ...comments.slice(index + 1)];console.table(comments);console.table(newComments); 補充資料:相等比較 ===、==Array.prototype.slice()Array.prototype.findIndex()Array.prototype.find()Array.prototype.every()DateArray.prototype.some()","categories":[],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第六天","slug":"ironman2021D6","date":"2021-10-22T06:27:37.000Z","updated":"2021-10-22T06:34:08.414Z","comments":true,"path":"2021/10/22/ironman2021D6/","link":"","permalink":"https://qi-xiang.github.io/2021/10/22/ironman2021D6/","excerpt":"","text":"前言JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標利用 Fetch API 取得 JSON 格式的資料，隨著輸入關鍵字的不同，將特定資料篩選出來並呈現在網頁上。 解析程式碼JS 部分將要取得的資料來源網址放入 endpoint中，並建立一個空的city陣列。 123const endpoint = &#x27;https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json&#x27;;const cities = [];/*empty array*/ fetch() 是 Fetch API 的一個方法，主要用於發出資料的 request 並回傳 Promise，有點類似於XMLHttpRequest，但在使用上較有彈性。 Promise 物件代表的是一個將要完成或失敗的非同步操作，以及它所產生的值。 then() 方法最多需要兩個參數，分別作為 Promise 成功和失敗時的 callback function 並返回 Promise。 json() 方法會接收一個 response stream，在讀取完成之後返回一個解析成 JSON 格式的 Promise。 我們透過 fetch() 向 endpoint 發送 request，之後將 return 的 Promise 以 json 格式進行解構，最後將這些資料一筆筆的 push 到空的 cities 陣列中。...data的主要用意在於將原本的 data 陣列中的元素個別拆出來放進 cities 裡面，如果直接寫cities.push(data)則 data 會變成在 cities 內部的一個陣列型態元素。 123fetch(endpoint) .then(blob =&gt; blob.json()) .then(data =&gt; cities.push(...data)); findMatches() 需要用到兩個參數，wordToMatch 用來傳入要尋找的文字，cities 則是原本的資料陣列，最後回傳經過 filter() 過濾後的 cities 陣列。 在 filter() 裡，我們將 cities 的每一個元素用 RegExp 物件進行正規表示式的字元比對，之後將包含關鍵字的 city 或是 state回傳。 RegExp() 用來建立一個正規表達式的物件，wordToMatch 是要進行比對的內容，&#39;gi&#39;則是 flag，g 代表搜尋出所有符合比對的文字，而不是比對出第一筆就停止，i 代表比對時不分大小寫。 123456function findMatches(wordToMatch, cities)&#123; return cities.filter(place =&gt; &#123; const regex = new RegExp(wordToMatch,&#x27;gi&#x27;); return place.city.match(regex) || place.state.match(regex); &#125;)&#125; numberWithCommas() 主要用來幫我們在每三位數字加上逗號(ex.1,000)。toString() 可以幫我們將 x 轉成字串，之後利用 replace() 進行正規表示式的判斷並取代字元。 123function numberWithCommas(x)&#123; return x.toString().replace(/\\B(?=(\\d&#123;3&#125;)+(?!\\d))/g,&#x27;,&#x27;);&#125; 宣告 matchArray 並放入找到的結果陣列。接著，將陣列中的元素換成 HTML 的格式。再來宣告一個 Regex 物件，然後宣告兩個常數並各自以正規表示式判斷並取代(replace)原有的文字內容，改以 HTML 的方式呈現。 之後，透過 Template literals 的格式傳回一個&lt;li&gt;...&lt;/li&gt;。最後，使用 join() 將陣列中的所有元素以空字串為分隔，形成一個很長的字串再放入.suggestions的標籤中。 123456789101112131415function displayMatches()&#123; const matchArray = findMatches(this.value,cities); const html = matchArray.map(place =&gt;&#123; const regex = new RegExp(this.value, &#x27;gi&#x27;); const cityName = place.city.replace(regex,`&lt;span class=&quot;hl&quot;&gt;$&#123;this.value&#125;&lt;/span&gt;`); const stateName = place.state.replace(regex,`&lt;span class=&quot;hl&quot;&gt;$&#123;this.value&#125;&lt;/span&gt;`); return ` &lt;li&gt; &lt;span class=&quot;name&quot;&gt;$&#123;cityName&#125;, $&#123;stateName&#125;&lt;/span&gt; &lt;span class=&quot;ppulation&quot;&gt;$&#123;numberWithCommas(place.population)&#125;&lt;/span&gt; &lt;/li&gt; ` &#125;).join(&#x27;&#x27;); suggestions.innerHTML = html;&#125; 分別宣告常數 searchInput、suggestions 並取得 .search、.suggestions標籤。最後為搜尋欄(searchInput) 註冊change和keyup事件，當欄位數值發生改變或放開鍵盤的那個剎那都會觸發事件，兩個事件都是以 displayMatches() 進行事件處理。 12345const searchInput = document.querySelector(&#x27;.search&#x27;);const suggestions = document.querySelector(&#x27;.suggestions&#x27;);searchInput.addEventListener(&#x27;change&#x27;,displayMatches)searchInput.addEventListener(&#x27;keyup&#x27;,displayMatches); 補充資料:Promise使用 FetchPromise.prototype.then()Response.json()Spread syntax (…)RegExp()比較 keydown, keypress, keyup 的差異 實際效果請按此","categories":[],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第五天","slug":"ironman2021D5","date":"2021-10-22T06:27:31.000Z","updated":"2021-10-22T06:30:34.585Z","comments":true,"path":"2021/10/22/ironman2021D5/","link":"","permalink":"https://qi-xiang.github.io/2021/10/22/ironman2021D5/","excerpt":"","text":"前言JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標利用 flexbox、transition 等 CSS 屬性，搭配 JS 監聽 transitionend、click 事件，最終實作出一個美觀的 Image Gallery。 解析程式碼HTML 部分由最外層的.panels包覆住內部的5個.panel所形成的一個巢狀結構。 123456789101112131415161718192021222324252627&lt;div class=&quot;panels&quot;&gt; &lt;div class=&quot;panel panel1&quot;&gt; &lt;p&gt;Hey&lt;/p&gt; &lt;p&gt;Let&#x27;s&lt;/p&gt; &lt;p&gt;Dance&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel panel2&quot;&gt; &lt;p&gt;Give&lt;/p&gt; &lt;p&gt;Take&lt;/p&gt; &lt;p&gt;Receive&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel panel3&quot;&gt; &lt;p&gt;Experience&lt;/p&gt; &lt;p&gt;It&lt;/p&gt; &lt;p&gt;Today&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel panel4&quot;&gt; &lt;p&gt;Give&lt;/p&gt; &lt;p&gt;All&lt;/p&gt; &lt;p&gt;You can&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel panel5&quot;&gt; &lt;p&gt;Life&lt;/p&gt; &lt;p&gt;In&lt;/p&gt; &lt;p&gt;Motion&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; CSS 部分(僅說明影片中更動的部分) 先將最外層的 .panels 顯示類型設定為 flex，它同時也作為一個 flex-container 包覆住內部的五個 flex-items 也就是 .panel。 1234.panels &#123; /*其餘略過*/ display: flex;&#125; flex 是 flex-grow、flex-shrink、flex-basis 的簡寫，只有指定一個值給 flex 時，則代表設定的是 flex-grow，其餘屬性以預設值帶入。 flex-grow 可以指定 flex-container 的剩餘空間該如何分配，下面所有的 .panel 的 flex-grow 都是 1，也就是均勻分配剩餘空間。 接著，將每一個 .panel 的顯示類型都設定為 flex (此時的.panel 對下面的&lt;p&gt;&lt;/p&gt;來說就是 flex-container) 並將其下的 flex-item 在水平、鉛直方向都置中。 最後，設定 flex-direction 將 flex-box 的 main-axis 更改為直列。 1234567.panel &#123; flex: 1; /*將每個 flex-item 的大小都設為一樣並填滿*/ display: flex; justify-content: center; /*在水平方向置中*/ align-items: center;/*在鉛直方向置中*/ flex-direction: column; &#125; 將 .panel (flex-container)下的 &lt;p&gt;&lt;/p&gt; (flex-item) 的 flex 屬性設定為 1、0、auto，也就是均勻分配 flex-container 的剩餘空間、flex-item 長度超過 flex-container 時的收縮量設為 0、flex-item 在 flex container 的初始大小設為自動(auto)。 接著，也將&lt;p&gt;&lt;/p&gt;當作是一個 flex-container，設定顯示類型為 flex。透過 justify-content、align-items，將標籤內的文字(flex-item) 水平、鉛直置中排列。 1234567.panel &gt; * &#123; /*其餘省略*/ flex: 1 0 auto; display: flex; justify-content: center; align-items: center;&#125; 初始狀態，分別將在 .panel 上方和下方的 &lt;p&gt;&lt;/p&gt; 都各上移、下移 100% 以達到隱藏的效果。 123456.panel &gt; *:first-child&#123; transform: translateY(-100%);/*上移*/&#125;.panel &gt; *:last-child&#123; transform: translateY(100%);/*下移*/&#125; 接著設定當.panel上有open-active這個 class 時，就將原本隱藏的文字分別下移和上移顯示出來。 123456.panel.open-active &gt; *:first-child&#123; transform: translateY(0);&#125;.panel.open-active &gt; *:last-child&#123; transform: translateY(0);&#125; .panel開啟時，將內部文字放大為 40px 並將 flex-container 剩餘分配的位置變為原來的5倍。 1234.panel.open &#123; font-size: 40px; flex: 5;&#125; 補充資料:CSS flex 屬性圖解 Flexbox 基本屬性FLEXBOX FROGGY-學習 flexbox 的小遊戲 JS 部分取得所有的.panel 並放到 NodeList &#39;panels&#39; 中。 1const panels = document.querySelectorAll(&#x27;.panel&#x27;); 為 panels 中的每一個.panel都註冊兩個事件監聽器，當 click 或 transitionend 事件發生時，就分別以 toggleOpen 和 toggleActive 方法進行事件處理。 12panels.forEach(panel =&gt; panel.addEventListener(&#x27;click&#x27;,toggleOpen));panels.forEach(panel =&gt; panel.addEventListener(&#x27;transitionend&#x27;,toggleActive)); 點擊任意一個.panel，toggleOpen() 方法會替觸發事件的.panel依照情況的不同，新增或是移除.open 這個 class，若是觸發事件的.panel原本沒有.open則新增，有的話則移除.open。 當 transitionend 事件發生，toggleActive() 會作出如同 toggleOpen() 一樣的判斷，決定新增還是移除.open-active這個 class。因為同時會被觸發的 transitionend 事件有很多個，我們決定在觸發 transitionend 事件的 CSS 屬性是 flex 時，才採取處理。為什麼不寫 e.propertyName == &#39;flex-grow&#39; 是因為在 Safari 顯示的是 flex 而 Chrome、FireFox 顯示的是 flex-grow，為避免這個差異導致錯誤，我們可以使用 include(‘flex’)，當 propertyName 含有 flex 就進行事件處理。 123456789function toggleOpen()&#123; this.classList.toggle(&#x27;open&#x27;);&#125;function toggleActive(e)&#123; if(e.propertyName.includes(&#x27;flex&#x27;))&#123; this.classList.toggle(&#x27;open-active&#x27;); &#125;&#125; 補充資料:Element.classList String.prototype.includes() 實際效果請按此","categories":[],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第四天","slug":"ironman2021D4","date":"2021-10-22T06:23:16.000Z","updated":"2021-10-22T06:25:03.400Z","comments":true,"path":"2021/10/22/ironman2021D4/","link":"","permalink":"https://qi-xiang.github.io/2021/10/22/ironman2021D4/","excerpt":"","text":"前言JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標練習一些 Array 常用的方法，包括 filter()、sort()、map()、reduce()。 解析程式碼JS 部分前七個練習題要使用的資料如下: 12345678910111213141516171819202122232425262728/*JS*/// Get your shorts on - this is an array workout!// ## Array Cardio Day 1// Some data we can work withconst inventors = [ &#123; first: &#x27;Albert&#x27;, last: &#x27;Einstein&#x27;, year: 1879, passed: 1955 &#125;, &#123; first: &#x27;Isaac&#x27;, last: &#x27;Newton&#x27;, year: 1643, passed: 1727 &#125;, &#123; first: &#x27;Galileo&#x27;, last: &#x27;Galilei&#x27;, year: 1564, passed: 1642 &#125;, &#123; first: &#x27;Marie&#x27;, last: &#x27;Curie&#x27;, year: 1867, passed: 1934 &#125;, &#123; first: &#x27;Johannes&#x27;, last: &#x27;Kepler&#x27;, year: 1571, passed: 1630 &#125;, &#123; first: &#x27;Nicolaus&#x27;, last: &#x27;Copernicus&#x27;, year: 1473, passed: 1543 &#125;, &#123; first: &#x27;Max&#x27;, last: &#x27;Planck&#x27;, year: 1858, passed: 1947 &#125;, &#123; first: &#x27;Katherine&#x27;, last: &#x27;Blodgett&#x27;, year: 1898, passed: 1979 &#125;, &#123; first: &#x27;Ada&#x27;, last: &#x27;Lovelace&#x27;, year: 1815, passed: 1852 &#125;, &#123; first: &#x27;Sarah E.&#x27;, last: &#x27;Goode&#x27;, year: 1855, passed: 1905 &#125;, &#123; first: &#x27;Lise&#x27;, last: &#x27;Meitner&#x27;, year: 1878, passed: 1968 &#125;, &#123; first: &#x27;Hanna&#x27;, last: &#x27;Hammarström&#x27;, year: 1829, passed: 1909 &#125;];const people = [ &#x27;Bernhard, Sandra&#x27;, &#x27;Bethea, Erin&#x27;, &#x27;Becker, Carl&#x27;, &#x27;Bentsen, Lloyd&#x27;, &#x27;Beckett, Samuel&#x27;, &#x27;Blake, William&#x27;, &#x27;Berger, Ric&#x27;, &#x27;Beddoes, Mick&#x27;, &#x27;Beethoven, Ludwig&#x27;, &#x27;Belloc, Hilaire&#x27;, &#x27;Begin, Menachem&#x27;, &#x27;Bellow, Saul&#x27;, &#x27;Benchley, Robert&#x27;, &#x27;Blair, Robert&#x27;, &#x27;Benenson, Peter&#x27;, &#x27;Benjamin, Walter&#x27;, &#x27;Berlin, Irving&#x27;, &#x27;Benn, Tony&#x27;, &#x27;Benson, Leana&#x27;, &#x27;Bent, Silas&#x27;, &#x27;Berle, Milton&#x27;, &#x27;Berry, Halle&#x27;, &#x27;Biko, Steve&#x27;, &#x27;Beck, Glenn&#x27;, &#x27;Bergman, Ingmar&#x27;, &#x27;Black, Elk&#x27;, &#x27;Berio, Luciano&#x27;, &#x27;Berne, Eric&#x27;, &#x27;Berra, Yogi&#x27;, &#x27;Berry, Wendell&#x27;, &#x27;Bevan, Aneurin&#x27;, &#x27;Ben-Gurion, David&#x27;, &#x27;Bevel, Ken&#x27;, &#x27;Biden, Joseph&#x27;, &#x27;Bennington, Chester&#x27;, &#x27;Bierce, Ambrose&#x27;, &#x27;Billings, Josh&#x27;, &#x27;Birrell, Augustine&#x27;, &#x27;Blair, Tony&#x27;, &#x27;Beecher, Henry&#x27;, &#x27;Biondo, Frank&#x27;]; 1. Filter the list of inventors for those who were born in the 1500’sArray.prototype.filter() filter() 方法會透過指定的函式運算，決定保留哪些資料並形成一個新的陣列。 在 filter 裡 return true 代表要保留該筆資料，除此之外的資料都會被捨棄，我們沒必要再寫 else 去 return false。 filter() 的詳細內容 以下我們透過 filter() 過濾”出生於16世紀的發明家” 123456/*JS*/const fifteen = inventors.filter(function(inventor)&#123; if(inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt; 1600)&#123; return true; //keep it in the new array &#125;&#125;)/*除了有回傳true之外的東西都會被丟掉，不必再用else return false*/ 更簡潔的寫法: console.table()，可以將 Array 以表格的形式呈現出來。 123/*JS*/const fifteen = inventors.filter(inventor =&gt; (inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt; 1600));console.table(fifteen); 2. Give us an array of the inventors first and last namesArray.prototype.map() map() 方法會建立一個和原陣列長度相同的陣列，其內容為原陣列的每一個元素經由指定的函式運算後所回傳的結果之集合。 map() 的詳細內容 以下我們使用 map() 方法，將發明家的 first name 和 last name 結合在一起，形成一個新的陣列。 123/*JS*/const fullNames = inventors.map(inventor =&gt; `$&#123;inventor.first&#125; $&#123;inventor.last&#125;`); /*Template literals*/console.table(fullNames); 3. Sort the inventors by birthdate, oldest to youngestArray.prototype.sort() sort() 方法會對一個陣列中的所有元素進行排序，並回傳此陣列，預設是以字串的 Unicode 編碼進行排序。 我們也可以指定一個 compareFunction ，用自訂的排序規則為陣列進行排序。 compareFunction(a, b)，回傳值小於0時，a 會被排在 b 的前面，反之若回傳值大於0時，a 會被排在 b 的後面。 sort() 的詳細內容 以下我們使用 sort()，將較早出生的發明家排在前面的位置。 1234567const ordered = inventors.sort(function(a,b)&#123; if(a.year &gt; b.year)&#123; return 1; /*a 往後排*/ &#125;else&#123; return -1; /*a 往前排*/ &#125;&#125;) 更簡潔的寫法: 12const ordered = inventors.sort((a,b) =&gt; a.year &gt; b.year ? 1 : -1);console.table(ordered); 4. How many years did all the inventors live all together?Array.prototype.reduce() reduce() 方法將一個累加器(accumulator)及陣列中每項元素傳入函式中進行運算，將陣列化為單一的值。 其中一種用法如下: 123Array.reduce((accumulator,currentValue) =&gt; &#123; return accumulator + currentValue; &#125;,initialValue); /*initialValue 是 accumulator 的初始值*/ reduce() 的詳細內容 12345const totalYears = inventors.reduce((total,inventor)=&gt;&#123; return total + (inventor.passed - inventor.year);&#125;,0);console.log(totalYears); 5. Sort the inventors by years lived以下，我們將這些發明家依照壽命的長短由大到小進行排序。透過 passed - year，我們可以很簡單的算出每一位發明家的壽命。 1234567const oldest = inventors.sort(function(a,b)&#123; const lastGuy = a.passed - a.year; const nextGuy = b.passed - b.year; return lastGuy &gt; nextGuy ? -1 : 1;&#125;);console.table(oldest) 6. Create a list of Boulevards in Paris that contain ‘de’ anywhere in the name這題我們需要自行到 https://en.wikipedia.org/wiki/Category:Boulevards_in_Paris 右鍵檢查進入 console 進行解題。 Node.textContent Node.textContent 可以取得節點或其後代的文字內容。 textContent 的詳細內容 Array.prototype.includes() includes() 方法會判斷陣列是否包含特定的元素，並以此來回傳 true 或 false。 includes() 的詳細內容 Array.from() Array.from() 方法會從類陣列（array-like，例如: NodeList）或是可迭代（iterable）物件建立一個新的 Array 實體。 from() 的詳細內容 首先，我們取得包覆所有巴黎大道名稱的最上層 div 標籤(.mw-category)。接著，取得在其之下的所有連結(a)。最後，使用 map() 方法以所有連結的內部文字組成新陣列並透過 filter() 過濾出包含(include)’de’的所有大道名稱。 123456const category = document.querySelector(&#x27;.mw-category&#x27;);const links = Array.from(category.querySelectorAll(&#x27;a&#x27;));/*NodeList*/const de = links.map(link =&gt; link.textContent).filter(streetName =&gt; streetName.includes(&#x27;de&#x27;));console.table(de); 7. Sort the people alphabetically by last nameString.prototype.split() split()方法可以使用指定的分隔字元(separator)將一個String分割成串列。 split() 的詳細說明 以下，用, (逗號和空格)作為分隔字元將 first name、last name 切開並放入一個陣列中，接下來就可以依照 aLast、bLast 的 Unicode 進行 last name 的排序(由小到大)。 12345const alpha = people.sort(function(lastOne,firstOne)&#123; const [aLast,aFirst] = lastOne.split(&#x27;, &#x27;); const [bLast,bFirst] = firstOne.split(&#x27;, &#x27;); return aLast &gt; bLast ? 1 : -1;&#125;); 另一種寫法: 12345const alpha = people.sort((lastOne,firstOne) =&gt; &#123; const [aLast,aFirst] = lastOne.split(&#x27;, &#x27;); const [bLast,bFirst] = firstOne.split(&#x27;, &#x27;); return aLast &gt; bLast ? 1 : -1;&#125;); 8. Sum up the instances of each of these資料內容: 1const data = [&#x27;car&#x27;, &#x27;car&#x27;, &#x27;truck&#x27;, &#x27;truck&#x27;, &#x27;bike&#x27;, &#x27;walk&#x27;, &#x27;car&#x27;, &#x27;van&#x27;, &#x27;bike&#x27;, &#x27;walk&#x27;, &#x27;car&#x27;, &#x27;van&#x27;, &#x27;car&#x27;, &#x27;truck&#x27; ]; 一開始賦予累加器(obj)的初始值(initial value)為空物件({})，因為最初所有的 item 都不存在於 obj 中，所以透過 if 判斷當 obj[item] 不存在時，就建立 obj[item] 並賦予初始值0。其後就可正常將 item 持續累加至正確的交通工具分類中(obj[item]++)。 123456789const transportation = data.reduce(function(obj,item)&#123; if(!obj[item])&#123; obj[item] = 0; &#125; obj[item]++; return obj;&#125;,&#123;&#125;)console.table(transportation);","categories":[],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第三天","slug":"ironman2021D3","date":"2021-10-22T05:39:53.000Z","updated":"2021-10-22T05:40:34.224Z","comments":true,"path":"2021/10/22/ironman2021D3/","link":"","permalink":"https://qi-xiang.github.io/2021/10/22/ironman2021D3/","excerpt":"","text":"前言JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標學習建立 CSS 變數並透過 JavaScript 監聽 mousemove、change 事件，接著主動去更新變數的值，讓使用者得以調整圖片框的大小和背景色、圖片的模糊程度等等…。 解析程式碼HTML 部分由最外層的代表控制列(.controls)的div元素包覆住內部用來調整圖片的三個 input 元素(#spacing、#blur、#base)。其中兩個 input 元素上有設定 data- 屬性，標明使用的單位。 1234567891011121314&lt;h2&gt;Update CSS Variables with &lt;span class=&#x27;hl&#x27;&gt;JS&lt;/span&gt;&lt;/h2&gt;&lt;div class=&quot;controls&quot;&gt; &lt;label for=&quot;spacing&quot;&gt;Spacing:&lt;/label&gt; &lt;input id=&quot;spacing&quot; type=&quot;range&quot; name=&quot;spacing&quot; min=&quot;10&quot; max=&quot;200&quot; value=&quot;10&quot; data-sizing=&quot;px&quot;&gt; &lt;label for=&quot;blur&quot;&gt;Blur:&lt;/label&gt; &lt;input id=&quot;blur&quot; type=&quot;range&quot; name=&quot;blur&quot; min=&quot;0&quot; max=&quot;25&quot; value=&quot;10&quot; data-sizing=&quot;px&quot;&gt; &lt;label for=&quot;base&quot;&gt;Base Color&lt;/label&gt; &lt;input id=&quot;base&quot; type=&quot;color&quot; name=&quot;base&quot; value=&quot;#ffc600&quot;&gt;&lt;/div&gt;&lt;img src=&quot;https://source.unsplash.com/7bwQXzbF6KE/800x500&quot;&gt; CSS 部分用--變數名稱的方式，宣告三個 CSS 的全域變數，並且是在根元素之下。 12345:root&#123; /*CSS 全域變數*/ --base: #ffc600; --spacing: 10px; --blur: 10px;&#125; 要使用 CSS 變數，我們可以利用var()並在裡面放入要使用的變數名稱。 123456789img&#123; padding: var(--spacing); /*使用關鍵字 var( )並在括號內填入想套用的變數名稱*/ background: var(--base); filter: blur(var(--blur)); /*套上帶有模糊效果的濾鏡*/&#125;.hl&#123; color: var(--base);&#125; 補充說明1:CSS 變數的補充資料 &gt;&gt;&gt; :root 根目錄選取器 - 叫你阿爸出來講 補充說明2:使用 CSS 的 filter 屬性，主要目的是套一層濾鏡到圖片上，常見的值除了有 blur 以外，還有 contrast、grayscale 等等…。 詳細見此 JS部分取得所有的 input 標籤，要注意的是這裡的資料型態是 NodeList 而不是 Array。 相較 Array 而言，NodeList 能用的方法少很多。 12/*JS*/const inputs = document.querySelectorAll(&#x27;.controls input&#x27;); /*取得所有的 input 元素，資料型態是 NodeList 不是 Array*/ 將每個取得的 input 標籤都分別註冊兩個事件監聽器，當 input 標籤的 value 屬性有變動(change)或是滑鼠有在 input 標籤的桿上移動時，就透過 handleUpdate() 方法進行事件處理。 123456function handleUpdate()&#123; &#125;inputs.forEach(input =&gt; input.addEventListener(&#x27;change&#x27;,handleUpdate)); /*當數值改變*/inputs.forEach(input =&gt; input.addEventListener(&#x27;mousemove&#x27;,handleUpdate)); /*當滑鼠移動*/ 在 handleUpdate() 方法內宣告 suffix 變數，透過 dataset.sizing 取得對應屬性的單位。當屬性沒有單位時，指定 suffix 為空字串，避免因為是 undefined 出現錯誤。 最後，藉著 document.documentElement.style 取得文件上”根元素”的 CSS 屬性，進一步使用 setProperty() 調整 CSS 屬性值(注意，有些屬性必須要加上單位)。 1234function handleUpdate()&#123; const suffix = this.dataset.sizing || &#x27;&#x27;; /*取得單位，當單位不存在時就指定為空字串*/ document.documentElement.style.setProperty(`--$&#123;this.name&#125;`,this.value + suffix); /*Template literals*/&#125; 補充說明1:NodeList 的補充資料 – JavaScript HTML DOM Node Lists 補充說明2:透過 dataset 實際取得的 data-自訂名稱 屬性內容如下: 我們可以進一步使用 dataset.自訂名稱，取得裡面代表單位的”px”。(圖片中的 sizing 等同於標籤上的 data-sizing) 實際效果請按此","categories":[],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第二天","slug":"ironman2021D2","date":"2021-10-22T05:29:18.000Z","updated":"2021-10-22T05:33:30.620Z","comments":true,"path":"2021/10/22/ironman2021D2/","link":"","permalink":"https://qi-xiang.github.io/2021/10/22/ironman2021D2/","excerpt":"","text":"前言JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標透過 JavaScript 的 Date 物件分別取得”時”、”分”、”秒”並計算出在圓上的相對應角度，最後搭配 CSS 的 transform 和 transition 屬性，製作出一個簡易的時鐘。 解析程式碼HTML 部分由最外層的”clock”部分包住內層的”clock-face”和其內部的”時針”、”分針”、”秒針”，形成一個完整的巢狀結構。 1234567&lt;div class=&quot;clock&quot;&gt; &lt;div class=&quot;clock-face&quot;&gt; &lt;div class=&quot;hand hour-hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hand min-hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hand second-hand&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS 部分首先，將物件 transform 的基準點，更改為最右端。接著，將所有指針都預先固定在12點鐘方向。最後，透過 transition 屬性還有 transition-timing-function屬性，分別調整 CSS animation 效果變化速度和做出指針移動時的彈跳效果。 12345678910111213.hand &#123; width: 50%; height: 6px; background: black; position: absolute; top: 50%; /*以下是影片中教學的部分*/ transform-origin: 100%; /*改變 transform 的 x-axis*/ transform: rotate(90deg); /*初始位置從12點鐘出發*/ transition: all 0.05s; /*調整 CSS animation 變動的速度*/ transition-timing-function: cubic-bezier(0.1, 2.7, 0.58, 1);&#125; 補充說明1:transform 預設是以物件中心作為平移、旋轉、縮放、傾斜時的基準點。詳細內容見此 補充說明2:transition timing function，可用來定義轉場發生的時間曲線，以四個參數的貝茲曲線代表。詳細內容見此 JS 部分首先，分別取得代表”時針”、”分針”、”秒針”的標籤。 1234/*JS*/const secondHand = document.querySelector(&#x27;.second-hand&#x27;);const minsHand = document.querySelector(&#x27;.min-hand&#x27;)const hourHand = document.querySelector(&#x27;.hour-hand&#x27;) 建立 Date 物件，取得”時”、”分”、”秒”的資料，以此算出所應旋轉的角度(注意，角度必須加上早先設定的90度，才會是正確的)，之後分別調整 CSS 的 transform 屬性。 最後用 setInterval() 方法，設定每1000毫秒(1秒)就執行 setDate() 方法一次，藉此動態改變 rotate 的值。 (時針、分針、秒針的原理都一樣，只是在角度計算上有所差異) 123456789101112/*JS*/function setDate()&#123; const now = new Date(); /*時針、分針、秒針的原理都一樣*/ const seconds = now.getSeconds(); const secondsDegrees = ((seconds/60)*360) + 90;/*旋轉的角度要加上預設的90度*/ secondHand.style.transform = `rotate($&#123;secondsDegrees&#125;deg)`;&#125; setInterval(setDate,1000) 分別設定完”時針”、”分針”、”秒針”後，setDate() 方法如下。 1234567891011121314151617/*JS*/function setDate()&#123; const now = new Date(); /*時針、分針、秒針的原理都一樣*/ const seconds = now.getSeconds() const secondsDegrees = ((seconds/60)*360) + 90;/*旋轉的角度要加上預設的90度*/ secondHand.style.transform = `rotate($&#123;secondsDegrees&#125;deg)`; const mins = now.getMinutes(); const minsDegrees = ((mins/60)*360) + 90; minsHand.style.transform = `rotate($&#123;minsDegrees&#125;deg)`; const hours = now.getHours(); const hoursDegrees = ((hours/12)*360) + 90; hourHand.style.transform = `rotate($&#123;hoursDegrees&#125;deg)`;&#125; 以上都完成後，一個簡單的時鐘就出現了。但仔細一看就會發現指針在某個時間點會突然倒轉一圈。 舉”秒針”為例，在59秒~0秒之間，數值上的角度會從444度變為90度(分針也是如此)，整整倒轉354度接近一圈，這就解釋了為什麼指針會有突然倒轉的現象。 而我們可以分別記錄時針和分針所走的圈數，並將原來計算出的度數加上360度*圈數，解決指針倒轉的問題。 用 if 判斷到 0 秒(分)時，就將圈數加1。 12345678910111213141516171819202122232425var secRound = 0; /*紀錄秒針所走圈數*/var minRound = 0; /*紀錄秒針所走圈數*/function setDate()&#123; const now = new Date(); /*時針、分針、秒針的原理都一樣*/ const seconds = now.getSeconds() if(seconds == 0)&#123;/*避免回彈*/ secRound += 1; &#125; const secondsDegrees = ((seconds/60)*360) + 360*secRound + 90;/*旋轉的角度要加上預設的90度*/ secondHand.style.transform = `rotate($&#123;secondsDegrees&#125;deg)`; const mins = now.getMinutes(); if(mins == 0)&#123;/*避免回彈*/ minRound += 1; &#125; const minsDegrees = ((mins/60)*360) + 360*minRound + 90; minsHand.style.transform = `rotate($&#123;minsDegrees&#125;deg)`; const hours = now.getHours(); const hoursDegrees = ((hours/12)*360) + 90; hourHand.style.transform = `rotate($&#123;hoursDegrees&#125;deg)`;&#125; 最後的最後，我們還可以讓指針的位置更加精準。一般而言，秒針每走一格，分針應該跟著移動一點，同理時針也是如此。 對分針而言移動每過一分鐘移動6度，我們可以用 (秒數/60)*6，算出實際上每過一秒鐘，分針應該要跟著移動多少度。 對時針而言移動每過一小時移動30度，我們可以用 (分鐘數/60)*30，算出實際上每過一分鐘，時針應該要跟著移動多少度。 12345678910const mins = now.getMinutes();if(mins == 0)&#123;/*避免回彈*/ minRound += 1;&#125;const minsDegrees = ((mins/60)*360) + 360*minRound + ((seconds/60)*6) + 90;minsHand.style.transform = `rotate($&#123;minsDegrees&#125;deg)`;const hours = now.getHours();const hoursDegrees = ((hours/12)*360) + ((mins/60)*30) + 90;hourHand.style.transform = `rotate($&#123;hoursDegrees&#125;deg)`; 補充說明1:rotate($&#123;hoursDegrees&#125;deg) 是 ES6 Template literals 的寫法。詳細介紹 Template literals 範例網頁請按此","categories":[],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第一天","slug":"ironman2021D1","date":"2021-10-21T16:20:35.000Z","updated":"2021-10-22T05:36:40.695Z","comments":true,"path":"2021/10/22/ironman2021D1/","link":"","permalink":"https://qi-xiang.github.io/2021/10/22/ironman2021D1/","excerpt":"","text":"前言JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標透過監聽 “transitionend 事件” 和 “keydown 事件”，調整 CSS 設定以及播放音效，最終建立一組爵士鼓並依照按下按鍵的不同播放不同的音效伴隨網頁上的 CSS 動畫效果。 解析程式碼HTML 部分基本結構是由最外層的 “keys” 包住內層9個 “key” 的巢狀結構，內層的 “key” 都有 data-key 屬性並有相異的數值，這些相異值在接下來判斷要播放哪個音檔和套用 CSS 設定到哪個 “key” 時很重要。 1234567891011121314151617181920212223242526272829303132333435363738&lt;div class=&quot;keys&quot;&gt; &lt;div data-key=&quot;65&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;A&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;clap&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;83&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;S&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;hihat&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;68&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;D&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;kick&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;70&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;F&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;openhat&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;71&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;G&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;boom&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;72&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;H&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;ride&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;74&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;J&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;snare&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;75&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;K&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;tom&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;76&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;L&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;tink&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 補充說明1:HTML5 新增了 data-* 自定義屬性(data attributes)，讓我們能以 data- 為開頭，建立自訂的屬性和值並隨時可以讀寫在元素上的資料數值，而不會影響到整個版面。 程式碼中的 data-key 就是一個不錯的例子。 補充說明2:&lt;kbd&gt; 是一個行內元素 (inline element) ，用來標示鍵盤符號。 JS 部分首先，我們先依照按下按鍵的 keyCode 取得特定的音檔和 div 標籤。 12345/*JS*/window.addEventListener(&quot;keydown&quot;,function()&#123; const audio = document.querySelector(`audio[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); const key = document.querySelector(`.key[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`);&#125;) 因為實際上會有作用的按鍵只有9個，按到沒作用的按鍵時，理論上我們應該要終止執行方法避免錯誤，所以新增 if 判斷是否成功取得音檔，沒有取得就終止方法的執行。 123456/*JS*/window.addEventListener(&quot;keydown&quot;,function()&#123; const audio = document.querySelector(`audio[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); const key = document.querySelector(`.key[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); if(!audio)return; /*如果keyCode不存在則中止執行方法*/&#125;) 接著是播放音檔的部分，如果只單用 audio.play()的話，則在連續按下同一按鍵時，會出現聲音不連貫的效果，此時需要將每次播放音檔的時間軸都設為0，讓每次播放都是從頭開始。 123456789/*JS*/window.addEventListener(&quot;keydown&quot;,function()&#123; const audio = document.querySelector(`audio[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); const key = document.querySelector(`.key[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); if(!audio)return; /*如果keyCode不存在則中止執行方法*/ audio.currentTime = 0; /*確保每一次按下鍵盤都從頭播放音檔*/ audio.play(); /*播放音檔*/&#125;) 最後處理 CSS 的動畫效果，我們會套用 .playing 的 CSS 設定到播放音檔的 div 標籤上。 123456/*CSS*/.playing &#123; transform: scale(1.1); /*讓 div 標籤變大1.1倍*/ border-color: #ffc600; /*改變 border 的顏色*/ box-shadow: 0 0 1rem #ffc600; /*產生陰影*/&#125; 1234567891011/*JS*/window.addEventListener(&quot;keydown&quot;,function()&#123; const audio = document.querySelector(`audio[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); const key = document.querySelector(`.key[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); if(!audio)return; /*如果keyCode不存在則中止執行方法*/ audio.currentTime = 0; /*確保每一次按下鍵盤都從頭播放音檔*/ audio.play(); /*播放音檔*/ key.classList.add(&#x27;playing&#x27;);&#125;) 一定時間後，我們必須拿掉 .playing 的 CSS 設定，讓 div 標籤回到未被按鍵觸發的狀態。因此我們可以在每個 key 上都註冊 “transitionend 事件” 的監聽器，並用 removeTransition() 處理該事件。 123456789/*JS*/function removeTransition(e)&#123; this.classList.remove(&#x27;playing&#x27;);&#125;/*取得所有的 key 標籤*/const keys = document.querySelectorAll(`.key`);/*在每個 key 上都註冊 &quot;transitionend 事件&quot; 的監聽器*/keys.forEach(key =&gt; key.addEventListener(&#x27;transitionend&#x27;,removeTransition)); 到這裡基本上就完成了，但是如果把 removeTransition() 的 “transitionend 事件” 印到 console，可以發現 “transitionend 事件” 不只有一個。 我們可以選擇以 transform 結束觸發的那個 “transitionend 事件”，作為移除 CSS 設定的時機點。 123456/*JS*//*當transform完成就移除.playing*/function removeTransition(e)&#123; if(e.propertyName != &#x27;transform&#x27;) return; this.classList.remove(&#x27;playing&#x27;);&#125; 整理後的完整JS如下: 1234567891011121314151617181920/*JS*/function playSound(e)&#123; const audio = document.querySelector(`audio[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); const key = document.querySelector(`.key[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); if(!audio)return; /*如果keyCode不存在則中止執行方法*/ audio.currentTime = 0; /*確保每一次按下鍵盤都從頭播放音檔*/ audio.play(); /*播放音檔*/ key.classList.add(&#x27;playing&#x27;); &#125; /*當transform完成就移除.playing*/function removeTransition(e)&#123; if(e.propertyName != &#x27;transform&#x27;) return; this.classList.remove(&#x27;playing&#x27;);&#125;const keys = document.querySelectorAll(`.key`);keys.forEach(key =&gt; key.addEventListener(&#x27;transitionend&#x27;,removeTransition));window.addEventListener(&quot;keydown&quot;,playSound) 補充說明:上面 `.key` 的用法是 JavaScript ES6 中新增的模版字符串（template literals)。 在過去我們需要用以下寫法在JS 的字串中放入 HTML 內容: 1234567/*JS*/let component_es5 = &#x27;&lt;header&gt;\\n&#x27;+&#x27;&lt;div class=&quot;banner&quot;&gt;\\n&#x27;+&#x27;&lt;img src=&quot;img1.jpg&quot;\\n&#x27;+&#x27;&lt;/div&gt;\\n&#x27;+&#x27;&lt;/header&gt;&#x27; 上面的寫法相當冗長，而且不具備閱讀性。在 ES6 中我們可以用反引號快速的解決這樣的狀況： 12345678/*JS*/let component_es6 = `&lt;header&gt; &lt;div class=&#x27;banner&#x27;&gt; &lt;img src=&quot;img1.jpg&gt; &lt;/div&gt;&lt;/header&gt;` – 資料來源: [筆記] JavaScript ES6 中的模版字符串（template literals）和標籤模版（tagged template） 實際效果請按此","categories":[],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-10-21T10:28:26.490Z","updated":"2021-10-21T10:28:26.490Z","comments":true,"path":"2021/10/21/hello-world/","link":"","permalink":"https://qi-xiang.github.io/2021/10/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]}