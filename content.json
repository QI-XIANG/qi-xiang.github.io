{"meta":{"title":"Xiang's Blog","subtitle":"記錄生活中發生的大小事","description":"在這裡我將與你共享我的知識庫!","author":"Qi Xiang,Zhang","url":"https://qi-xiang.github.io","root":"/"},"pages":[{"title":"","date":"2020-12-22T13:28:52.860Z","updated":"2020-12-22T13:28:52.860Z","comments":true,"path":"about/README.html","permalink":"https://qi-xiang.github.io/about/README.html","excerpt":"","text":"qi-xiang.github.io"},{"title":"","date":"2021-05-06T09:48:14.284Z","updated":"2021-05-06T09:48:14.284Z","comments":true,"path":"about/CSS_homepage/rwd.css","permalink":"https://qi-xiang.github.io/about/CSS_homepage/rwd.css","excerpt":"","text":"/*完美支援320、375、425、768、1440、1536、1920px*/ /**********************************Design for Phone*************************************/ @media screen and (min-width: 320px){ #inner-experience{ margin:0px 0px !important; } #mail_jumbo{ padding-top: 0px; } #mail pre{ margin-left: 0px !important; } #inner-education{ margin: 0px 0px !important; } } @media screen and (min-width: 375px){ #inner-experience{ margin:0px 0px !important; } #mail_jumbo{ padding-top: 0px; } #mail pre{ margin-left: 0px !important; } #inner-education{ margin: 0px 0px !important; } } @media screen and (min-width: 425px) { /*Done*/ #inner-experience{ margin:0px 0px !important; } #mail_jumbo{ padding-top: 0px; } #mail pre{ margin-left: 0px !important; } #inner-education{ margin: 0px 0px !important; } } /***************************************************************************************/ @media screen and (min-width: 768px) { /*Done*/ #inner-education{ margin:0px 24px !important; margin-left: 8%; } #inner-experience{ margin:0px 24px !important; } #mail pre{ margin: 0px !important; } #mail_jumbo{ padding-top: 0px !important; } #icon{ padding-bottom: 0px; } } @media screen and (min-width: 1440px) { /*Done*/ #inner-education{ padding:0px 141px !important; } #contact{ padding-left: 150px; } #inner-experience{ padding:0px 141px !important; } #mail{ padding-left: 165px; padding-top: 64px; } #icon{ padding: 0px 150px; } } @media screen and (min-width: 1536px) { /*Done*/ #inner-education{ padding:0px 0px 0px 189px !important; } #inner-experience{ padding: 0px 189px !important; margin-right:0px !important; } #contact{ padding-left: 198px; } #icon{ padding-left: 198px; } #mail{ padding-top: 64px; padding-left: 213px; } } @media screen and (min-width: 1920px) { /*Done*/ #inner-education{ padding:0px 0px 0px 381px !important; } #inner-experience{ padding-left: 381px !important; margin-right:0px !important; } #contact{ padding-left: 390px; } #icon{ padding-left: 390px; } #mail{ padding-top: 64px; padding-left: 405px; } }"},{"title":"","date":"2021-05-13T04:00:18.992Z","updated":"2021-05-13T04:00:18.992Z","comments":true,"path":"about/CSS_homepage/rwd2.css","permalink":"https://qi-xiang.github.io/about/CSS_homepage/rwd2.css","excerpt":"","text":"div .row{ background-color: #E9ECEF; } #foot{ background-color: #5569DC; } .marquee { width: 300px; /* the plugin works for responsive layouts so width is not necessary */ overflow: hidden; border:1px solid #ccc; }"},{"title":"","date":"2021-04-22T15:24:39.596Z","updated":"2021-04-22T15:24:39.596Z","comments":true,"path":"about/CSS_homepage/style.css","permalink":"https://qi-xiang.github.io/about/CSS_homepage/style.css","excerpt":"","text":"#myBtn { display: none; position: fixed; bottom: 10px; right: 10px; z-index: 99; font-size: 18px; border: none; outline: none; background-color: red; color: white; cursor: pointer; padding: 15px; border-radius: 4px; opacity: 0.5; } #myBtn:hover { background-color: #555; } a{ text-decoration: none; } /* Style all font awesome icons */ .fa { padding: 0px 25px 0px 0px; font-size: 20px; width: 20px; text-align: center; text-decoration: none; margin: 5px 2px; } /* Add a hover effect if you want */ .fa:hover { opacity: 0.7; } /* Set a specific color for each brand */ /* Facebook */ .fa-facebook { color: black; } /* LinkedIn */ .fa-linkedin { color: black; } /*Instagram*/ .fa-instagram { color: black; } /*Style for a:hover*/ .about a:hover{ color: aqua !important; } .education a:hover{ color: aqua !important; } .skills a:hover{ color: aqua !important; }.awards a:hover{ color: aqua !important; }"},{"title":"","date":"2021-05-13T04:02:27.460Z","updated":"2021-05-13T04:02:27.460Z","comments":true,"path":"about/JS_homepage/FadeIn_Animation.js","permalink":"https://qi-xiang.github.io/about/JS_homepage/FadeIn_Animation.js","excerpt":"","text":"$(document).ready(function(){ $(\"#fadeArea1 p\").hide() $(\"#fadeArea2 pre\").hide() $(\"#fadeArea2 p\").hide() $(\"#fadeArea3 pre\").hide() $(\"#fadeArea3 p\").hide() $(\"#fadeArea4 pre\").hide() $(\"#fadeArea4 p\").hide() $(\"#fadeArea5 pre\").hide() $(\"#fadeArea5 p\").hide() for(var i = 1;i=$('#about').offset().top){ $(\"#fadeArea1 p\").fadeIn(1000); } if($(window).scrollTop()+330>=$('#education').offset().top){ $(\"#fadeArea2 p\").fadeIn(1000); $(\"#fadeArea2 pre\").fadeIn(1000); } if($(window).scrollTop()+420>=$('#experience').offset().top){ $(\"#fadeArea3 p\").fadeIn(1000); $(\"#fadeArea3 pre\").fadeIn(1000); } if($(window).scrollTop()+440>=$('#skills').offset().top){ for(var i = 1;i=$('#awards').offset().top){ $(\"#fadeArea4 p\").fadeIn(1200); $(\"#fadeArea4 pre\").fadeIn(1200); } if($(window).scrollTop()+600>=$('#interests').offset().top){ $(\"#fadeArea5 p\").fadeIn(1300); $(\"#fadeArea5 pre\").fadeIn(1300); } }) $('.marquee').marquee({ //duration in milliseconds of the marquee duration: 8000, //gap in pixels between the tickers gap: 50, //time in milliseconds before the marquee will start animating delayBeforeStart: 0, //'left' or 'right' direction: 'left', //true or false - should the marquee be duplicated to show an effect of continues flow duplicated: true }); })"},{"title":"","date":"2021-04-22T14:37:21.604Z","updated":"2021-04-22T14:37:21.603Z","comments":true,"path":"about/animation/animation.css","permalink":"https://qi-xiang.github.io/about/animation/animation.css","excerpt":"","text":"@charset \"utf-8\"; h1{ text-align: center; color: darkorchid; padding-bottom: 15px; margin-top: 25px; margin-bottom: 25px; } body{ background-image: url(img/2.png); background-repeat: repeat-x; background-color: wheat; } a{ text-decoration: none; } a:hover{ color: red; } a:active{ color: blue; } .more{ text-align: right; padding: 20px 24px 20px 20px; background-image: url(img/icon.png); background-repeat: no-repeat; background-position: right center; clear: left; } h2{ border: black 1px solid; border-left: gray 15px solid; width: 180px; } table{ width: 50%; border: violet 1px solid; } th,td{ padding: 5px 10px; border: violet 1px solid; border-collapse: collapse; } #wrap{ width: 798px; margin: 40px auto; padding: 40px 80px; border: white 1px solid; background-color: white; } #a,#b,#c{ background-color: wheat; background-image: url(img/30.jpg); background-repeat: repeat-x; margin: 20px 0; padding: 35px 30px 30px 30px; } .ph{ float: left; margin-right: 30px; } .data{ width: 300px; float: left; } dt{ clear: left; float: left; font-weight: bold; } @keyframes marquee{ 0%{ left: 0%; } 100%{ left:-100%; } } div.marquee{ overflow: hidden; width: 420px; position: relative;margin: auto; height: 25px; } .marquee div{ display: block; overflow: hidden; width:200%; height: 25px; position: absolute; animation: marquee 10s linear infinite; } .marquee div span{ width: 50%; float: left; font-weight: bold; }"},{"title":"","date":"2021-04-22T14:40:14.530Z","updated":"2021-04-22T14:40:14.530Z","comments":true,"path":"about/animation/animation.html","permalink":"https://qi-xiang.github.io/about/animation/animation.html","excerpt":"","text":"animation 果然我的青春戀愛喜劇搞錯了! 果然我的青春戀愛喜劇搞錯了!完~2020年7月放送開始! 果然我的青春戀愛喜劇搞錯了!完~2020年7月放送開始! 來介紹一下我喜歡的作品! 作品概要 劇情大綱 登場人物 網站作者資訊 回饋表單 作品概要 《果然我的青春戀愛喜劇搞錯了。》（日語：やはり俺の青春ラブコメはまちがっている。 是日本輕小說作家渡航所創作的輕小說，插畫由ぽんかん⑧負責，簡體簡稱《春物》(我的青春戀愛物語果然有問題)，繁體簡稱《果青》(果然我的青春戀愛喜劇搞錯了)（日語：俺ガイル）。由GAGAGA文庫（小學館）於2011年3月至2019年11月間發行全14卷（本篇），日本地區累計發行量已突破900萬本。於2013年4月至6月播放第1季動畫，2015年4月至6月播放第2季動畫。原定於2020年4月9日首播第3期完結動畫，後因嚴重特殊傳染性肺炎疫情影響延期至同年7月。 劇情大綱 高中生比企谷八幡生性彆扭，不屈服於孤獨，沒有半個朋友，更不用提女朋友。對那些享受著青春的同班同學，他詛咒：「他們都是現充，通通給我爆炸吧！」——這樣一個傢伙，被導師帶去全校第一美少女雪之下雪乃加入的「侍奉社」。平凡無奇的八幡與美少女的奇妙邂逅，然而，雪乃和八幡個性上的缺陷讓他們無法擦出愛情的火花。這是一則充滿錯誤的青春故事。 登場人物(主要) 比企谷 八幡 年齡:17歲。 生日:8月8日，獅子座。 血型:A型。 喜歡的食物:蜂蜜炒花生及Max咖啡。 興趣:閱讀、玩遊戲、看動畫。 座右銘:「強求不來就放棄。」。 更多介紹 雪之下雪乃 年齡:17歲。 生日:1月3日，摩羯座。 血型:B型。 喜歡的食物:龍蝦和紅茶。 更多介紹 由比濱結衣 年齡:17歲。 生日:6月18日，雙子座。 血型:O型。 喜歡的食物:甜食。 更多介紹 網頁作者介紹 暱稱:翔翔 職業:中央大學資訊管理學系學生 E-mail:a0905716188@gmail.com WEB:建置中 敬請期待!! 回饋表單 回饋表單連結... Copyright &copy; GAGAGA文庫 All Rights Reserved. alert(\"該網站還處於測試階段!!\");"},{"title":"","date":"2021-04-22T14:37:30.908Z","updated":"2021-04-22T14:37:30.907Z","comments":true,"path":"about/animation/feedback.html","permalink":"https://qi-xiang.github.io/about/animation/feedback.html","excerpt":"","text":"feedback for animation 回饋表單 性別: 男生 女生 年齡: 請選擇 喜歡的角色: 最喜歡的女主角: 雪之下雪乃 由比濱結衣 川崎沙希 一色伊呂波 網站改善意見: 最後確認:"},{"title":"","date":"2021-10-21T16:12:18.300Z","updated":"2021-10-21T16:12:18.300Z","comments":true,"path":"about/index.html","permalink":"https://qi-xiang.github.io/about/index.html","excerpt":"","text":"My Homepage document.addEventListener('click', musicPlay); function musicPlay() { document.getElementById('music').play(); document.removeEventListener('click', musicPlay); } Top Welcome to my website! About Education & Experience Skills & Languages Awards & Interests QI-XIANG, ZHANG MIS in International Information & System Taoyuan, Taiwan qixiang1009@gmail.com https://github.com/QI-XIANG About MY BACKGROUND With a passion for computer science, web design, and all things programming, I have both the skill set and professional background necessary to dive deep into the programming world. As an upbeat, self-motivated team player with excellent communication, I envision an exciting future in the industry. Browse my site to see all that I have to offer. Education WHAT I’VE LEARNED 2019 - Present National Central University, TaiwanManagement in Information System 2016 - 2019 Taichung First Senior High School Experience WHERE I’VE WORKED Mar. 2021 - Present NCU Coding Club, Member Jan. 2020 - Present NCU Traditional Chinese Music Club, Erhu Group Leader Oct. 2019 - Dec. 2019 NCU MIS Carnival, Curation Group Member Sep. 2019 - Jan. 2020 NCU Traditional Chinese Music Club, Member Skills & Languages WHAT I BRING TO THE TABLE Java 20% Complete80% HTML & CSS 20% Complete70% JavaScript & JQuery 20% Complete50% Python 20% Complete45% Bootstrap 4 20% Complete40% Stock Analysis 20% Complete35% Git 20% Complete25% Chinese 20% Complete100% Taiwanese 20% Complete90% English 20% Complete80% Japanese 20% Complete35% Awards WHERE I SHINE Mayor Prize, Taichung City NCU College of Management,United Classes of Calculus 2019 Exam3 [21th place] JLPT N5 Certificate Interests OUT OF OFFICE Animation Reading Coding Web Design Stock Computer Science I'd love to hearfrom you qixiang1009@gmail.comhttps://github.com/QI-XIANG &copy; 2021 By Qi-Xiang Zhang.Proudly created with Bootstrap 4. //Get the button var mybutton = document.getElementById(\"myBtn\"); // When the user scrolls down 20px from the top of the document, show the button window.onscroll = function() {scrollFunction()}; function scrollFunction() { if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) { mybutton.style.display = \"block\"; } else { mybutton.style.display = \"none\"; } } // When the user clicks on the button, scroll to the top of the document function topFunction() { document.body.scrollTop = 0; document.documentElement.scrollTop = 0; } if (top.location !== self.location) { top.location.href = \"https://www.google.com\"; // 很不負責的轉給Google... XD } //audio play var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor); if (!isChrome){ $('#iframeAudio').remove() } else { $('#playAudio').remove() // just to make sure that it will not have 2x audio in the background }"}],"posts":[{"title":"輕鬆玩轉 Hexo","slug":"Hexo","date":"2022-03-13T17:11:55.000Z","updated":"2022-03-13T17:18:35.953Z","comments":true,"path":"2022/03/14/Hexo/","link":"","permalink":"https://qi-xiang.github.io/2022/03/14/Hexo/","excerpt":"","text":"作業系統: Windows10、編輯器: Visual Studio Code 建立環境 1.安裝 Node.js 要安裝Node.js是因為Hexo是基於Node.js開發的 (建議下載LTS版本較為穩定) 2.安裝 Git 後續的自動化部署會用到 3.確認成功安裝 在cmd裡依序輸入以下指令: 123node -vnpm -vgit --version (ps. 安裝node.js的同時，也會安裝npm) 都能正確顯示版本的話即代表安裝成功~ 4.安裝Hexo 1npm install -g hexo-cli 5.確認成功安裝Hexo 1hexo -v 到這邊環境安裝就結束了~ 建立 Hexo 專案 在想建立 Hexo專案的路徑下輸入以下指令即可建立Hexo專案 1hexo init [資料夾名稱] 建立文章 所有文章都是以Markdown撰寫~ 請在專案路徑下開啟cmd並輸入: 1hexo new &#x27;文章名稱&#x27; 建立的文章被放在source\\_posts資料夾裡面 預設內容如下: 產生靜態檔案 記得切到專案路徑底下再輸入! 1hexo generate 靜態檔案會被放在public資料夾中，放在裡面的東西就是我們實際上的部落格內容 開啟測試伺服器 輸入以下指令可開啟測試伺服器並檢視部落格: 1hexo server 清除暫存檔案 輸入以下指令，可以解決一些奇怪的問題: 1hexo clean 主要是用來清除快取檔案 (db.json) 以及編譯檔案 (public): 部署靜態檔案 輸入以下指令，可以將部落格自動部屬或更新到特定的遠端數據庫: 1hexo deploy 在輸入指令前，要先做一些設定，以部署到github為例: 1.建立數據庫 2.安裝部署套件 輸入以下指令: 1npm install --save hexo-deployer-git 3.修改hexo/_config.yml 把url改成自己建立的git page網址: deploy區塊修改方式如下: 4.部屬到github 12hexo generatehexo deploy ps.可能會需要驗證帳號，有多個帳號記得切，參考此篇 重新整理後，可以在數據庫看到部署的東西 5.設定 git page 6.檢視部落格 從git page的網址進入部落格: 更新部落格 要更新部落格的文章可以直接修改對應的.md檔案，或新增新文章後編輯 編輯完後依序輸入以下指令即可: 12hexo generatehexo deploy 以上就是簡明版的Hexo教學，有空會再補充一些細節~","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://qi-xiang.github.io/tags/Hexo/"}]},{"title":"IP位址計算 (IPv4 適用)","slug":"IP位址計算-IPv4-適用","date":"2022-03-05T18:00:00.000Z","updated":"2022-03-09T09:38:16.582Z","comments":true,"path":"2022/03/06/IP位址計算-IPv4-適用/","link":"","permalink":"https://qi-xiang.github.io/2022/03/06/IP%E4%BD%8D%E5%9D%80%E8%A8%88%E7%AE%97-IPv4-%E9%81%A9%E7%94%A8/","excerpt":"","text":"大二修企業資料通訊(BDC)時，對於IP位址的計算一竅不通，上網看教學影片、文章仍然無法學會，後來到圖書館借書時，偶然翻到網路概論的書，才讓我學會如何計算XD。 IP 位址是用來幹嘛的? 在網路上的所有裝置都要有一個獨一無二的IP位址，作為傳送和接收資料的地址。在現實生活中，IP位址的功用就像是郵件上都會有的收件人地址和寄件人地址，收件人地址讓信件可以被正確送達，寄件人地址則讓收到信的人可以回信。 (圖片來源: https://www.homenethowto.com/basics/ip-addresses/) IP 位址的表示方式 IP 位址是由 32 bits的二進位數字表示，也就是由32個0或1組成 : 101111111000000000000000000000001 上面那一串數字真的讓人霧煞煞，所以我們可以透過下列方式做轉換 : 將 32 bits 的 IP 位址每 8 bits 切成一段 101111111 00000000 00000000 00000001 將每一段的二進位數字轉回十進位，再以.隔開每一段 : 1127.0.0.1 這樣就能比較容易看懂。 IP 位址的結構 IP 位址可以劃分為兩個部分 : 網路位址、主機位址 網路位址 識別所屬的網路 主機位址 識別所屬網路的裝置 舉例來說，某天拿到192.168.117.x的網段，前面的192.168.117就是用來辨別所屬網路的網路位址(24 bits)，後面的x則對應到可以分配的主機位址，x的長度總共有8 bits，所以可能的排列組合有256種(2的8次方)，換句話說總共有256個主機位址可以分配給256個裝置使用。 將這個概念做延伸，不難發現前面的網路位址越短，可以分配的主機位址就會越多，為了滿足不同規模的網路需求，又依據網路位址的長度區分出不同的 IP 位址等級。 (實際上的長度劃分不一定是這樣，這邊僅是舉例) IP 位址的等級 當初設計 IP 時，將 IP 位址分成五個等級(Class A、B、C、D、E) 一般常用的是 Class A、B、C 這三種等級的 IP 位址，分別適用在大、中、小型網路，負責管理IP位址的機構，可以依照申請者所需要的網路規模，賦予不同等級的IP位址。 Class A 網路位址為 8 bits，第1個 bit(前導位元)必須是0。 網路位址從00000000~01111111，總共有128(2的7次方)個可以運用的網路位址(2的7次方)。主機位址為 24 bits，可以運用的位址總數為16777216個(2的24次方)。目前大部分的 Class A 都已經分配給過去有參與 ARPAnet(Internet的前身) 實驗的政府機關、學術單位等等，所以現在無法取得 Class A 的IP位址。 Class B 網路位址為 16 bits，前2個 bits(前導位元)必須是 10。Class B的 IP 位址必定介於128.0.0.0~191.255.255.255。主機位址為 16 bits，可以運用的位址總數為65536個(2的16次方)。大部分的 Class B 都被分配給大企業或ISP使用。 Class C 網路位址為 24 bits，前3個 bits(前導位元)必須是 110。Class C 的 IP 位址必定介於192.0.0.0~223.255.255.255。主機位址為 8 bits，可以運用的位址總數為256個(2的8次方)。Class C 通常都被分配給小企業使用。 特殊的IP位址 主機位址全為0 用來代表這個網路，以 Class C為例，196.67.208.0用來代表該 ClassC 網路。 主機位址全為1 代表網路中的所有位址，主要是用在廣播上面。假設有電腦送出目的地為196.67.208.255的封包，則代表對196.67.208.0這個網路的所有裝置進行廣播(所有裝置都會收到封包)。 段落重點整理 從 IP 位址的第一段我們就能看出它所屬的 IP 位址等級。例如: 168.0.0.1可以從 168 判斷它是一個 Class B 的 IP 位址，IP 位址的前 16 bits 為網路位址，後 16 bits 為主機位址。 Class A : 0.0.0.0~127.255.255.255 Class B : 128.0.0.0~191.255.255.255 Class C : 192.0.0.0~223.255.255.255 子網路 IP 位址等級的切割固然方便，但彈性卻略顯不足。假設有人拿到 Class B 的 IP 位址，實際上只連接數十台電腦，那這樣不是會有很多位址被浪費掉嗎? 要解決這個問題可以透過將網路切割成更小的子網路來避免 IP 位址浪費的同時，增加原本3種 IP 位址等級的彈性。而在切割子網路前，務必要先思考需要多少個子網路，以及每個子網路需要連結多少台主機。 切割子網路的原理 簡單來說切割子網路就是向 IP位址 中的主機位址借前幾個位元作為子網路位址。 假設拿到的 Class B IP 位址是這樣 : 借主機位址的前 3 bits 作為子網路位址: 子網路位址與原有的網路位址合計共佔 19 bits，可以被視為是一個新的網路位址，用來識別該子網路。原先 16 bits 的網路位址是不可更動的，但子網路位址是可以自由分配的，在範例中從主機位址借用 3 bits，產生了8(2的3次方)個子網路。 範例中，原先 Class B 總共有 65536(2的16次方) 個可分配的主機位址，經過切割後每個子網路(共8個)則有 8192(2的13次方) 個可分配的主機位址，理論上從主機位址借到 15 bits 可以形成 32768 (2的15次方) 個子網路，而每個子網路有2個可分配的主機位址，但不幸的是主機位址不能全為0或1，所以上述的主機位址通通都要扣2，也就是說最多只能從主機位址身上借到前 14 bits。 子網路遮罩 在切割完子網路後，可以發現不論原先是哪一等級的 IP 位址，網路位址都不會再是原來的長度(8、16、24 bits)，那要怎麼確認切割後，現在網路位址的長度呢? 答案是我們可以用子網路遮罩來確認借用幾 bit 的主機位址。 子網路遮罩的結構 長度為 32 bits 與 IP 位址對應 必須由連續一串的1再和連續一串的0組合而成 可以用十進位表示(和 IP 位址相同) 轉成十進位表示 : 111111111 11111111 11111111 00000000 =&gt; 255.255.255.0 子網路遮罩一定要與 IP 位址搭配使用，單獨存在沒有意義。把 IP 位址和子網路遮罩擺在一起看時，子網路遮罩 1 的長度範圍對應到的是這組 IP 位址的網路位址，0 的長度範圍則對應到這組 IP 位址的主機位址。 以下用圖來說明會比較清楚 : 子網路遮罩由21個連續的1和11個連續的0組成，對應到 IP 位址(Class B)代表最前面的 21 bits 是網路位址，剩下的 11 bits 則是主機位址。 另外，也可以將範例的168.95.192.1套用子網路遮罩後簡寫成168.95.192.1/21，/21代表網路位址有 21 bits，同時也是子網路遮罩有21個連續的1的意思。 不進行子網路切割則各等級 IP 位址的子網路遮罩如下 : 以上就大致交代完 IP 位址的基礎了，當然還有蠻多東西沒有講，不過就讓我用一些應用題目結束這回合吧! 應用問題 以下都是蒐集來的題目 : 某主機的 IP 位址為 192.168.1.134，子網路遮罩為 255.255.255.248，則該主機的&quot;網路位址&quot;為何? 從第一段的數字192可以看出是 Class C 的 IP 位址，然後將 IP 位址中的最後一個數字134轉成二進制並和子網路遮罩比對 : 可以發現這組 IP 位址落在 10000 這個子網路裡面，轉成十進位後，此子網路的網路位址為 192.168.1.128。 在 Class C 等級網路中若要分出至少13個子網路，則子網路遮罩為何? 向主機位址借 4 bits 就可以切出 16(2的四次方) 個子網路，故子網路遮罩為 11111111 11111111 11111111 11110000 (255.255.255.240)。 255.255.252.0 這個子網路遮罩最多可以將 132.114.0.0 這個網路分成幾個有效的子網路? 每個子網路最多可以有幾台主機? 由 IP 位址第一個數字132，可以確認它是 Class B 的 IP 位址，經比對之後發現向主機位址借用 6 bits 作為子網路位址，所以最多可分出 64 (2的6次方) 個子網路，每個子網路可以容納 1024-2 = 1022 (2的10次方減去主機位址全為0或1) 台主機。 之後有空應該會再寫其他填坑的文章~~~","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"填坑系列","slug":"填坑系列","permalink":"https://qi-xiang.github.io/tags/%E5%A1%AB%E5%9D%91%E7%B3%BB%E5%88%97/"}]},{"title":"建置簡單 Line 聊天機器人","slug":"聊天機器人","date":"2022-02-24T16:25:00.000Z","updated":"2022-03-09T09:40:48.662Z","comments":true,"path":"2022/02/25/聊天機器人/","link":"","permalink":"https://qi-xiang.github.io/2022/02/25/%E8%81%8A%E5%A4%A9%E6%A9%9F%E5%99%A8%E4%BA%BA/","excerpt":"","text":"Hint: 筆記內容主要來自: iT邦幫忙 - LINE BOT 新手村30日攻略系列 的部分重點節錄。 Our Goal &amp; Ability You Need 1. 目的: 實做出一個可以回應使用者的天氣預報 line 機器人 💪 2. 需要具備的能力: Line 帳號 Python 環境 Python 基礎語法 分析JSON資料 學習熱誠 接下來進入實作環節 ! Setting Environment LINE Messenging API LINE BOT設定 Hint: 將我們希望回覆的訊息格式和內容以特定的JSON格式回覆給Messenging API，指定的 JSON格式檔案就可以在我們的 BOT Server 及 LINE Platform 之間以HTTPS的方式，傳遞這則訊息給用戶。 Step1. LINE BOT設定 新增LINE BOT 前往 https://developers.line.biz/ 並 登入/創建LINE帳號 新增Providers 登入 LINE 帳號後看到介面如下 👇 接下來點擊 Create 輸入Providers name，可以隨意填寫，只要下面都是綠色勾勾就可以~ 新增 Messenger API channel 點選 Create a Messenging API channel 接下來修改以下內容: Channel name Channel description Category Subcategory Email address 其餘選填 填完後下方選項打勾並點選 Create 產生Access token 到 Messaging API 在最下面找到 Channel access token 並點擊 issue 務必將此token記下來!之後會用到喔! Channel Secret 請到 Basic settings 往下找到Channel secret 務必將此secret記下來!之後會用到喔! 啟用webhook 前往 LINE manager 選擇剛剛新增的BOT 按右上角設定 選擇左側的回應設定 ， 將進階設定中的 Webhook勾選啟用、自動回覆訊息改為停用 到這邊關於LINE BOT的設定就告一段落 😄 Step2. 下載Python套件 LINE官方關於python部分有提供 line-bot-sdk 此外，我們也會用到 flask 套件 win+R 開啟cmd 輸入以下指令 1pip3 install line-bot-sdk flask Python的部分完成囉! Step3. 開發用資料夾 上面的套件都下載&amp;安裝完後就新增一個資料夾吧~ 之後所有的資料都會放在這個資料夾裡面 Step4. 下載ngrok 做本機測試會用到ngrok，這邊就先下載 建議放在剛剛新增的資料夾裡面，之後會比較方便使用 前往 https://ngrok.com/download 下載windows版ngrok 如果你是使用WSL或是Linux系統可以下載Linux版ngrok 前置作業終於完成 ! 👍 實作 - 鸚鵡式機器人 Hint: 所謂鸚鵡式機器人就是 你說甚麼，它就說甚麼 Coding 使用webhook建立連線 接收使用者訊息 回覆使用者訊息 Coding 先到建立的開發用資料夾中開啟新檔案，建議使用VScode開啟。 名稱就叫main.py 將模板放入main.py中 12345678910111213141516171819202122232425262728293031323334353637383940from flask import Flask, request, abortfrom linebot import ( LineBotApi, WebhookHandler)from linebot.exceptions import ( InvalidSignatureError)from linebot.models import *app = Flask(__name__)# LINE BOT infoline_bot_api = LineBotApi(&#x27;Channel Access token&#x27;)handler = WebhookHandler(&#x27;Channel Secret&#x27;)@app.route(&quot;/callback&quot;, methods=[&#x27;POST&#x27;])def callback(): signature = request.headers[&#x27;X-Line-Signature&#x27;] body = request.get_data(as_text=True) app.logger.info(&quot;Request body: &quot; + body) print(body) try: handler.handle(body, signature) except InvalidSignatureError: abort(400) return &#x27;OK&#x27;# Message event@handler.add(MessageEvent)def handle_message(event): message_type = event.message.type user_id = event.source.user_id reply_token = event.reply_token message = event.message.text line_bot_api.reply_message(reply_token, TextSendMessage(text = message))import osif __name__ == &quot;__main__&quot;: port = int(os.environ.get(&#x27;PORT&#x27;, 8888)) app.run(host=&#x27;0.0.0.0&#x27;, port=port) Channel Access token 以及 Channel Secret 改成上面提到要記的兩個值放入 1234app = Flask(__name__)# LINE BOT infoline_bot_api = LineBotApi(&#x27;Channel Access token&#x27;)handler = WebhookHandler(&#x27;Channel Secret&#x27;) 指定在 /callback 通道上接收訊息，且方法是 POST 而 callback() 是為了要檢查連線是否正常 其中 signature 是LINE官方提供用來檢查該訊息是否透過LINE官方APP傳送 而 body 就是用戶傳送的訊息，並且是以 JSON 的格式傳送 1234567891011@app.route(&quot;/callback&quot;, methods=[&#x27;POST&#x27;])def callback(): signature = request.headers[&#x27;X-Line-Signature&#x27;] body = request.get_data(as_text=True) app.logger.info(&quot;Request body: &quot; + body) print(body) try: handler.handle(body, signature) except InvalidSignatureError: abort(400) return &#x27;OK&#x27; 這邊是用來接收訊息的地方 特別注意到 line_bot_api.reply_message() 它是回傳訊息的方法，而我們設定回傳的型態是文字(text) 12345678# Message event@handler.add(MessageEvent)def handle_message(event): message_type = event.message.type user_id = event.source.user_id reply_token = event.reply_token message = event.message.text line_bot_api.reply_message(reply_token, TextSendMessage(text = message)) 接收到的訊息會被放在event中，一樣會是JSON格式 events.message.type 這裡記錄訊息的型態 events.message.text 如果是文字訊息(text) 這裡會記錄傳送的文字 events.sourse.userId 這裡記錄使用者的ID 指定BOT執行的位置是在 0.0.0.0:8888 接上前面所說的，BOT會接收訊息的位置會是0.0.0.0:8888/callback 1234import osif __name__ == &quot;__main__&quot;: port = int(os.environ.get(&#x27;PORT&#x27;, 8888)) app.run(host=&#x27;0.0.0.0&#x27;, port=port) Webhook Hint: 當LINE Platfrom接收到來自使用者的訊息後，透過API接口，webhook通道使得LINE Platform從被動方變成主動方，將訊息傳送到BOT Server 實作開始 實際上，這份code已經完成了鸚鵡的功能了，那接下來就讓它動起來吧 ! 執行ngrok.exe 在命令提示視窗執行以下指令 1ngrok.exe http 8888 執行cmd，移動路徑到專案的資料夾中 在cmd執行以下指令 1python main.py 目前為止，你的畫面應該會是這樣 你會發現有一個會將訊息導向 localhost:80 上的webhook 現在只需要讓LINE 知道webhook在哪裡就完成了! 前往 https://manager.line.biz/ 登入自己的LINE帳號，並進入自己的LINE BOT 點擊右上角的設定 &gt; Messaging API 將Webhook網址改成剛剛ngrok上看到的網址加上/callback並儲存 圖片中忘記加上callback，請記得補上 這樣一來，通道就建構成功啦! 先將LINE BOT加入好友後來試試看功能吧! LINE ID可以在剛剛的網頁上方找到 接下來就可以跟自己的BOT聊天","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"LineBot超入門","slug":"LineBot超入門","permalink":"https://qi-xiang.github.io/tags/LineBot%E8%B6%85%E5%85%A5%E9%96%80/"}]},{"title":"遲來的鐵人賽心得","slug":"遲來的鐵人賽心得","date":"2022-02-15T12:05:00.000Z","updated":"2022-03-13T17:25:46.845Z","comments":true,"path":"2022/02/15/遲來的鐵人賽心得/","link":"","permalink":"https://qi-xiang.github.io/2022/02/15/%E9%81%B2%E4%BE%86%E7%9A%84%E9%90%B5%E4%BA%BA%E8%B3%BD%E5%BF%83%E5%BE%97/","excerpt":"","text":"某人可能會遲到，但從不缺席 (沒x 失蹤很久了好嗎== 故事原點 在正式參加鐵人賽之前，我從不知道有這個活動，或者也可以說沒有真正的逛過iT邦幫忙這個網站。第一次真正意義上讓我看到鐵人賽，是因為在學校上UNIX作業系統時遇到瓶頸，然後著急地到網路上尋找其他人學習恐龍書之後所寫的心得，緣分使然讓我在無意間看到&quot;小黑馬作業系統教室統整&quot;的鐵人賽系列文(已被下架QQ)，令我在重新拾回學習信心同時，也在心中浮現下次的鐵人賽參賽計畫(2021第13屆)。 恐龍書 (圖源: 三民網路書店) 由於是初次參加鐵人賽，我選擇報名的是&quot;自我挑戰組&quot;。(或許是因為覺得相對自由的關係?) 在想這30天要寫些什麼的時候，我最原始的想法是想寫我開始接觸網頁的心得，像是網頁三本柱以及前期踩的坑之類的，但後來看到有人分享 JS30 的課程心得，又因為它剛好就是30天的課程，當下我就確定要寫&quot;JS30學習日記&quot;系列文。 故事伊始 在鐵人賽正式開賽(2021-09-01)之前，我有思考過該不該寫稿起來放(後來在鐵人賽開賽後沒幾天，我就看到有人在文章中說他已經寫完30天的文章。自爆XD)，考慮到時間安排彈性的問題，我在開賽前屯了10篇左右的稿子。 當然不是說我每天晚上12:00剛過，就上來丟篇文章打卡這麼簡單，如果各位大大、前輩們有稍微看過我寫的系列文，就會發現我JS真的很菜，非常依賴在網路上查各種算是&quot;常識&quot;的資料(我自己認為是這樣)，查資料的時間甚至比我看課程影片+寫學習心得的時間還要長哈哈。 故事途中 前期每天就在準時上來發心得文(確認發表前我都會再確認一次內容，盡量讓文章不要出現錯字)、寫之後的文章內容、觀看教學影片以及查大量的資料中平靜地度過。 而故事的轉折點，發生在開學之後課業(大學生ing~)與鐵人賽的事情剛好重疊在一起，我開始只能用相對零碎的時間來寫鐵人賽的系列文。 故事轉折 對我這個大學生而言，開學第一週都在思考整學期的課程安排，要怎麼選到可以帶走東西的課是每學期都有的挑戰，我會非常仔細地看課程大綱還有之前的課程評價等等來參考，當然有些萬惡的必修課仍無法避免XD。 想當然耳，跟前面說的一樣只能用零碎的時間繼續維持每天發文，過程中也曾經想要放棄，但畢竟就剩幾天就可以完賽，心裡浮現的那份不甘願促使我要繼續往前進。 我也稍微能夠體會為什麼有些優質系列文會無法挑戰成功，因為真的會有很多突發狀況讓人沒有時間寫完，一篇優質的文章或許只要短短不到10分鐘就能快速閱讀完畢，但作者卻要花數倍時間來寫和整理相關資料。 故事尾聲 在Stack Overflow、前人的JS30課程筆記、MDN Web Docs的大力支援下，&quot;JS30學習日記&quot;系列文就這樣順利地完成了。儘管因為開學，比較後面的文章有寫得比較隨便，但完賽的那個瞬間，真的帶給我滿滿的感動與成就感。除此之外，瀏覽次數、Like數、訂閱數的跳動，都讓我有被人認同的感覺。 最後真的非常感謝網路上的各位前輩們~ (更新於2022/02/28)","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"生活經驗分享","slug":"生活經驗分享","permalink":"https://qi-xiang.github.io/tags/%E7%94%9F%E6%B4%BB%E7%B6%93%E9%A9%97%E5%88%86%E4%BA%AB/"}]},{"title":"奇蹟似的通過日檢N4","slug":"奇蹟似的通過日檢N4","date":"2022-01-26T17:40:00.000Z","updated":"2022-03-13T17:26:46.626Z","comments":true,"path":"2022/01/27/奇蹟似的通過日檢N4/","link":"","permalink":"https://qi-xiang.github.io/2022/01/27/%E5%A5%87%E8%B9%9F%E4%BC%BC%E7%9A%84%E9%80%9A%E9%81%8E%E6%97%A5%E6%AA%A2N4/","excerpt":"","text":"在分享心得前，先附上我日檢N4的成績： 檢定通過標準： 對，你沒看錯我只比合格線高4分哈哈。在這邊我先自首，我真的沒有花很多時間在準備日檢，因為同一時間有系統設計的期末報告還有IoT的小專題，只用零碎的時間讀再配合修學校開的日文選修課，能過真的是奇蹟! (ps.學校的日文選修課只有摸到N4的一些範圍) 我自己本身並不是日文科系的學生，會開始學日文完全是因為喜歡看動畫(能不看字幕把焦點放在動畫本身是我一直以來追求的目標) 後來在大一的寒假，我買了第一本日文參考書開始自主學習，搭配著名的50音之歌，我很快就背完50音。 起初完全都是靠自己用力K書，把文法、單字通通背起來，但卻逐漸陷入瓶頸，所以我後來加購同一本參考書出的教學光碟，進入獲得系統性教學的階段。 而在大一下終於讓我選上學校超難選的日文課，我發現我寒假學的東西超出課堂蠻多的，雖然過得很輕鬆，但跟不同日文老師學習，可以聽到更多不同的說法，只能說賺爛了賺爛了~ (ps.3學分輕鬆入袋順便衝一波GPA) 接下來用 Q&amp;A 進行說明： Q1. 有特別練聽力? N5、N4的聽力說真的不難，只要平常有在看日本節目或動畫之類的，基本上可以輕鬆應付過去，就不要再浪費錢買聽力參考書啦~(ps.其實聽文法書的光碟也行) Q2. 使用的參考書? 文法: 大家學標準日本語初級、中級本 (自學用) 大家的日本語 初級Ⅰ、Ⅱ (修日文課用) 單字: 新日檢N5單字帶著背！ 新日檢N4單字帶著背！ Q3. 直接衝N4比較好? 如果是想省錢的話，當然不建議考N5，但如果只是出於興趣學習日文，那N5檢定應該能為你帶來莫大的信心。 Q4. N4的難點在哪? 聽力真的沒什麼，主要難在動詞變化，包括た型、て型、ない型還有其它各種型的變化還有相關的句型應用。另外，單字要認真背一下，日檢很喜歡把看起來很像的字都放在選項裡，像是有無長音う或促音っ。 Q5. 通過N4要準備多久? 假設你前面基本功很足，達到可以輕鬆通過N5的水準，那大概就只要再花點時間學點動詞變化的皮毛和些許單字就可以低空飛過，我是在準備的同時，手邊還有太多事，前後大概也就考試前1-2個月前開始準備吧！ 剩下有問題都可以在下面問，我會盡量回~ 祝大家都能順利考過日文檢定!","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"生活經驗分享","slug":"生活經驗分享","permalink":"https://qi-xiang.github.io/tags/%E7%94%9F%E6%B4%BB%E7%B6%93%E9%A9%97%E5%88%86%E4%BA%AB/"}]},{"title":"關於我開始寫電子筆記這檔事","slug":"關於我開始寫電子筆記這檔事","date":"2022-01-26T09:20:00.000Z","updated":"2022-03-13T17:25:43.768Z","comments":true,"path":"2022/01/26/關於我開始寫電子筆記這檔事/","link":"","permalink":"https://qi-xiang.github.io/2022/01/26/%E9%97%9C%E6%96%BC%E6%88%91%E9%96%8B%E5%A7%8B%E5%AF%AB%E9%9B%BB%E5%AD%90%E7%AD%86%E8%A8%98%E9%80%99%E6%AA%94%E4%BA%8B/","excerpt":"","text":"首先，我必須先說本篇真的不是在幫HackMD打廣告，純粹是想稍微分享我開始寫電子筆記這件事。 其實從小到大我都有做筆記的習慣，但傳統紙本筆記最大的缺點在於保存不易，以前寫的厚厚一本筆記在成長的過程中直接失蹤。 從小學到高中的求學過程中，有很大一部份的時間都在補習班度過，也就沒有機會接觸到可以快速寫出精美筆記的軟體或網站。 直到大學，作筆記變成是每個人都要會的基本功(至少在我的班上是這樣~)，又因為我是資訊科系的學生，很容易就整天都泡在網路世界(ex. youtube)。 在此不得不說YT的演算法真的挺神的，讓我在偶然間看到Papaya電腦教室介紹Obsidian這款筆記軟體的影片，直接shock到我，開始使用它來寫電子筆記。 (ps.終於有手機APP可以用啦~ 但用手機寫markdown語法真的挺哭的QQ) 就這樣我愛上寫電子筆記，那HackMD又是如何走進我的視野呢? 前面有說過我是資訊科系的學生，所以理所當然的有Github帳號，到處亂逛別人repository的過程中，我發現有些大佬的技術文件是用HackMD寫的，出於好奇我試著用它陸續寫了幾篇筆記，沒想到一試成主顧用它到現在。 從2021.5.27開始使用到現在，在HackMD上我已經有100多篇筆記和3本電子書，寫電子筆記真的有種令人沉迷其中的力量。 對我來說，寫筆記是為了形塑出在未來的某一天能夠快速找回事物印象的知識庫~","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[]},{"title":"CSS Flex Box Chapter2.","slug":"Chapter2","date":"2022-01-22T19:15:00.000Z","updated":"2022-03-13T17:25:20.003Z","comments":true,"path":"2022/01/23/Chapter2/","link":"","permalink":"https://qi-xiang.github.io/2022/01/23/Chapter2/","excerpt":"","text":"material from: freeCodeCamp、CSS Tools: Reset CSS Use the flex-direction Property to Make a Row 透過新增display:flex;這個屬性設定到元素上，該元素就會變成一個有彈性的容器(flex container)。 接下來可以進一步設定flex-direction，調整容器內部子元素的擺放方式，是要以列(row)或欄(column)作排列， 設定flex-direction:row;則子元素會以水平方向作排列；設定flex-direction:column;則子元素會以 鉛直方向作排列。 順帶一提，若想要倒序排列子元素，則可分別設定flex-direction:row-reverse;或flex-direction:column-reverse;。 在不做任何設定的情況下，預設flex-direction:row;。 Initial 12345678910111213141516171819202122&lt;style&gt; #box-container &#123; display: flex; height: 500px; &#125; #box-1 &#123; background-color: dodgerblue; width: 50%; height: 50%; &#125; #box-2 &#123; background-color: orangered; width: 50%; height: 50%; &#125;&lt;/style&gt;&lt;div id=&quot;box-container&quot;&gt; &lt;div id=&quot;box-1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;box-2&quot;&gt;&lt;/div&gt;&lt;/div&gt; flex-direction:row; 1234567&lt;style&gt; #box-container &#123; display: flex; height: 500px; flex-direction: row; &#125; ... flex-direction:column; 1234567&lt;style&gt; #box-container &#123; display: flex; height: 500px; flex-direction: column; &#125; ... flex-direction:row-reverse; 1234567&lt;style&gt; #box-container &#123; display: flex; height: 500px; flex-direction: row-reverse; &#125; ... flex-direction:column-reverse; 1234567&lt;style&gt; #box-container &#123; display: flex; height: 500px; flex-direction: column-reverse; &#125; ...","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"網頁基礎","slug":"網頁基礎","permalink":"https://qi-xiang.github.io/tags/%E7%B6%B2%E9%A0%81%E5%9F%BA%E7%A4%8E/"}]},{"title":"CSS Flex Box Chapter1.","slug":"Chapter1","date":"2022-01-22T18:45:03.000Z","updated":"2022-03-13T17:25:22.781Z","comments":true,"path":"2022/01/23/Chapter1/","link":"","permalink":"https://qi-xiang.github.io/2022/01/23/Chapter1/","excerpt":"","text":"material from: freeCodeCamp、CSS Tools: Reset CSS Use display: flex to Position Two Boxes 這邊算是 flex box 的初入門，display:flex 宣告父容器要用 flex box 的形式放置網頁元素。 因為下面設定2個box各佔50%寬度的關係而且沒有多寫flex: wrap;，所以在縮放視窗時，沒辦法感受到 flex box 的威力，原則上所有子元素都會被排在同一列上。 12345678910111213141516171819202122&lt;style&gt; #box-container &#123; #父容器 height: 500px; display: flex; &#125; #box-1 &#123; #子元素 background-color: dodgerblue; width: 50%; #均分寬度 height: 50%; &#125; #box-2 &#123; background-color: orangered; width: 50%; height: 50%; &#125;&lt;/style&gt;&lt;div id=&quot;box-container&quot;&gt; &lt;div id=&quot;box-1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;box-2&quot;&gt;&lt;/div&gt;&lt;/div&gt; 有display: flex; 沒有display: flex; Practice: Simple Image Gallery 上面的東西只要再多個flex: wrap;就可以做個簡易的 Image Gallery，flex: wrap;在後面會提到，現在只要知道它可以讓原本&quot;被迫&quot;排在一起的元素，按實際指定的 width 依序排在不同列上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;body&gt; &lt;div class=&quot;box-container&quot;&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box5&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box6&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;style&gt; .box-container&#123; height: 100%; display: flex; flex-wrap: wrap; &#125; .box1&#123; width: 50%; height: 250px; background-color: rgb(140, 231, 231); &#125; .box2&#123; width: 50%; height: 250px; background-color: rgb(120, 243, 202); &#125; .box3&#123; width: 33.3333%; height: 250px; background-color: rgb(65, 136, 136); &#125; .box4&#123; width: 33.3333%; height: 250px; background-color: rgb(105, 126, 126); &#125; .box5&#123; width: 33.3333%; height: 250px; background-color: rgb(57, 83, 83); &#125; .box6&#123; width: 100%; height: 250px; background-color: rgb(9, 160, 160); &#125;&lt;/style&gt; 加上圖片再調整個別高度就完成啦~ ps. 現在的長寬比是照我的螢幕尺寸做規劃，其他尺寸的螢幕有可能會跑版。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;body&gt; &lt;div class=&quot;box-container&quot;&gt; &lt;div class=&quot;box1&quot;&gt;&lt;img src=&quot;image/thumb1.jpg&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;img src=&quot;image/thumb2.jpg&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;img src=&quot;image/thumb3.jpg&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt;&lt;img src=&quot;image/thumb4.jpg&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box5&quot;&gt;&lt;img src=&quot;image/thumb5.jpg&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box6&quot;&gt;&lt;img src=&quot;image/thumb6.jpg&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;style&gt; .box-container&#123; height: 100%; display: flex; flex-wrap: wrap; &#125; .box1&#123; width: 50%; height: 350px; background-color: rgb(140, 231, 231); &#125; .box2&#123; width: 50%; height: 350px; background-color: rgb(120, 243, 202); &#125; .box3&#123; width: 33.3333%; height: 250px; background-color: rgb(65, 136, 136); &#125; .box4&#123; width: 33.3333%; height: 250px; background-color: rgb(105, 126, 126); &#125; .box5&#123; width: 33.3333%; height: 250px; background-color: rgb(57, 83, 83); &#125; .box6&#123; width: 100%; height: 650px; background-color: rgb(9, 160, 160); &#125;&lt;/style&gt;","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"網頁基礎","slug":"網頁基礎","permalink":"https://qi-xiang.github.io/tags/%E7%B6%B2%E9%A0%81%E5%9F%BA%E7%A4%8E/"}]},{"title":"原子習慣 書摘(3)","slug":"atomhabit-3","date":"2021-12-06T03:33:44.000Z","updated":"2022-03-13T17:21:49.881Z","comments":true,"path":"2021/12/06/atomhabit-3/","link":"","permalink":"https://qi-xiang.github.io/2021/12/06/atomhabit-3/","excerpt":"","text":"四個簡單的步驟，讓你建立更好的習慣 內容待補…","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"原子習慣","slug":"原子習慣","permalink":"https://qi-xiang.github.io/tags/%E5%8E%9F%E5%AD%90%E7%BF%92%E6%85%A3/"}]},{"title":"原子習慣 書摘(2)","slug":"atomhabit-2","date":"2021-11-02T16:51:28.000Z","updated":"2022-03-13T17:21:33.366Z","comments":true,"path":"2021/11/03/atomhabit-2/","link":"","permalink":"https://qi-xiang.github.io/2021/11/03/atomhabit-2/","excerpt":"","text":"第二章 改變習慣的最有效方法，是改變身分認同 改變習慣之所以如此具有挑戰性，原因有二 : 試圖改變的東西不對 試圖改變習慣的方式不對 改變的發生分成三個層次 : 改變結果 : 重點放在改變成果，設定的目標多與這個層次的變化有關 改變過程 : 重點在於改變習慣與系統，建立的習慣多與此有關 改變身分認同 : 三層次中最為重要，主在改變信念、世界觀、自我形象、對自己與他人的評價，抱持的信念、假設或偏見多與此相關 結果 : 得到什麼 過程 : 做了什麼 身分認同 : 相信什麼 每一層次的改變各有其用處，問題在於改變的方向。 一般人在改變習慣的過程中，常把重點放在想要達成什麼，以結果為基礎建立習慣。而比較好的做法是以身分認同建立習慣，把重點放在想成為什麼樣的人。 許多人設立目標，然後確立要達成目標必須採取的行動，但卻不加思考驅使他們採取那些行動的信念，不去改變過去看待自己的方式，同時亦不知舊的身分認同，會破壞為了改變而打造的新計畫。 每個行動系統的背後都是一個信念系統。 以投票為例，在獨裁統治這個信念系統下，投票這個行為是不可行的。不是那個系統的身分認同，行為在某些信念之下是不可能被實現的。 信念與假設形塑出系統，習慣的背後往往存在著身分認同。 或許你現在有新的目標與計劃，但你還沒改變自己是什麼樣的人。 越是以身分認同中的某個特定面向自豪，越有動力去維持相關的習慣，但只要行為背後的信念不改變，就很難維持長期的轉變。 真正能帶來行為上改變的是身分認同的轉變。例如 : 目標不是去讀一本書，而是成為讀書的人。 行為可以反映出身分認同，一個人的所作所為暗示他相信自己是什麼樣的人。 當一個人相信他身分中的某個特定面向，就越有可能採取與之相符的行動。 為你所用時，身分認同的改變會是自我改善的一大利器；但與你為敵時，身分認同卻反倒成了一種詛咒，例如 : 附加在身分認同上的刻版印象。 我方向感很差、不擅長數學、整天遲到，不斷反覆對自己訴說同一件事，長期就容易開始抗拒某些事。思想或行為與身分認同牽扯越深，就越難去做出改變。 好習慣在理性上也許合理，但只要與身分認同相左，就很難產生實踐的念頭。若要持續的進步就不能一味依附在特定的身分認同，而是必須不斷修正、拓展自身的身分認同。 改變身分認同的兩個步驟 人不是一生下來就擁有預設信念，每個信念以及對自身的看法，都由後天的經驗形塑而成。習慣恰好是個人身分認同的具體化。 越是重複某一行為，就越強化與那個行為相關的身分認同。 有越多證據支持某個信念，就越會對其深信不疑。 一次性經驗的效果容易消失，但習慣的效果卻會隨時間不斷增強。 每次採取的行動都像一張選票，投給想要成為的那一種人。沒有單一例證可以改變你的信念，但隨著票數累積，新身分的證據也聚沙成塔。 習慣就是通往身分認同轉變的道路。要改變你是什麼樣的人，最實際的方法就是改變你做的事。 每次選擇去做某個壞習慣，就相當於投一票給那個身分，但在每一次的選舉中，並不一定要拿到所有的選票才能獲勝，只要保證在多數情況下都是由好習慣獲勝就好。 型塑新身分認同的兩步驟 : 決定你想要成為什麼樣的人 透過生活中的小勝利來向自己證明 將焦點從成果轉往身分認同。 你的習慣型塑你的身分認同，你的身分認同又型塑你的習慣，這是一條雙向道。 焦點永遠都要放在成為某一種人，而非得到某一種成果。 習慣會讓你變成你想要成為的人 你有能力改變對自身的信念。你的身分認同並非不可變更，每一刻你都有選擇。 根本上，習慣的精髓並非擁有，而是成為。 歸根究柢，習慣之所以重要，是因為它們能夠讓你變成你想要成為的人。","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"原子習慣","slug":"原子習慣","permalink":"https://qi-xiang.github.io/tags/%E5%8E%9F%E5%AD%90%E7%BF%92%E6%85%A3/"}]},{"title":"2021/10/25 NLP Matplotlib(範例2)","slug":"nlp20211025-2","date":"2021-10-31T16:38:35.000Z","updated":"2022-03-13T17:24:34.425Z","comments":true,"path":"2021/11/01/nlp20211025-2/","link":"","permalink":"https://qi-xiang.github.io/2021/11/01/nlp20211025-2/","excerpt":"","text":"Bar chart 長條圖 matplotlib.pyplot.bar Python 長條圖（Bar Charts） matplotlib.pyplot.xticks 123456789101112#繪製長條圖#%matplotlib inline#導入必要的模組import matplotlibimport numpy as npimport matplotlib.pyplot as plt#指定 x、y座標x = [4, 5, 6, 7, 8, 9]y = [2, 10, 3, 2, 8, 7]plt.bar(x, y) #指定長條圖中的座標plt.show() #繪製出圖表 水平長條圖 123456789101112# barh()用來畫水平方向的長條圖#%matplotlib inline#導入必要的模組import matplotlibimport numpy as npimport matplotlib.pyplot as plt#指定 x、y座標x = [&#x27;sleep&#x27;, &#x27;study&#x27;, &#x27;play&#x27;]y = [2, 10, 3]plt.barh(x, y, color=&#x27;green&#x27;) #繪製水平方向的長條圖plt.show() #繪製出圖表 Grouped Bar Charts 123456789101112131415161718192021222324#%matplotlib inline#導入必要的模組import matplotlibimport numpy as npimport matplotlib.pyplot as pltN = 5men_means = (20, 35, 30, 35, 27)women_means = (25, 32, 34, 20, 25)ind = np.arange(N) # ind = [0 1 2 3 4]width = 0.25 #bar(x, height, width=0.8, bottom=None, *, align=&#x27;center&#x27;, data=None, **kwargs)#bar() 的第一個參數是 x 軸上的座標plt.bar(ind, men_means, width, label=&#x27;Men&#x27;)plt.bar(ind + width, women_means, width, label=&#x27;Women&#x27;) #將第二個長條圖的x座標加上width，讓它落在前一個長條圖之後plt.ylabel(&#x27;Scores&#x27;) #調整坐標軸名稱plt.title(&#x27;Scores by group and gender&#x27;) #設定圖表名稱#xticks(ticks=None, labels=None, **kwargs)plt.xticks(ind + width / 2, (&#x27;G1&#x27;, &#x27;G2&#x27;, &#x27;G3&#x27;, &#x27;G4&#x27;, &#x27;G5&#x27;)) #調整刻度的 x 座標，讓它剛好落在中間plt.legend(loc=&#x27;best&#x27;) #標示出各長條圖plt.show() #繪製出長條圖 Stacked Bar Charts 12345678910111213141516171819202122232425262728#%matplotlib inline#導入必要的模組import matplotlibimport numpy as npimport matplotlib.pyplot as pltcountries = [&#x27;USA&#x27;, &#x27;GB&#x27;, &#x27;China&#x27;, &#x27;Russia&#x27;, &#x27;Germany&#x27;]bronzes = np.array([38, 17, 26, 19, 15])silvers = np.array([37, 23, 18, 18, 10])golds = np.array([46, 27, 26, 19, 17])#產生有序串列，[(0, &#x27;USA&#x27;), (1, &#x27;GB&#x27;), (2, &#x27;China&#x27;), (3, &#x27;Russia&#x27;), (4, &#x27;Germany&#x27;)]ind = [x for x,_ in enumerate(countries)] #bar(x, height, width=0.8, bottom=None, *, align=&#x27;center&#x27;, data=None, **kwargs)[source]#bottom 參數使指要從 y 軸上的哪個座標開始繪製#bottom=silvers+bronzes，表示要畫在銅牌和銀牌之上plt.bar(ind, golds, width=0.8, label=&#x27;golds&#x27;, color=&#x27;gold&#x27;, bottom=silvers+bronzes) plt.bar(ind, silvers, width=0.8, label=&#x27;silvers&#x27;, color=&#x27;silver&#x27;, bottom=bronzes)plt.bar(ind, bronzes, width=0.8, label=&#x27;bronzes&#x27;, color=&#x27;#CD853F&#x27;)plt.xticks(ind, countries) #設定x方向的刻度plt.ylabel(&quot;Medals&quot;) #設定y座標標題plt.xlabel(&quot;Countries&quot;) #設定x座標標題plt.legend(loc=&quot;upper right&quot;) #標示出圖表內容plt.title(&quot;2012 Olympics Top Scorers&quot;) #賦予圖表標題plt.show() #繪製出圖表 Scatter chart matplotlib.pyplot.scatter 在 Matplotlib 中為散點圖設定顏色 Matplotlib 標記散點 散佈圖 12345678910111213141516#繪製散射圖#%matplotlib inline#導入需要的套件import matplotlibimport numpy as npimport matplotlib.pyplot as plt#指定散佈圖上每一點的座標x = [4, 4, 7, 7 , 8 , 5]y = [2, 10, 3, 2 , 8 , 7]&#x27;&#x27;&#x27;scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None,vmin=None, vmax=None,alpha=None, linewidths=None, *, edgecolors=None, plotnonfinite=False, data=None, **kwargs)&#x27;&#x27;&#x27;plt.scatter(x, y, color=&#x27;red&#x27;)#用紅色在圖表上標出所有點plt.show()#繪製圖表 分群散射圖 1234567891011121314151617181920212223#繪製分群散射圖#%matplotlib inline#導入需要的套件import matplotlibimport numpy as npimport matplotlib.pyplot as plt # Create dataN = 60 #指定隨機生成的陣列大小#numpy.random.rand() 函式生成具有隨機值的指定形狀的陣列。g1 = (0.6 + 0.6 * np.random.rand(N), np.random.rand(N))g2 = (0.4+0.3 * np.random.rand(N), 0.5*np.random.rand(N))g3 = (0.3*np.random.rand(N),0.3*np.random.rand(N))data = (g1, g2, g3)colors = (&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;) #指定點的顏色groups = (&quot;coffee&quot;, &quot;tea&quot;, &quot;water&quot;) #指定點的類別for data, color, group in zip(data, colors, groups): #zip()可以把元素整合成tuple x, y = data #從data取出點座標 plt.scatter(x, y, alpha=0.8, c=color, edgecolors=&#x27;m&#x27;, s=50, label=group) #畫散佈圖plt.legend(loc=2)#標示圖表內容plt.title(&#x27;Matplot scatter plot&#x27;)#賦予圖表標題plt.show()#實際繪製出圖表 12345x = [1,2,3]y = [4,5,6]for i in zip(x,y): #使用 zip函數把 list 內對應元素鏈起來(tuple) print(i) Histogram 如何在 Matplotlib 中繪製資料列表的直方圖 matplotlib.pyplot.hist Numpy numpy.random.rand()函式 直方圖 12345678910111213141516#繪製直方圖#%matplotlib inline#導入需要的套件import matplotlibimport numpy as npimport matplotlib.pyplot as pltx = [1, 17, 3, 24, 44]&#x27;&#x27;&#x27;hist(x, bins=None, range=None, density=False, weights=None, cumulative=False, bottom=None, histtype=&#x27;bar&#x27;,align=&#x27;mid&#x27;,orientation=&#x27;vertical&#x27;, rwidth=None, log=False, color=None, label=None, stacked=False, *, data=None, **kwargs)&#x27;&#x27;&#x27;#plt.hist(x, bins=[0, 10, 20, 30, 40, 50])plt.hist(x, bins=[0, 10, 20, 30, 40, 50], density=True) #bin設定數值區間 #density=True，以個數百分比表示高度plt.show() #繪製圖表 用高斯常態分配生成資料 123456789101112131415#%matplotlib inline#導入需要的套件import matplotlibimport numpy as npimport matplotlib.pyplot as plt## Generate gaussian number 高斯常態分配# mean = 2.0# std = 3.0# number of points = 1000data = np.random.normal(2.0, 3.0, 1000)#用高斯常態分配生成資料plt.hist(data)#bins預設是10plt.xlabel(&#x27;Value&#x27;)#設定x座標標題plt.ylabel(&#x27;Frequency&#x27;)#設定y座標標題plt.title(&#x27;Histogram&#x27;)#設定圖表的標題plt.show()#實際繪製出圖表 Boxplot matplotlib.pyplot.boxplot Matplotlib 繪製箱線圖 箱型圖 12345678910111213#%matplotlib inlineimport matplotlib.pyplot as plt# ref: http://www.datasciencemadesimple.com/box-plot-in-python/#箱型圖的資料們value1 = [82,76,24,40,67,62,75,78,71,32,98,89,78,67,72,82,87,66,56,52]value2=[62,5,91,25,36,32,96,95,3,90,95,32,27,55,100,15,71,11,37,21]value3=[23,89,12,78,72,89,25,69,68,86,19,49,15,16,16,75,65,31,25,52]value4=[59,73,70,16,81,61,88,98,10,87,29,72,16,23,72,88,78,99,75,30] box_plot_data=[value1,value2,value3,value4] #整合資料plt.boxplot(box_plot_data) #繪製箱型圖plt.show()#實際繪製圖表 Pie char matplotlib.pyplot.pie [Day20]Matplotlib資料視覺化進階！ 如何在 Matplotlib 中繪製圓 matplotlib.patches.Circle 圓餅圖 1234567891011#繪製圓餅圖import matplotlib.pyplot as plt labels = [&#x27;Cookies&#x27;, &#x27;Jellybean&#x27;, &#x27;Milkshake&#x27;, &#x27;Cheesecake&#x27;]#用來標示圖表sizes = [38.4, 40.6, 20.7, 10.3]#指定每一塊所占比例colors = [&#x27;yellowgreen&#x27;, &#x27;gold&#x27;, &#x27;lightskyblue&#x27;, &#x27;lightcoral&#x27;]#指定每一塊的顏色patches, texts = plt.pie(sizes, colors=colors, shadow=True, startangle=90)#startangle可以指定向逆時針旋轉幾度plt.legend(patches,labels, loc=&quot;best&quot;)#標示圖表內容plt.axis(&#x27;equal&#x27;)#plt.axis除了可以設定x和y軸也可以設定其他樣式，ex： equal可以讓x和y軸的單位一樣。plt.tight_layout()#tight_layout() 方法會自動保持子圖之間的正確間距plt.show() 調整特定塊向外移動(explode) 123456789101112131415161718#繪製圓餅圖#%matplotlib inlineimport matplotlib.pyplot as plt# ref: https://matplotlib.org/examples/pie_and_polar_charts/pie_demo_features.html# Pie chart, where the slices will be ordered and plotted counter-clockwise:labels = &#x27;Frogs&#x27;, &#x27;Hogs&#x27;, &#x27;Dogs&#x27;, &#x27;Logs&#x27;#用來標示圖表sizes = [15, 30, 45, 10]#指定每一塊所占比例explode = (0, 0.1, 0, 0) # only &quot;explode&quot; the 2nd slice (i.e. &#x27;Hogs&#x27;) 向外位移指定的塊，同時指定位移的量&#x27;&#x27;&#x27;fig1, ax1 = plt.subplots()ax1.pie(sizes, explode=explode, labels=labels, autopct=&#x27;%1.1f%%&#x27;, shadow=True, startangle=90)ax1.axis(&#x27;equal&#x27;) # Equal aspect ratio ensures that pie is drawn as a circle.&#x27;&#x27;&#x27;plt.pie(sizes, explode=explode, labels=labels, autopct=&#x27;%1.1f%%&#x27;, shadow=True, startangle=90) #autopct 標示每一塊佔的比例，保留到小數點後一位plt.axis(&#x27;equal&#x27;) ##plt.axis除了可以設定x和y軸也可以設定其他樣式，ex： equal可以讓x和y軸的單位一樣。plt.show() 變化版的圓餅圖，圓環圖!? 1234567891011121314151617181920212223242526#%matplotlib inlineimport matplotlib.pyplot as plt# Pie chartlabels = [&#x27;Frogs&#x27;, &#x27;Hogs&#x27;, &#x27;Dogs&#x27;, &#x27;Logs&#x27;]#用來標示圖表sizes = [15, 30, 45, 10]#指定每一塊所占比例#colorscolors = [&#x27;#ff9999&#x27;,&#x27;#66b3ff&#x27;,&#x27;#99ff99&#x27;,&#x27;#ffcc99&#x27;]#指定每一塊的顏色#explsionexplode = (0.05,0.05,0.05,0.05)#pcdistance設定數字離圓心的距離plt.pie(sizes, colors = colors, labels=labels, autopct=&#x27;%1.1f%%&#x27;, startangle=90, pctdistance=0.85, explode = explode)#draw circlecentre_circle = plt.Circle((0,0),0.70,fc=&#x27;white&#x27;)#fc設定圓形的顏色 0.70是透明度fig = plt.gcf() #get current figure# Matplotlib.axes.Axes.add_artist() 在坐標軸上添加新的圖#使用 add_artist 方法在軸上新增 circle，因為 circle 是 Artist 的子類fig.gca().add_artist(centre_circle)#gca()方法圖形模塊用於獲取當前軸# Equal aspect ratio ensures that pie is drawn as a circleplt.axis(&#x27;equal&#x27;) plt.tight_layout()plt.show()","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"NLP自然語言處理","slug":"NLP自然語言處理","permalink":"https://qi-xiang.github.io/tags/NLP%E8%87%AA%E7%84%B6%E8%AA%9E%E8%A8%80%E8%99%95%E7%90%86/"}]},{"title":"原子習慣 書摘(1)","slug":"atomhabit-1","date":"2021-10-28T09:29:19.000Z","updated":"2022-03-13T17:21:53.857Z","comments":true,"path":"2021/10/28/atomhabit-1/","link":"","permalink":"https://qi-xiang.github.io/2021/10/28/atomhabit-1/","excerpt":"","text":"第一章 原子習慣的驚人力量 複利效應，讓小習慣造就大不同 人們很容易高估一個決定性瞬間的重要性，卻也容易低估每天都做些小改善的價值。 短期來看，每天百分之一的改善並不值得特別注意，但從長遠來看，意義可能非常大。假設每天都進步百分之一，持續一年後，你會進步37倍之多，若每天都退步百分之一，持續一年後，你會退步到趨近於0。 複利效應的驚人威力，讓起初看似不起眼的小勝利或小失敗，經長期累積造就出巨大差異。 好的習慣在執行的過程中，如果只挑其中一天來看，效果可能不是那麼明顯，但在長期的&quot;複利效應&quot;作用下，幾年之後回頭看，好習慣的價值與壞習慣的代價變得極為明顯。 好習慣帶來的改變通常是緩慢的，也因此讓惡習有悄悄生根的機會。 假設一個人正在減肥，他打算透過規律運動和正常飲食來達成目的，但經過速食店時，心想今天吃一餐垃圾食物，體重計上的數字也不會有任何變化吧?之後，他以此為藉口合理化自己錯誤的決策。 造就成功的，是日常習慣，而不是千載難逢的轉變。 重要的不是你現在有多成功或多失敗，而是你是否處在對的軌道上。百萬富翁如果每個月都入不敷出，最後就不會有好結果。反之，即便你現在窮困潦倒，但每個月都想方設法一點錢，那你就在通往財富自由的路上。 好習慣讓時間成為你的盟友，壞習慣讓時間與你為敵。 建立持久的習慣為何這麼難? 在跨越一個關鍵門檻前，習慣往往看起來沒什麼影響，在追尋目標的前期或中期，常常出現&quot;失望之谷&quot;，你期待有限性進展，但在前幾天、幾周或幾個月，效果都很不顯著，令人感到挫折。 然而，這正是複利過程中的標誌，強大的成果總是姍姍來遲。 這也是好的習慣難以維持的原因，在短時間內難以看到有形的改變，就容易產生放棄的念頭。 好的習慣習慣在短時間內會進入一段停滯期，而你每天做的工並沒有浪費，只是被儲存起來，作為突破停滯期的能量。當你突破停滯期，大家會說那是一夕成功，但只有你知道，正是因為很久以前持續做的事，讓今日的躍進成為可能。 石匠敲打石頭，可能敲打了一百下，石頭上連條裂縫都沒有，但就在第一百零一下，石頭斷裂成兩半，把石頭劈成兩半的不是最後那一下，而是先前的每一次敲擊。 別管目標，專注於系統就好 主流觀點認為，若要得到人生中想要的事物，最好的方法就是設定可行的確切目標。 但成果與設定的目標著實沒有太大的關係，反倒與所遵循的系統息息相關。 系統與目標的差異在於，目標是你想要達到的成果，系統是讓你達到成果的過程。 那如果徹底無視目標，只關注在系統，還能成功嗎? 答案是肯定的。 以運動比賽為例，把分數當作是目標，所以整場盯著記分板，這未免太荒謬了，真正能帶來勝利的是每天都進步一點，分數會顧好它自己。 然而，目標真的完全沒用嗎? 當然不是，目標有助於確立方向，但系統是進步的最佳解答。 贏家跟輸家擁有相同目標 目標設定受到嚴重的生存者偏差影響，我們往往都聚焦在最終獲得勝利的人身上，而自動忽略擁有相同目標卻失敗的那一群人，忘記重點不在目標而在系統。 儘管目標相同，系統卻未必，也就是追求目標過程的不同，造就截然不同的結果。 目標達成不過是短暫的改變 假設你的房間很亂，你設定了清理這個目標，之後也達成目標，得到乾淨的房間。 但這個目標的達成只能暫時改變你的生活，因為導致你房間變亂的系統並沒有被改變。從結果面著手，只能暫時解決問題，想要永久改善，就必須從系統面下手。 目標限制了你的快樂 目標創造了一種&quot;非A即B&quot;的衝突，若沒有成功達到目標，就是失敗而令人失望，把自己框限在狹隘的快樂裡。 系統優先的心態提供了解藥，當你愛上過程而非產物，只要系統有在運作，你隨時都能感到滿足。 目標與長期進步互相矛盾 目標取向的心態可能造成&quot;溜溜球效應&quot;。跑者持續努力數月，但衝過終點線之後，就停止訓練了。比賽結束，鼓勵亦隨之消失。 當你的一切努力都聚焦在一個特定目標，達成目標後。又有什麼能推動你繼續前進? 也因為這樣，很多人會在達成目標後，重新撿起放下的壞習慣。 重點不在任何單一成就，而在持續不斷改善的循環。Progress(進步)的必要條件是對Process(過程)的投入。 原子習慣的系統 決定你成功或失敗的，不是你的目標，而是你的系統。 原子習慣指的是微小的改變，但並不是任何微小的習慣都算是原子習慣。 原子習慣是一個更大系統的一部分，如同原子是分子的組成單元，原子是建構非凡成果的原件。習慣就像人生的原子，每一個習慣都是造就你整體增長的基本元件。 習慣雖小，力量無窮，這便是&quot;原子習慣&quot;一詞的真義。","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"原子習慣","slug":"原子習慣","permalink":"https://qi-xiang.github.io/tags/%E5%8E%9F%E5%AD%90%E7%BF%92%E6%85%A3/"}]},{"title":"李永樂老師講比特幣(2)-重點整理","slug":"blockchainyt2","date":"2021-10-25T17:57:39.000Z","updated":"2022-03-13T17:22:03.653Z","comments":true,"path":"2021/10/26/blockchainyt2/","link":"","permalink":"https://qi-xiang.github.io/2021/10/26/blockchainyt2/","excerpt":"","text":"比特幣是一種’‘電子記帳系統’'，所有交易紀錄皆為公開且匿名 如何保證交易紀錄的真實性 身分驗證 傳統: 人臉辨識、簽名、指紋 電子系統: 電子簽名 電子簽名(數位簽章) 比特幣用戶註冊時，系統會生成一&quot;隨機數&quot;，透過隨機數會產生&quot;私鑰&quot;(私有)字串，私鑰字串又可產生&quot;公鑰&quot;(公開)字串，公鑰又可產生&quot;地址&quot;(公開) 公鑰無法反算私鑰 自己轉出比特幣: 公鑰+地址 他人轉入比特幣: 地址 私鑰可以對字串進行加密 公鑰可以解密私鑰加密的字串 以上稱為非對稱加密(ex.RSA是非對稱加密的一種) 例子: 假設A給B 10個比特幣 1.A先寫一條紀錄(A給10比特幣到B)，之後進行Hash運算，再用私鑰進行加密，產生一組密碼 2.將交易訊息、公鑰、密碼對每一節點進行&quot;廣播&quot;，節點會去運用紀錄去做Hash運算，與運用公鑰解密後的密碼進行比對，驗證其交易的真偽 3.現假設A只有10個比特幣，卻同時給兩人10比特幣(double spending problem) 如何進行帳戶餘額檢查 A廣播出交易訊息後，區塊鏈中的節點會往前檢查每一區塊中A的交易紀錄(追溯)，確認A的餘額 防止雙重支付 A同時廣播兩條消息 給B 10比特幣 給C 10比特幣 每一個節點會去算A的餘額是否還夠，如果剛好有10比特幣的話，一些節點收到第一條消息就會拒絕第二條(因為餘額不足)，反之亦然。 第1(或2)的消息會被放到區塊中(未被確認)，當有一個節點解出隨機數，新的區塊會被鏈結到區塊鏈中，其餘節點則會放棄打包區塊的機會，自動承認第一個產生的區塊，此時第1(或2)個消息被確認，另一消息則不會被確認(此時A餘額已經確定是0) 只有當區塊鏈接到區塊鏈上，交易才真正完成 防止竄改 最長鏈原則 當有兩個礦工同時找到一個新區塊(產生分支，上、下)，當上面區塊的下一個區塊先被找到，此時上面的鏈結就比下面的長，所有人會跟著往上面走，下方區塊則打包失敗 若有人想要修改自己的交易紀錄，就要從該筆交易紀錄區塊開啟新分支(往另一方向走)，但根據最長鏈規則，這筆紀錄不會被其他節點承認 REF: 比特幣交易如何防偽？私鑰公鑰地址啥意思？李永樂老師講比特幣（2）","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"區塊鏈","slug":"區塊鏈","permalink":"https://qi-xiang.github.io/tags/%E5%8D%80%E5%A1%8A%E9%8F%88/"}]},{"title":"李永樂老師講比特幣(1)-重點整理","slug":"blockchainyt1","date":"2021-10-25T17:57:33.000Z","updated":"2022-03-13T17:21:58.291Z","comments":true,"path":"2021/10/26/blockchainyt1/","link":"","permalink":"https://qi-xiang.github.io/2021/10/26/blockchainyt1/","excerpt":"","text":"一、 比特幣是一種基於&quot;密碼學&quot;的電子貨幣 2008年11月1日 中本聰-&gt;(白皮書-比特幣:一種點對點的交易系統) 去中心化的電子記帳系統-&gt;帳本皆為公開 假設: 現有4人，A、B、C、D A支付B:10比特幣、 B支付C:5比特幣、 C支付D:2比特幣 ，每筆交易廣播給其他3人，而這些交易紀錄會形成一個&quot;區塊&quot;，再將其鏈結到舊區塊上，形成&quot;區塊鏈&quot;。 問題 1.帳單以誰為準?(會因為延遲造成每人的資訊不對稱) 2.為何需要記帳? 3.如何防偽? 為何需要記帳? 記帳有獎勵 手續費收益 打包交易紀錄獎勵(只能一個人) 中本聰設計為10分鐘打一個包，每打一個包獎勵50比特幣，每4年遞減，故比特幣有總量限制，約只有2100萬個 帳單以誰為準? 只能一個人打包 中本聰-&gt;工作量證明(PoW) 每一參與打包的用戶都必須解數學題，做出來後，就有打包的權利，並獲得手續費、打包獎勵-&gt;挖到礦 二、 挖礦原理 Hash Function: SHA256(256位的二進位數) 特色: 正向算容易，反向算困難 具體原理 每一區塊並不只有交易訊息，還可分成區塊的頭部 數學題的產生 字符串: 前區塊的頭部+現有帳單信息+時間+…+隨機數 對字符串作2次Hash Function(SHA256)，產生2進位數 規定前幾位數必須是0(關係到運算難度) 算出的Hash數做為新區塊的頭部完成打包，並與舊區塊鏈結-&gt;挖礦Fin. 如何算出前幾位是0? 透過改變隨機數(其餘都是定值) 比賽誰的計算能力強 計算難度設置 特過操控前n位0-&gt;保證每10分鐘打包一個區塊 REF: 比特幣和區塊鏈到底是啥？礦機挖礦咋回事？李永樂老師講比特幣(1)","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"區塊鏈","slug":"區塊鏈","permalink":"https://qi-xiang.github.io/tags/%E5%8D%80%E5%A1%8A%E9%8F%88/"}]},{"title":"2021/10/25 NLP Matplotlib(範例1)","slug":"nlp20211025","date":"2021-10-25T15:04:45.000Z","updated":"2022-03-13T17:24:37.903Z","comments":true,"path":"2021/10/25/nlp20211025/","link":"","permalink":"https://qi-xiang.github.io/2021/10/25/nlp20211025/","excerpt":"","text":"Axes Axes 圖框 程式語言-看盤版面(上)-圖框教學 123456789101112131415161718192021222324252627282930313233343536373839#產生圖中圖的效果#%matplotlib inline #此行是為了將圖表呈現在jupyter notebook中#import 需要的套件import matplotlibimport numpy as npimport matplotlib.pyplot as plt#開始繪圖fig = plt.figure()#指定x,y軸座標x = [1, 2, 3, 4, 5, 6, 7]y = [1, 3, 4, 2, 5, 8, 6]# below are all percentage 下面的數字全部都是以百分比為單位#使用add_axes繪製圖框，圖框的位置是自己定義的，兩個圖塊可以重疊#參數：add_axes( x初始座標, y初始座標, 寬, 高 )left, bottom, width, height = 0.1, 0.1, 0.8, 0.8ax1 = fig.add_axes([left, bottom, width, height]) # main axesax1.plot(x, y, &#x27;r&#x27;) #將線段以紅色繪出ax1.set_xlabel(&#x27;x&#x27;) #賦予坐標軸名稱ax1.set_ylabel(&#x27;y&#x27;)ax1.set_title(&#x27;title&#x27;) #圖表的標題ax2 = fig.add_axes([0.2, 0.6, 0.25, 0.25]) # inside axesax2.plot(y, x, &#x27;b&#x27;) #同上ax2.set_xlabel(&#x27;x&#x27;)ax2.set_ylabel(&#x27;y&#x27;)ax2.set_title(&#x27;title inside 1&#x27;)# different method to add axes 另一種新增圖框的方法####################################plt.axes([0.05, 0.2, 0.8, 0.25])plt.plot(y[::-1], x, &#x27;g&#x27;) #同上plt.xlabel(&#x27;x&#x27;)plt.ylabel(&#x27;y&#x27;)plt.title(&#x27;title inside 2&#x27;)plt.show()#plt.savefig(&quot;./axes_plot.png&quot;,dpi=72) x/y limit xlim、ylim 限制作畫的座標軸範圍 123456789101112131415161718192021222324# x/y limit 限制 x,y 畫的範圍%matplotlib inline#引入需要的套件import matplotlibimport numpy as npimport matplotlib.pyplot as plt#在 -pi~pi 之間產生256個均分點(等差數列)，包含 stop(endpoint=True)X = np.linspace(-np.pi, np.pi, 256, endpoint=True) C,S = np.cos(X), np.sin(X) #換算成 sin、cos 值# x limits#plt.xlim(0, 3) #在 x 軸只畫 0~3 的範圍plt.xlim(X.min()*1.1, X.max()*1.1) #乘上 1.1 是為了完整呈現圖表預留空間# y limitsplt.ylim(C.min()*1.1, C.max()*1.1) #如果不乘上 1.1 則圖表會顯得比較擠plt.plot(X,C) #繪製線段plt.plot(X,S, color=&#x27;red&#x27;, linewidth=10) #linewidth 調整線條粗細 plt.show() #顯示圖表#plt.savefig(&quot;./limit_plot1.png&quot;,dpi=72) x/y tick xticks、yticks 用來設定圖表座標軸刻度 xticks的詳細參數說明 123456789101112131415161718192021222324252627#%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltX = np.linspace(-np.pi, np.pi, 256, endpoint=True) #跟之前一樣產生256個數字的等差數列C,S = np.cos(X), np.sin(X) #換算sin、cos值# x limitsplt.xlim(-4.0,4.0) #設定 x 座標的範圍# x ticks#在 -4~4 間，產生9個均分點，包含 stop，並以此作為 x 軸上的刻度plt.xticks(np.linspace(-4,4,9,endpoint=True)) # y limitsplt.ylim(-1.0,1.0) #在不調整的情況下，會有部分圖形消失# y ticks#同於 x 軸plt.yticks(np.linspace(-1,1,5,endpoint=True)) plt.plot(X,C) #繪製線段plt.plot(X,S, color=&#x27;red&#x27;, linewidth=10)plt.show() #顯示圖表#plt.savefig(&quot;./ticks_plot1.png&quot;,dpi=72) 使用 LaTex Format 作為 ticks label Latex各种命令、符号、公式、数学符号、排版 123456789101112131415161718192021#%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltX = np.linspace(-np.pi, np.pi, 256, endpoint=True)C,S = np.cos(X), np.sin(X)# latex format 數學格式轉換#下面將刻度以 latex 方式呈現plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r&#x27;$-\\pi$&#x27;, r&#x27;$-\\pi/2$&#x27;, r&#x27;$0$&#x27;, r&#x27;$+\\pi/2$&#x27;, r&#x27;$+\\pi$&#x27;]) #第一個參數是實際的數值、第二個參數作為label使用plt.yticks([-1, 0, +1], [r&#x27;$-1$&#x27;, r&#x27;$0$&#x27;, r&#x27;$+1$&#x27;]) #前面加上 r 表示是原始字串plt.plot(X,C)plt.plot(X,S, color=&#x27;red&#x27;, linewidth=10)plt.show() #顯示圖表#plt.savefig(&quot;./ticks_plot2.png&quot;,dpi=72) Coordinate axis 移動x,y座標軸 ax.spines——matplotlib坐标轴设置 Matplotlib入门-3-plt.gca( )挪动坐标轴 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltx = np.linspace(-3, 3, 50) #在-3到3間產生等差數列(數量為50)y1 = 2*x + 1y2 = x**2plt.figure() #開始繪圖plt.plot(x, y2)# plot the second curve in this figure with certain parametersplt.plot(x, y1, color=&#x27;red&#x27;, linewidth=1.0, linestyle=&#x27;--&#x27;) #調整線段粗細以及樣式# set x limitsplt.xlim((-1, 2)) #設定座標軸範圍限制plt.ylim((-2, 3))# set new ticksnew_ticks = np.linspace(-1, 2, 5) #設定圖表的刻度plt.xticks(new_ticks)# set tick labelsplt.yticks([-2, -1.8, -1, 1.22, 3], [&#x27;$really\\ bad$&#x27;, &#x27;$bad$&#x27;, &#x27;$normal$&#x27;, &#x27;$good$&#x27;, &#x27;$really\\ good$&#x27;])# to use &#x27;$ $&#x27; for math text and nice looking, e.g. &#x27;$\\pi$&#x27;# gca = &#x27;get current axis&#x27;ax = plt.gca() #獲取圖像的軸，總共有四個軸top、bottom、left和right#不需要right、top的座標軸，故將其顏色設為none(透明)#ax.spines[&#x27;right&#x27;]取得右方的軸，以此類推ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;) ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)ax.xaxis.set_ticks_position(&#x27;bottom&#x27;) #設定x軸方向刻度的位置# ACCEPTS: [ &#x27;top&#x27; | &#x27;bottom&#x27; | &#x27;both&#x27; | &#x27;default&#x27; | &#x27;none&#x27; ]ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0)) #&#x27;data&#x27;表示按數值挪動，其後數字代表挪動到Y軸的刻度值# the 1st is in &#x27;outward&#x27; | &#x27;axes&#x27; | &#x27;data&#x27;# axes: percentage of y axis# data: depend on y dataax.yaxis.set_ticks_position(&#x27;left&#x27;) #同x軸刻度# ACCEPTS: [ &#x27;left&#x27; | &#x27;right&#x27; | &#x27;both&#x27; | &#x27;default&#x27; | &#x27;none&#x27; ]ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;,0)) #同上plt.show() #繪製出圖表#plt.savefig(&quot;./Coordinate_axis.png&quot;,dpi=72) Annotation 用於寫註解 plt.scatter()函数解析（最清晰的解释） matplotlib.pyplot.annotate matplotlib.pyplot.text 123456789101112131415161718192021222324252627282930313233343536373839#%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltx = np.linspace(-3, 3, 50)y = 2*x + 1plt.figure(num=1, figsize=(8, 5),)plt.plot(x, y,)ax = plt.gca()ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))ax.yaxis.set_ticks_position(&#x27;left&#x27;)ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0))x0 = 1y0 = 2*x0 + 1plt.plot([x0, x0,], [0, y0,], &#x27;k--&#x27;, linewidth=2.5) #linestyle=&#x27;k--&#x27;plt.scatter([x0, ], [y0, ], s=50, color=&#x27;b&#x27;) #s代表的是點的大小，scatter()用來畫散佈圖# method 1:######################用於寫註解 詳細參數說明: https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.annotate.htmlplt.annotate(r&#x27;$2x+1=%s$&#x27; % y0, xy=(x0, y0), xycoords=&#x27;data&#x27;, xytext=(+30, -30), textcoords=&#x27;offset points&#x27;, fontsize=16, arrowprops=dict(arrowstyle=&#x27;-&gt;&#x27;, connectionstyle=&quot;arc3,rad=.2&quot;))# method 2:#########################用於在圖表中加入文字 詳細參數說明: https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.text.htmlplt.text(-3.7, 3, r&#x27;$This\\ is\\ the\\ some\\ text. \\mu\\ \\sigma_i\\ \\alpha_t$&#x27;, fontdict=&#123;&#x27;size&#x27;: 16, &#x27;color&#x27;: &#x27;r&#x27;&#125;)plt.show() #繪製出圖表#plt.savefig(&quot;./Annotation.png&quot;,dpi=72) Line Style 調整線的樣式 (ex. 虛線) matplotlib.pyplot.plot (裡面有關於marker、linestyle的詳細說明) 1234567891011121314151617#%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltcolor = &#x27;cornflowerblue&#x27;X = np.linspace(-np.pi, np.pi, 256, endpoint=True) #等差數列C = np.cos(X) #計算 cos 值linestyles = [&#x27;-&#x27;, &#x27;--&#x27;, &#x27;-.&#x27;, &#x27;:&#x27;] #不同的線段樣式for x, linestyle in enumerate(linestyles): #enumerate產生索引序列 plt.plot(X, C+x, linestyle=linestyle, color=color, linewidth=3) plt.show() #繪製圖表#plt.savefig(&quot;./linestyle.png&quot;,dpi=72) Marker 在線段上實際標出點，參考Line Style的補充資料 1234567891011121314151617#%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltcolor = &#x27;cornflowerblue&#x27;X = np.linspace(-np.pi, np.pi, 12, endpoint=True)C = np.cos(X)markers = [&#x27;o&#x27;, &#x27;v&#x27;, &#x27;^&#x27;, &#x27;&lt;&#x27;] #標出點的樣式for x, linestyle in enumerate(markers): #enumerate產生索引序列 plt.plot(X, C+x, marker=markers[x], color=color, linewidth=1) plt.show() #繪製圖表#plt.savefig(&quot;./marker.png&quot;,dpi=72) 不實際畫出線，而是描出點 1234567891011121314#%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltx = [1, 2, 3, 4]y = [1, 4, 9, 16]plt.plot(x, y,&#x27;ro&#x27;) #參數ro中r為red，o代表使用圓形標記繪製而不是用線繪製plt.ylabel(&#x27;y label&#x27;) #更改坐標軸標題plt.xlabel(&#x27;x label&#x27;)plt.show() #繪製圖表#plt.savefig(&quot;./marker2.png&quot;,dpi=72) Legend 區分出線段 matplotlib.pyplot.legend 1234567891011121314151617181920212223#%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltX = np.linspace(-np.pi, np.pi, 256, endpoint=True)C,S = np.cos(X), np.sin(X)plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r&#x27;$-\\pi$&#x27;, r&#x27;$-\\pi/2$&#x27;, r&#x27;$0$&#x27;, r&#x27;$+\\pi/2$&#x27;, r&#x27;$+\\pi$&#x27;])plt.yticks([-1, 0, +1], [r&#x27;$-1$&#x27;, r&#x27;$0$&#x27;, r&#x27;$+1$&#x27;]) # latex formatplt.plot(X,C, label=&#x27;cosine&#x27;) #label標記線段名稱plt.plot(X,S, color=&#x27;red&#x27;, linewidth=10, label=&#x27;sine&#x27;)#plt.legend(loc=&#x27;upper left&#x27;, frameon=True)# frameon 決定是否有外框、設定 loc=&#x27;best&#x27;，python會自動找到有空位的地方放legendplt.legend(loc=&#x27;best&#x27;, frameon=False) plt.show() #繪製圖表#plt.savefig(&quot;./legend.png&quot;,dpi=72) Figure 下次內容紀錄的是從bar chart開始的部分。","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"NLP自然語言處理","slug":"NLP自然語言處理","permalink":"https://qi-xiang.github.io/tags/NLP%E8%87%AA%E7%84%B6%E8%AA%9E%E8%A8%80%E8%99%95%E7%90%86/"}]},{"title":"2021/10/18 NLP Matplotlib(範例)","slug":"nlp20211018","date":"2021-10-24T16:02:46.000Z","updated":"2022-03-13T17:24:30.680Z","comments":true,"path":"2021/10/25/nlp20211018/","link":"","permalink":"https://qi-xiang.github.io/2021/10/25/nlp20211018/","excerpt":"","text":"Simple plot 12345678910111213141516171819%matplotlib inline #此行目的是為了畫在jupyter notebook裡#import 需要的套件import numpy as npimport matplotlib.pyplot as plt#在 -pi 和 pi 間，以等差數列的方式取256個點，endpoint=True(包含stop)X = np.linspace(-np.pi, np.pi, 256, endpoint=True)#print(X)C,S = np.cos(X), np.sin(X) #分別計算cos、sin值plt.plot(X,C) #使用plt.plot()繪圖並帶入x,y座標plt.plot(X,S)plt.title(&#x27;this is title&#x27;) #設定圖表標題plt.ylabel(&#x27;y label&#x27;) #設定y軸名稱plt.xlabel(&#x27;x label&#x27;) #設定x軸名稱plt.grid() #顯示網格#plt.show() #匯出圖表plt.savefig(&quot;./simple_plot.png&quot;,dpi=72) #將圖表存成檔案；dpi是解析度 要特別注意，plt.savefig()之前不能有plt.show()，不然存到的會是空白圖。 numpy.linspace(等差數列): 此陣列以等差數列的形式產生，指定個數 Figure 1234567891011121314151617181920%matplotlib inline #此行目的是為了畫在jupyter notebook裡#import必要套件import matplotlibimport numpy as npimport matplotlib.pyplot as plt#在 -pi 和 pi 間，以等差數列的方式取256個點，endpoint=True(包含stop)X = np.linspace(-np.pi, np.pi, 256, endpoint=True)C,S = np.cos(X), np.sin(X)#分別計算cos、sin值#要畫一張新的圖只要重新呼叫 plt.figure() 即可#以下分開繪製 cos、sin 的圖plt.figure()plt.plot(X,C) #使用plt.plot()繪圖並帶入x,y座標#重新繪製另一張圖plt.figure()plt.plot(X,S, color=&#x27;red&#x27;, linewidth=10) #將線段設為紅色，linewidth=10 用來調整線段寬度plt.show() #繪出兩個圖表 Subplot 畫子圖，將原來的一張圖分成數個子圖 subplot函數需要使用幾個參數(row,col,# of plot) 1234567891011121314151617181920212223#%matplotlib inline #此行目的是為了畫在jupyter notebook裡#import必要套件import matplotlibimport numpy as npimport matplotlib.pyplot as pltplt.figure(figsize=(6, 4)) #開始繪圖，指定 figsize# plt.subplot(n_rows, n_cols, plot_num)plt.subplot(2, 2, 1) #繪製子圖 plt.subplot(row,col,number of plot) 第一張圖plt.plot([0, 1], [0, 1]) #繪製從(0,0)到(1,1)的點plt.subplot(2,2,2) #第二張圖plt.plot([1, 1], [0, 2]) #以此類推plt.subplot(2,2,3) #...plt.plot([2, 1], [3, 3])plt.subplot(2,2,4) #...plt.plot([4, 1], [1, 4])#tight_layout automatically adjusts subplot params so that the subplot(s) fits in to the figure area.plt.tight_layout() #用於自動調整子圖參數以提供指定的填充 1234567891011121314151617181920212223%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltplt.figure(figsize=(6, 4))# plt.subplot(n_rows, n_cols, plot_num)plt.subplot(2, 1, 1)# figure splits into 2 rows, 1 col, plot to the 1st sub-figplt.plot([0, 1], [0, 1])plt.subplot(2,3,4)# figure splits into 2 rows, 3 col, plot to the 4th sub-figplt.plot([0, 1], [0, 2])plt.subplot(2,3,5)# figure splits into 2 rows, 3 col, plot to the 5th sub-figplt.plot([0, 1], [0, 3])plt.subplot(2,3,6)# figure splits into 2 rows, 3 col, plot to the 6th sub-figplt.plot([0, 1], [0, 4])plt.tight_layout() 要注意這個例題的圖表順序，因為第一張圖表佔據3個位置(1~3)，所以下面的圖表要以4、5、6來排列。 補充資料: Matplotlib讓資料視覺化！ NumPy基礎介紹 subplot和subplots绘制子图 Python Matplotlib.pyplot.tight_layout()用法及代碼示例","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"NLP自然語言處理","slug":"NLP自然語言處理","permalink":"https://qi-xiang.github.io/tags/NLP%E8%87%AA%E7%84%B6%E8%AA%9E%E8%A8%80%E8%99%95%E7%90%86/"}]},{"title":"Hexo 官方教學","slug":"hello-world","date":"2021-10-21T10:28:26.490Z","updated":"2022-03-08T15:37:14.777Z","comments":true,"path":"2021/10/21/hello-world/","link":"","permalink":"https://qi-xiang.github.io/2021/10/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[]},{"title":"JS30 全攻略 第30天","slug":"ironman2021D30","date":"2021-09-30T07:46:50.000Z","updated":"2022-03-13T17:24:05.342Z","comments":true,"path":"2021/09/30/ironman2021D30/","link":"","permalink":"https://qi-xiang.github.io/2021/09/30/ironman2021D30/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 最後一天要實作的內容是&quot;網頁版打地鼠&quot;。 解析程式碼 HTML 部分 &lt;h1&gt;是頁面的標題，旁邊的&lt;span class=&quot;score&quot;&gt;是打地鼠遊戲的記分板。 &lt;button&gt;在滑鼠點擊時，會呼叫startGame()方法，開始打地鼠遊戲。 &lt;div class=&quot;game&quot;&gt;是打地鼠遊戲的主體，內部有&lt;dvi class=&quot;hole&quot;&gt;共計六個洞，每個洞(.hole)都有一隻初始被隱藏的地鼠(&lt;div class=&quot;mole&quot;&gt;)。 1234567891011121314151617181920212223&lt;h1&gt;Whack-a-mole! &lt;span class=&quot;score&quot;&gt;0&lt;/span&gt;&lt;/h1&gt;&lt;button onClick=&quot;startGame()&quot;&gt;Start!&lt;/button&gt;&lt;div class=&quot;game&quot;&gt; &lt;div class=&quot;hole hole1&quot;&gt; &lt;div class=&quot;mole&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hole hole2&quot;&gt; &lt;div class=&quot;mole&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hole hole3&quot;&gt; &lt;div class=&quot;mole&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hole hole4&quot;&gt; &lt;div class=&quot;mole&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hole hole5&quot;&gt; &lt;div class=&quot;mole&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hole hole6&quot;&gt; &lt;div class=&quot;mole&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS 部分 初始每一隻地鼠(.mole)都是採用絕對定位(position:absolute)，然後將top指定為100%，把地鼠(.mole)隱藏起來。 在遊戲過程中，我們會為地洞(.hole)添加.up這個 CSS class 選擇器，讓地鼠探頭出來給我們打 XD。 12345678910.mole &#123; /*上略...*/ position: absolute; top: 100%; /*下略...*/&#125;.hole.up .mole &#123; top: 0;&#125; JS 部分 宣告常數holes取得所有的地洞(.hole)，資料型態是 NodeList。 宣告常數scoreBoard取得頁面中顯示的分數(.score)。 宣告常數mole取得所有的地鼠(.mole)，資料型態是 NodeList。 123const holes = document.querySelectorAll(&#x27;.hole&#x27;); //NodeListconst scoreBoard = document.querySelector(&#x27;.score&#x27;);const moles = document.querySelectorAll(&#x27;.mole&#x27;); 撰寫ranTime()幫我們決定地鼠出現的持續時間並給定參數min、max作為出現持續時間範圍的最小、最大值。 下面用Math.random()隨機產生一個介於0~1的數字，然後把它乘上(max-min)再加上min，最後用Math.round()四捨五入得到隨機的出現持續時間。 123function randTime(min,max)&#123; return Math.round(Math.random() * (max-min) + min);&#125; randomHole()幫我們隨機選擇地鼠出現的洞，為避免接連選到兩次一樣的洞，所以另外宣告變數lastHole，來幫我們記住上一次出現的洞。 在方法裡，首先要傳入所有洞穴(holes，NodeList)，接著一樣用Math.random()隨機產生0~1的數字並乘上holes的長度後，呼叫Math.floor()無條件捨去小數點，取得一個隨機的index放入常數idx中。 然後，宣告的常數hole就可以用這個idx，隨機取得holes中的一個洞穴。 為避免選到和上次一樣的洞穴，利用條件判斷hole是不是跟lastHole相同，如果相同就遞迴呼叫randomHole()，直至選到不同的洞為止。 在方法的最後，把這次的結果放到lastHole中，之後回傳被隨機選到的hole。 123456789101112let lastHole;function randomHole(holes)&#123; const idx = Math.floor(Math.random() * holes.length); const hole = holes[idx] if(hole === lastHole)&#123; console.log(&#x27;You got the same hole.&#x27;); return randomHole(holes); &#125; lastHole = hole; return hole;&#125; 宣告變數timeup作為遊戲是否已經結束的flag。 peep()是讓地鼠從洞穴探頭出來的關鍵!!! 在peep()的最一開始，宣告常數time並取得由randTime(200,1000)隨機產生的地鼠持續出現時間，接著宣告常數hole取得由randomHole(holes)隨機挑出的地洞。 隨機挑出的hole會被添加.up這個 class，目的是讓躲在洞中的地鼠探出頭來。 如果超過地鼠持續出現的時間，地鼠就應該要重新回到洞中。所以這邊使用setTimeout()，在經過地鼠出現持續時間time後，移除hole上的.up，讓地鼠順利回家。在遊戲未結束(timeup = false)且前一隻地鼠已經回家的狀態下，我們會重新呼叫peep()，讓下一隻地鼠探頭出來。 1234567891011let timeup = false;function peep()&#123; const time = randTime(200,1000); const hole = randomHole(holes); hole.classList.add(&#x27;up&#x27;); setTimeout(()=&gt;&#123; hole.classList.remove(&#x27;up&#x27;); if(!timeup) peep(); &#125;,time);&#125; 宣告變數score給定初始值0，用來幫我們算分數。 startGame()可以讓我們在點擊頁面上的button後，立即開始打地鼠遊戲。 在方法的一開始，先把記分板(scoreBoard)歸零，然後把代表結束遊戲與否的timeup設成flase，同時也把計算的分數(score)歸零。 上面都做完後，呼叫peep()讓地鼠開始探頭出來給我們打，接著利用setTimeout()訂定打地鼠遊戲的時間限制，這邊設定遊戲時間為15秒(15000毫秒)，15秒後把timeup設為true並提示使用者遊戲結束。 123456789101112let score = 0;function startGame()&#123; scoreBoard.textContent = 0; timeup = false; score = 0; peep(); setTimeout(()=&gt;&#123; timeup = true; alert(&quot;時間到，遊戲結束!!!&quot;); &#125; , 15000);&#125; 最後一部分要來處理的是&quot;當地鼠被點擊到，頁面上的得分要加1，然後地鼠要縮回洞中&quot;。 我們可以為每一隻地鼠(mole)註冊click event listener以bonk()作為event handler。 在bonk()裡，首先判斷點擊是不是&quot;人為&quot;的，如果是使用者點擊觸發，則e.isTrusted會回傳true，而如果是用像是script之類的去觸發click event，則會回傳false並直接停止往下執行方法。 接著，在每一次點擊成功後，把分數(score)加1並移除加到地鼠(mole)上的.up，讓地鼠回到洞中，之後更新頁面上的得分(scoreBoard)就完成了。 12345678function bonk(e)&#123; if(!e.isTrusted) return; //cheater score++; this.classList.remove(&#x27;up&#x27;); scoreBoard.textContent = score;&#125;moles.forEach(mole =&gt; mole.addEventListener(&#x27;click&#x27;,bonk)); 補充資料: Math.random() Math.round() Math.floor() setTimeout() Element.classList Node.textContent Event.isTrusted 範例網頁請點此 完整程式碼請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第29天","slug":"ironman2021D29","date":"2021-09-29T07:46:44.000Z","updated":"2022-03-13T17:24:03.124Z","comments":true,"path":"2021/09/29/ironman2021D29/","link":"","permalink":"https://qi-xiang.github.io/2021/09/29/ironman2021D29/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 製作網頁版的倒數計時器，透過點按網頁上的按鈕快速設定倒數計時器或是在輸入框內輸入要設定倒數的分鐘數。 在這裡順便說明什麼是Vanilla JS，Vanilla JS是一個快速、輕量化、跨平台的 JavaScript 框架。 解析程式碼 HTML 部分 .timer是倒數計時器的本體，以下又可分成兩大部分，.timer__controls是其下設置倒數計時器的控制列，.display是其下用來展示剩餘時間和倒數結束時間的容器。 此外，可以發現在每一個button元素上，都有設定data-time屬性，這個屬性用來幫我們快速地設置倒數計時器且單位是以秒計算。 #custom內部放置一個文字輸入框，在使用者輸入數字按下 enter 後，這個數字會被拿來設定倒數計時器並以分鐘作為單位。 .display__time-left用來放置正在倒數的時間(分:秒)。 display__end-time用來放置倒數結束的時間。 12345678910111213141516&lt;div class=&quot;timer&quot;&gt; &lt;div class=&quot;timer__controls&quot;&gt; &lt;button data-time=&quot;20&quot; class=&quot;timer__button&quot;&gt;20 Secs&lt;/button&gt; &lt;button data-time=&quot;300&quot; class=&quot;timer__button&quot;&gt;Work 5&lt;/button&gt; &lt;button data-time=&quot;900&quot; class=&quot;timer__button&quot;&gt;Quick 15&lt;/button&gt; &lt;button data-time=&quot;1200&quot; class=&quot;timer__button&quot;&gt;Snack 20&lt;/button&gt; &lt;button data-time=&quot;3600&quot; class=&quot;timer__button&quot;&gt;Lunch Break&lt;/button&gt; &lt;form name=&quot;customForm&quot; id=&quot;custom&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;minutes&quot; placeholder=&quot;Enter Minutes&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;display&quot;&gt; &lt;h1 class=&quot;display__time-left&quot;&gt;&lt;/h1&gt; &lt;p class=&quot;display__end-time&quot;&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; JS 部分 宣告變數countdown，待會用來指定成後面setInterval()的間隔代碼(Interval ID)。 宣告常數timeDisplay取得用來放置倒數時間的元素。 12let countdown;const timeDisplay = document.querySelector(&#x27;.display__time-left&#x27;); 在timer()裡首先要取得現在的時間(Date.now())，要注意這邊回傳的是以毫秒為單位的timestamp。 接著宣告then作為倒數計時結束的時間點，把要倒數的秒數乘上1000(換成毫秒)再加上現在的時間(毫秒)就完成了。 再接下來可以注意到在第五行，呼叫了displayTimeLeft()這個方法，這個方法用來幫我們把倒數中的時間放到.display__time-left還有網頁的標題裡面(方法的詳細內容在更下面)。 那為什麼在開始倒數之前，要先呼叫displayTimeLeft()呢? 因為用setInterval()倒數的話，它會有1秒的延遲時間，也就是說最一開始的那1秒是什麼都沒有的狀態，所以要呼叫displayTimeLeft()補上那1秒的空窗期。 然後就是用setInterval()開始倒數的部分啦~ 在這邊宣告常數secondsLeft放入經計算後的剩餘秒數，記得要除上1000，因為每一秒 then - Date.now() 的結果單位都是毫秒，最後用Math.round()四捨五入取最近的整數。 secondLeft小於0的時候，我們應該要立即停止倒數，這時候前面指定的 Interval ID 就派上用場啦~ 用clearInterval(countdown)就可以把倒數輕鬆移除。 12345678910111213141516function timer(seconds)&#123; const now = Date.now(); const then = now +seconds * 1000; //run immediately not run after 1 sec displayTimeLeft(seconds); countdown = setInterval(()=&gt;&#123; const secondsLeft = Math.round((then - Date.now())/1000); //display it if(secondsLeft &lt; 0)&#123; clearInterval(countdown); return; &#125; displayTimeLeft(secondsLeft); &#125;,1000)&#125; 在displayTimeLeft()，它會把拿到的剩餘秒數換算成分和秒，再放回到’.display__time-left’裡並同時修改網頁標題。 這邊要特別注意如果經換算後，秒數的部分不足10秒，則要透過條件判斷在前方補上0。(ex. 10:5 &gt;&gt;&gt; 10:05) 1234567function displayTimeLeft(seconds)&#123; const minutes = Math.floor(seconds/60); const reminderSeconds = seconds%60; const display = `$&#123;minutes&#125;:$&#123;reminderSeconds &lt; 10 ? &#x27;0&#x27; : &#x27;&#x27;&#125;$&#123;reminderSeconds&#125;`; document.title = display; timeDisplay.textContent = display;&#125; 宣告常數endTime取得放置倒數結束時間的元素，接下來就要用displayEndTime()來處理倒數結束的時間囉! 在displayEndTime()，他把傳入的timestamp(單位 : 毫秒)，用new Date(timestamp)建立成一個Date物件再放入常數end裡面。 接下來 Do Re Mi SO，把endTime(結束時間)，修改成自Date物件取得的小時、分鐘。特別注意遇到分鐘數不足10分鐘時，要利用條件判斷在數字前方補上0，例如: 21:5 &gt;&gt;&gt; 21:05。 12345678const endTime = document.querySelector(&#x27;.display__end-time&#x27;);/*中略....*/function displayEndTime(timestamp)&#123; const end = new Date(timestamp); const hour = end.getHours(); const minutes = end.getMinutes(); endTime.textContent = `Be Back At $&#123;hour&#125;:$&#123;minutes &lt; 10 ? &#x27;0&#x27; : &#x27;&#x27;&#125;$&#123;minutes&#125;`;&#125; new Date(timestamp)的一些操作如下圖 : (我一開始覺得怪怪的，為什麼getMonth()回傳的是8而不是9? 後來一查才發現0代表的是1月 XD) 下面把timer()倒數結束的時間(then，毫秒)，傳入displayEndTime()，修改頁面上的倒數結束時間。 12345function timer(seconds)&#123; /*上略...*/ displayEndTime(then); /*下略...*/&#125; 宣告常數buttons取得所有用來快速設定倒數計時器的按鈕。 然後為每個button都註冊click event listener以startTimer()作為event handler。 在startTimer()，宣告常數seconds取得被點擊按鈕上的data-time屬性值，接著把這個seconds丟入timer()，成功建立一個倒數計時器。 12345678const buttons = document.querySelectorAll(&#x27;[data-time]&#x27;);/*中略...*/function startTimer()&#123; const seconds = parseInt(this.dataset.time); timer(seconds);&#125;buttons.forEach(button =&gt; button.addEventListener(&#x27;click&#x27;,startTimer)); 如果這時候開始瘋狂點擊按鈕建立倒數計時器，你會發現網頁上的倒數時間開始&quot;抽搐&quot;，因為之前建立的倒數計時器仍在運作，造成網頁倒數時間的文字被頻繁地修改，然後不自然的&quot;抽搐&quot;就出現了。 所以我們需要在timer()的最上面加上clearInterval(countdown);這一行，在每一次設定倒數計時器的時候，把之前的倒數計時器通通清掉。 12345function timer(seconds)&#123; //clear any existing timer clearInterval(countdown); /*下略...*/&#125; 最後要來處理文字輸入框的部分，在form元素上註冊submit event listener以後面的function()作為event handler。 因為submit表單時會重新整理網頁，所以在第一行寫e.preventDefault()防止網頁重新整理。接著宣告常數mins承接來自&lt;input name=&quot;minutes&quot;&gt;的分鐘數(value)，然後再把分鐘數乘上60換成秒傳入timer()，成功設定倒數計時器。最後一行的this.reset()用來重置表單元素。 1234567document.customForm.addEventListener(&#x27;submit&#x27;,function(e)&#123; e.preventDefault(); const mins = this.minutes.value; console.log(mins); timer(mins * 60); this.reset();&#125;); 補充資料: Date.now() WindowOrWorkerGlobalScope.setInterval() clearInterval() Math.floor() Node.textContent Date.prototype.getHours() Date.prototype.getMinutes() HTMLElement.dataset 範例網頁 完整程式碼請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第28天","slug":"ironman2021D28","date":"2021-09-28T07:46:39.000Z","updated":"2022-03-13T17:24:00.454Z","comments":true,"path":"2021/09/28/ironman2021D28/","link":"","permalink":"https://qi-xiang.github.io/2021/09/28/ironman2021D28/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 除了原本在video元素自帶的影片控制器(設定controls屬性)，我們可以另外實作一個調節影片速度的控制介面，這個介面可以用拖拉的方式改變影片的播放速度。 解析程式碼 HTML 部分 div(.wrapper)是我們整個的影片播放器，下面可拆作兩部分，一個是 video(.flex)和自帶的預設控制介面(啟用controls)，另一個是我們這次要實作出的影片速度調節介面 div(.speed)。 123456&lt;div class=&quot;wrapper&quot;&gt; &lt;video class=&quot;flex&quot; width=&quot;765&quot; height=&quot;430&quot; src=&quot;http://clips.vorwaerts-gmbh.de/VfE_html5.mp4&quot; loop controls&gt;&lt;/video&gt; &lt;div class=&quot;speed&quot;&gt; &lt;div class=&quot;speed-bar&quot;&gt;1×&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; JS 部分 首先，取得所有需要的元素 : 宣告常數speed放入取得的速度調節介面(.speed)。 宣告常數bar放入取得的速度調節介面內部的子元素(.speed-bar)。 宣告常數video放入取得的video元素(.flex)。 123const speed = document.querySelector(&#x27;.speed&#x27;);const bar = document.querySelector(&#x27;.speed-bar&#x27;);const video =document.querySelector(&#x27;.flex&#x27;); 在speed註冊mousemove event listener監聽是否有滑鼠在speed上移動，有的話就用後方的function()作為event handler。 在event handler裡，我們要先取得的是滑鼠在內部移動時的 y 座標(e.pageY，相對整個 HTML 文件頂部而言)，又因為我們無法保證速度調節介面(.speed)是在 HTML 文件的最頂端而且沒有margin、padding之類的，所以還須把取得的 y 座標減去.speed離視窗(offsetParent)頂端的距離(offsetTop)進行修正。 宣告常數percent算出目前滑鼠所在的 y 座標位置，相對於整個速度調節介面高度(this.offsetHeight)的比例，作為後續調整.speed-bar的高度和.flex影片播放速度的依據。 宣告常數max、min作為調整影片播放速度時能達到的最大、最小倍率。 1234567speed.addEventListener(&#x27;mousemove&#x27;, function(e)&#123; //we can&#x27;t assume that speed is on the top const y = e.pageY - this.offsetTop; const percent = y / this.offsetHeight; const min = 0.4; const max = 4;&#125;); 宣告常數height，用Math.round(percent*100)+'%'，將剛剛算出的比例換成百分比的形式。 宣告常數playbackRate計算現在的比例(percent)換算成的速度倍率。 將.speed-bar的高度設為我們算出的高度百分比(height)，然後再把它的文字內容換成現在的速度倍率(ex. 1.2x)。toFixed()幫我們把算出的速度倍率(playbackRate)取到小數點後1位。 最後修改video的playbackRate屬性就完成了。 (播放速度太快或太慢均有可能導致影片部分聲音消失!!!) 12345678speed.addEventListener(&#x27;mousemove&#x27;, function(e)&#123; /*上略...*/ const height = Math.round(percent*100)+&#x27;%&#x27;; const playbackRate = percent * (max-min) + min; bar.style.height = height; bar.textContent = playbackRate.toFixed(1)+&#x27;x&#x27;; video.playbackRate = playbackRate;&#125;); 補充資料 : HTMLElement.offsetTop HTMLMediaElement.playbackRate HTMLElement.offsetHeight Number.prototype.toFixed() Math.round() 範例網頁請點此 觀看完整程式碼","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第27天","slug":"ironman2021D27","date":"2021-09-27T07:46:34.000Z","updated":"2022-03-13T17:23:55.362Z","comments":true,"path":"2021/09/27/ironman2021D27/","link":"","permalink":"https://qi-xiang.github.io/2021/09/27/ironman2021D27/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 實作出能夠按住滑鼠左右拖曳的水平捲軸。 解析程式碼 HTML 部分 捲軸(div.items)由內部的25個div.item共同組成。 123456789&lt;div class=&quot;items&quot;&gt; &lt;div class=&quot;item item1&quot;&gt;01&lt;/div&gt; &lt;div class=&quot;item item2&quot;&gt;02&lt;/div&gt; &lt;div class=&quot;item item3&quot;&gt;03&lt;/div&gt; &lt;!--中間省略...--&gt; &lt;div class=&quot;item item23&quot;&gt;23&lt;/div&gt; &lt;div class=&quot;item item24&quot;&gt;24&lt;/div&gt; &lt;div class=&quot;item item25&quot;&gt;25&lt;/div&gt;&lt;/div&gt; JS 部分 宣告常數slider取得捲軸(div.items)元素。 宣告變數isDown作為判斷滑鼠是否有被按住的 flag，給定預設值是 false。 宣告變數startX用來放入之後取得的移動起始點座標。 宣告變數scrollLeft用來取得div.items下方 scrollbar 的位置，最左方是 0。 1234const slider = document.querySelector(&#x27;.items&#x27;);let isDown = false; //flag variablelet startX;let scrollLeft; 當滑鼠被按住(mousedown) : 把isDown設為true。 當滑鼠離開 slider 的範圍(mouseleave) : 把isDown設為false，因為離開 slider 範圍不應再有拖拉的效果(不執行mousemove裡面的內容)。 當放開滑鼠(mouseup) : 把isDown設為false，因為mouseup代表已放開滑鼠。 當滑鼠在 slider 裡移動(mousemove) : 先判斷滑鼠是否被按住，若沒被按住(isDown = false)則直接跳出方法不往下執行。 123456789101112131415slider.addEventListener(&#x27;mousedown&#x27;, () =&gt; &#123; isDown = true;&#125;);slider.addEventListener(&#x27;mouseleave&#x27;, () =&gt; &#123; isDown = false;&#125;);slider.addEventListener(&#x27;mouseup&#x27;, () =&gt; &#123; isDown = false;&#125;);slider.addEventListener(&#x27;mousemove&#x27;, () =&gt; &#123; if(!isDown) return; //stop the function from running&#125;); 接下來在按住滑鼠時，在 slider 上添加.active這個 class，而在滑鼠離開 slider 範圍或放開滑鼠時，移除 slider 上的.active。 .active這個 CSS class 選擇器，用來設定拖拉捲軸時產生的效果，例如處於拖拉狀態，捲軸(.items)會比原來的大小略為放大一點。 event.preventDefault()用來取消DOM的預設功能，在這裡是避免被 browser 認為想要選取文字之類的。 12345678910111213141516171819slider.addEventListener(&#x27;mousedown&#x27;, () =&gt; &#123; isDown = true; slider.classList.add(&#x27;active&#x27;);&#125;);slider.addEventListener(&#x27;mouseleave&#x27;, () =&gt; &#123; isDown = false; slider.classList.remove(&#x27;active&#x27;);&#125;);slider.addEventListener(&#x27;mouseup&#x27;, () =&gt; &#123; isDown = false; slider.classList.remove(&#x27;active&#x27;);&#125;);slider.addEventListener(&#x27;mousemove&#x27;, () =&gt; &#123; if(!isDown) return; //stop the function from running e.preventDefault();&#125;); 在 slider 裡面按住滑鼠(mousedown)，首先要做的是取得滑鼠在整個 HTML 文件的座標(會隨著捲軸移動改變)，所以先呼叫e.pageX。那為什麼還要減去slider.offserLeft呢? 因為我們要取得的是在 slider 裡面的 x 座標，而 slider 剛好有左 margin，所以要減掉offsetLeft修正再放回startX(滑鼠在 slider 裡的 x 座標)。 宣告常數scrollLeft放入按住滑鼠時 slider 下方 scrollbar 的位置。 12345678slider.addEventListener(&#x27;mousedown&#x27;, (e) =&gt; &#123; //省略... //know where we click on the slider startX = e.pageX - slider.offsetLeft;// if the slider has the margin left then we should correct it scrollLeft = slider.scrollLeft; console.log(startX); console.log(scrollLeft);&#125;); 在mousemove event handler裡，宣告常數x不斷更新滑鼠在 slider 內移動的座標，跟上面一樣要把 e.pageX 減去 slider.offsetLeft 作 slider 有左 morgin 時的修正。 常數walk放入移動時的x座標減去起始點的x座標作為移動下方 scrollbar 的依據，把算出來的值乘上3是為了讓 scrollbar 移動的距離更加大、明顯。 最後，為了讓移動時更加順暢，把先前取得的 scrollLeft 減去 walk，指定捲軸移動的位置和距離大小，這裡一定要用減的，因為移動方向和算出來的值剛好差負號。 舉例來說按住滑鼠向左拉，此時的捲軸應該要往右(+)移動，但算出的 walk 會是負的，所以要再加上-號修正。 123456slider.addEventListener(&#x27;mousemove&#x27;, (e) =&gt; &#123; //省略... const x = e.pageX - slider.offsetLeft; const walk = (x - startX)*3; slider.scrollLeft = scrollLeft - walk;&#125;); 補充資料 : Element.scrollLeft HTMLElement.offsetLeft MouseEvent.pageX JS一秒區分clientX,offsetX,screenX,pageX之間關係 範例網頁請點此 完整程式碼請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第26天","slug":"ironman2021D26","date":"2021-09-26T07:42:42.000Z","updated":"2022-03-13T17:23:53.355Z","comments":true,"path":"2021/09/26/ironman2021D26/","link":"","permalink":"https://qi-xiang.github.io/2021/09/26/ironman2021D26/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 今天我們要實作的內容是當使用者hover in 或 out 導覽列時，展開顯示下方的連結、文字內容並搭配上 CSS 的動畫效果。 解析程式碼 HTML 部分 &lt;h2&gt;&lt;/h2&gt;用來模擬&lt;nav&gt;&lt;/nav&gt;不是 HTML 最上面元素的情況。 &lt;nav&gt;&lt;/nav&gt;(.top)是我們的導覽列，其中包含作項目內容背景用途的&lt;div&gt;&lt;/dvi&gt;(.dropDownBackground)，以及項目列表&lt;ul&gt;&lt;/ul&gt;(.cool)和項目內容&lt;li&gt;&lt;/li&gt;，其中每一個項目的內容除了&lt;a&gt;&lt;/a&gt;標題連結有顯示外，剩餘資訊.dropdown的部分都被預設隱藏。 123456789101112131415161718192021222324252627&lt;h2&gt;Cool&lt;/h2&gt;&lt;nav class=&quot;top&quot;&gt; &lt;div class=&quot;dropdownBackground&quot;&gt; &lt;span class=&quot;arrow&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;ul class=&quot;cool&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;About Me&lt;/a&gt; &lt;div class=&quot;dropdown dropdown1&quot;&gt; &lt;!--省略--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Courses&lt;/a&gt; &lt;ul class=&quot;dropdown courses&quot;&gt; &lt;!--省略--&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Other Links&lt;/a&gt; &lt;ul class=&quot;dropdown dropdown3&quot;&gt; &lt;!--省略--&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; CSS 部分 .dropdown : 分別設定opacity: 0;、display: none;預設隱藏.dropdown，然後用transition監控 CSS 屬性值的變化，達成 CSS 動畫的效果。 .trigger-enter .dropdown : .trigger-enter 這個 class 會在 hover in 任意一個&lt;li&gt;&lt;/li&gt;時，被加到.dropdown上。設定display:block;把隱藏的項目資訊 show 出來，但現在還是透明的。 .trigger-enter-active .dropdown : .trigger-enter-active 這個 class 會在 hover in 任意一個&lt;li&gt;&lt;/li&gt;時，被加到.dropdown上。設定opacity:1;把隱藏的項目資訊 show 出來，現在是不透明的。 為什麼要把opacity、display分開寫而不寫在同一個 class 選擇器呢? 因為寫在一起的話，transition的動畫效果會失效。 12345678910111213141516.dropdown &#123; /*省略...*/ opacity: 0; /*省略...*/ transition: all 0.5s; /*省略...*/ display: none; &#125;.trigger-enter .dropdown &#123; display: block;&#125;.trigger-enter-active .dropdown &#123; opacity: 1; /*display和opacity分開寫是為了CSS動畫效果*/&#125; .dropdownBackground : 初始項目內容的背景被隱藏(透明)。 .dropdownBackground.open : 讓項目內容的背景被顯示出來(不透明)。而.open 這個 class 會在 hover in 任意一個&lt;li&gt;&lt;/li&gt;時，被加到.dropdownBackground上。 12345678.dropdownBackground &#123; /*省略...*/ opacity:0;&#125;.dropdownBackground.open &#123; /*show the background*/ opacity: 1;&#125; JS 部分 首先取得所有必要的網頁元素，包括項目列表下的每個&lt;li&gt;、作為列表項目內容背景的.dropdownBackground以及導覽列.top。 123const triggers = document.querySelectorAll(&#x27;.cool &gt; li&#x27;);const background = document.querySelector(&#x27;.dropdownBackground&#x27;);const nav = document.querySelector(&#x27;.top&#x27;); 為項目列表中的每個&lt;li&gt;都分別註冊mouseenter event listener(hover in 觸發)和mouseleave event listener(hover out 觸發)，然後各自以handleEnter()和handleLeave作事件處理。 1234567891011//listen for hovering in and outfunction handleEnter()&#123;&#125;function handleLeave()&#123; &#125;triggers.forEach(trigger =&gt; trigger.addEventListener(&#x27;mouseenter&#x27;,handleEnter));triggers.forEach(trigger =&gt; trigger.addEventListener(&#x27;mouseleave&#x27;,handleLeave)); hover in &lt;li&gt;時，將trigger-enter加到&lt;li&gt;上。 然後利用setTimeout()讓在&lt;li&gt;加上trigger-enter-active這件事被延遲150毫秒，利用條件判斷只有當&lt;li&gt;上已經有.trigger-enter這個 class，才執行後方的在&lt;li&gt;加上.trigger-enter-active，會需要做到這樣是為避免使用者 hover in and out 的時間過快，讓一個項目的內容還沒來得及消失，另一個卻馬上出現，造成殘影的效果。 最後，在項目內容背景加上.open這個 class 讓它被 show 出來。 12345678function handleEnter()&#123; this.classList.add(&#x27;trigger-enter&#x27;); //use the arrow function or &#x27;this&#x27; will be the window //不要讓內容太早被show出來，不然可能會出現殘影 setTimeout(()=&gt; this.classList.contains(&#x27;trigger-enter&#x27;) &amp;&amp; this.classList.add(&#x27;trigger-enter-active&#x27;),150); //set background background.classList.add(&#x27;open&#x27;);&#125; handleLeave()要做的事情很簡單，就是當使用者 hover out 時，移除所有被新增的 class。 12345function handleLeave()&#123; this.classList.remove(&#x27;trigger-enter&#x27;,&#x27;trigger-enter-active&#x27;); //set background background.classList.remove(&#x27;open&#x27;);&#125; 最後的最後，我們要把項目內容的背景移到它該待的地方。 首先取得項目內容的元素然後再取得項目內容相對視窗右上角的座標(這個座標不隨著 scroll down 而有所改變)。 複習一下getBoundingClientRect()取得的元素座標圖 : 那為什麼我們還需要取得導覽列nav的座標呢? 因為在 nav 不是 HTML 文件裡的第一個元素時，如果只單單用.dropdown的left、top進行項目內容背景的位置設定，會發現到背景被稍微往下擠了一點，被往下擠的大小剛好可以用導覽列nav的位置來作修正，分別將指定的left、top減去nav的left、top就好。 我們將大小、位置等等資訊整合在物件coords裡，之後再個別利用coords裡的指定值去修改項目內容背景的 CSS 屬性就完成了。 12345678910111213141516171819function handleEnter()&#123; // 上略... // set position of the background const dropDown = this.querySelector(&#x27;.dropdown&#x27;); const dropDownCoords = dropDown.getBoundingClientRect(); const navCoords = nav.getBoundingClientRect(); console.log(dropDownCoords); const coords = &#123; height: dropDownCoords.height, width: dropDownCoords.width, top: dropDownCoords.top - navCoords.top, left: dropDownCoords.left - navCoords.left &#125; background.style.setProperty(&#x27;width&#x27;,`$&#123;coords.width&#125;px`); background.style.setProperty(&#x27;height&#x27;,`$&#123;coords.height&#125;px`); background.style.setProperty(&#x27;transform&#x27;,`translate($&#123;coords.left&#125;px,$&#123;coords.top&#125;px)`);&#125; 補充資料 : mouseenter mouseleave Element.getBoundingClientRect() CSSStyleDeclaration.setProperty() 範例網頁請點此 完整程式碼","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第25天","slug":"ironman2021D25","date":"2021-09-25T07:42:38.000Z","updated":"2022-03-13T17:23:50.389Z","comments":true,"path":"2021/09/25/ironman2021D25/","link":"","permalink":"https://qi-xiang.github.io/2021/09/25/ironman2021D25/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 瞭解addEventListener中事件的捕捉、傳遞(Event Bubbling/Capturing)以及一次性的事件監聽(Once)。 解析程式碼 HTML 部分 建立三層的div做為測試event listener的物件。 div(.one) : 淡紫色 div(.two) : 淡粉色 div(.three) : 橘色 123456&lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;two&quot;&gt; &lt;div class=&quot;three&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; JS 部分 Event Bubbling 首先取得所有的div標籤，然後在每個div上都註冊cllick event listener並以logText()進行事件處理把div標籤的class屬性值印出來。 1234567const divs = document.querySelectorAll(&#x27;div&#x27;);function logText(e)&#123; console.log(this.classList.value);&#125;divs.forEach(div =&gt; div.addEventListener(&#x27;click&#x27;,logText)); 點擊最內層的div(橘色)，console 印出的內容如下 : 由上面的結果，我們可以得知在 div(.three)捕捉到事件後，還會連帶向上觸發parents的event handler，這種由底部向上傳遞觸發event handler的機制稱為event bubbling。 傳遞順序 : div.three(橘色) -&gt; div.two(淡粉色) -&gt; div.one(淡紫色) Event Capturing 前面的Event Bubbling是從觸發事件的element開始向外層的parent element進行事件傳遞，而Event Capturing則是從觸發事件的element的最外層parent element向內進行傳遞。 要做到這一點，我們就必須使用到addEvenListener的第三個參數Options Object的capture屬性，這個屬性的預設值是false，我們只需要把它改成true即可。 1234/*上略...*/divs.forEach(div =&gt; div.addEventListener(&#x27;click&#x27;,logText,&#123; capture: true&#125;)); 設定完後點擊div.three，console 印出結果如下 : 傳遞順序 : div.one(淡紫色) -&gt; div.two(淡粉色) -&gt; div.three(橘色) capture : true，Event Capturing。 capture : false，Event Bubbling。 上方的Event Bubbling其實可被改寫如下 : 1234/*上略...*/divs.forEach(div =&gt; div.addEventListener(&#x27;click&#x27;,logText,&#123; capture: false //預設就是 false 可直接省略&#125;)); Event Propagation 那如果不想讓事件由內向外(bubbling)或由外向內(capturing)傳遞要怎麼辦呢? 我們可以在event handler裡面對Event呼叫stopPropagation()，讓事件不再繼續傳遞。 以阻止Event Bubbling為例，在event handler裡面，我們對event(e)呼叫stopPropagation()。 123456789/*上略...*/function logText(e)&#123; console.log(this.classList.value); e.stopPropagation(); //stop bubbling or capturing&#125;divs.forEach(div =&gt; div.addEventListener(&#x27;click&#x27;,logText,&#123; capture: false&#125;)); 然後點擊div.three，console 印出結果如下 : 由上可知呼叫stopPropagation()後，事件就沒有繼續傳遞。 Event Once addEvenListener的第三個參數Options Object的屬性除了capture之外，還有once這個屬性(預設是false)，它可以用來指定是否在觸發一次事件處理後，就unbind event listener(讓事件監聽器失效)。 下面以按鈕作為例子 : 在網頁上放置一個button。 1&lt;button&gt;Button&lt;/button&gt; 透過 JS 取得button標籤，然後為其註冊click event listener並指定Options Object的once屬性為 true。 12345const button = document.querySelector(&#x27;button&#x27;);const text = &#x27;努力は自分に裏切らない、梦想は裏切ります！努力は梦を実现することはできない！しかし、努力している事実は自分を慰めることができる。--大先生&#x27;button.addEventListener(&#x27;click&#x27;,() =&gt; alert(text),&#123; once: true&#125;); 此時點擊button，視窗會顯示提示訊息，但若在未 reload 頁面的情況下二次點擊button，會發現視窗不再顯示提示訊息，也就是button失效了。 這個效果可以放在提交表單的按鈕上，用來防止使用者重複提交表單。 補充資料 : EventTarget.addEventListener() Event.stopPropagation() [教學] 瀏覽器事件：Event Bubbling, Event Capturing 及 Event Delegation 點擊檢視完整程式碼(Wes Bos)","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第24天","slug":"ironman2021D24","date":"2021-09-24T07:41:19.000Z","updated":"2022-03-13T17:23:33.884Z","comments":true,"path":"2021/09/24/ironman2021D24/","link":"","permalink":"https://qi-xiang.github.io/2021/09/24/ironman2021D24/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 今天我們要做的是置頂導覽列，當使用者拉下捲軸而視窗頂部碰到導覽列頂部時，若往後繼續下拉捲軸則將導覽列始終固定在最上方。 解析程式碼 HTML 部分 header是網頁上方的標題。 #main是網頁的導覽列，包含.logo(初始隱藏)還有其他五個項目。 .site-wrap放的是一大堆假文還有圖片。 123456789101112131415161718&lt;header&gt; &lt;h1&gt;A story about getting lost.&lt;/h1&gt;&lt;/header&gt;&lt;nav id=&quot;main&quot;&gt; &lt;ul&gt; &lt;li class=&quot;logo&quot;&gt;&lt;a href=&quot;#&quot;&gt;LOST.&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Images&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Locations&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Maps&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt;&lt;div class=&quot;site-wrap&quot;&gt; &lt;!--以下是假文還有圖片，為不佔空間所以省略--&gt;&lt;/div&gt; JS 部分 宣告常數nav取得網頁導覽列。 宣告常數topOfNav取得導覽列頂部離視窗最上方的距離。 12const nav = document.querySelector(&#x27;#main&#x27;);const topOfNav = nav.offsetTop; 我們置頂導覽列的機制主要是透過觀測捲軸的&quot;捲動量&quot;來決定是否置頂捲軸。為此首先要在window註冊scroll event listener在捲軸捲動時不斷觸發，然後用fixNav()進行事件處理。 在fixedNav()裡面，我們可以判斷現在視窗的 y 方向捲動量(window.scrollY)是否超過導覽列的頂部(topOfNav)，如果超過的話就在body上添加fixed-nav這個 class，反之若沒有超過則移除fixed-nav。 那為什麼我們還要特別設定body的padding-top呢? 因為在導覽列(#main)的 CSS 設定中，我們使用了position: fixed;，這樣就會造成導覽列(#main)原本佔的空間突然空出來，之後下方的.site-wrap看上面還有空間就會擠上來，但擠上來的速度過快，因此在視覺上就會出現詭異的彈跳。 為避免這種狀況發生，我們可以在置頂導覽列的同時，指定body的padding-top: nav.ofsetHeight;，讓原本導覽列佔有的空間，被padding-top補上。不置頂導覽列的同時，理所當然我們就要將body的padding-top改回 0。 123456789101112function fixNav()&#123; console.log(topOfNav,window.scrollY); if(window.scrollY &gt;= topOfNav)&#123; document.body.style.paddingTop = nav.offsetHeight + &#x27;px&#x27;; document.body.classList.add(&#x27;fixed-nav&#x27;); &#125;else&#123; document.body.style.paddingTop = 0; document.body.classList.remove(&#x27;fixed-nav&#x27;); &#125;&#125;window.addEventListener(&#x27;scroll&#x27;,fixNav); CSS 部分 下面是在body上有.fixed-nav這個 class 時的特殊設定。 設定導覽列position: fixed，在預設上是固定在left: 0;、top: 0;的位置(視窗左上角)，然後加上一點陰影。 1234.fixed-nav nav&#123; position: fixed; box-shadow: 0 5px rgba(0,0,0,0.1);&#125; 把原本在導覽列隱藏的logo顯示出來，設定max-width(最大寬度)為500px，這裡原本也可以用width: 500px;就好，但是設定width會讓transition產生的動畫效果失效。 123.fixed-nav li.logo&#123; max-width: 500px; /*use width can&#x27;t show animation effect*/&#125; 在置頂導覽列的同時，把下方的文章區塊略為放大。 123.fixed-nav .site-wrap&#123; transform: scale(1);&#125; 補充資料: HTMLElement.offsetTop HTMLElement.offsetHeight Element.classList CSS Transform Element: scroll event Window.scrollY 範例網頁請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第23天","slug":"ironman2021D23","date":"2021-09-23T07:29:15.000Z","updated":"2022-03-13T17:23:31.614Z","comments":true,"path":"2021/09/23/ironman2021D23/","link":"","permalink":"https://qi-xiang.github.io/2021/09/23/ironman2021D23/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 還記得在 Day 20 - Native Speech Recognition，我們使用了 Web Speech API 中語音識別(Speech recognition)的部分，而這次我們要使用的是語音合成(Speech synthesis)的部分。 這次的主角是Web Speech API的SpeechSynthesis、SpeechSynthesisUtterance。 在下面的範例，我們會利用 API 語音合成功能，讓網頁用不同的聲音讀出textarea裡面的文字。 解析程式碼 HTML 部分 select(#voices)是一個用來選擇要用什麼聲音讀出文字的選單。 input([name=&quot;rate&quot;]) 是用來調整讀字的速度。 input([name=&quot;rate&quot;]) 是用來調整讀字音高。 textarea([name=&quot;text&quot;]) 是要讀的文字。 button(#stop) 是停止讀的按鈕。 button(#speak) 是開始讀的按鈕。 12345678910111213141516171819&lt;div class=&quot;voiceinator&quot;&gt; &lt;h1&gt;The Voiceinator 5000&lt;/h1&gt; &lt;select name=&quot;voice&quot; id=&quot;voices&quot;&gt; &lt;option value=&quot;&quot;&gt;Select A Voice&lt;/option&gt; &lt;/select&gt; &lt;label for=&quot;rate&quot;&gt;Rate:&lt;/label&gt; &lt;input name=&quot;rate&quot; type=&quot;range&quot; min=&quot;0&quot; max=&quot;3&quot; value=&quot;1&quot; step=&quot;0.1&quot;&gt; &lt;label for=&quot;pitch&quot;&gt;Pitch:&lt;/label&gt; &lt;input name=&quot;pitch&quot; type=&quot;range&quot; min=&quot;0&quot; max=&quot;2&quot; step=&quot;0.1&quot;&gt; &lt;textarea name=&quot;text&quot;&gt;Hello! I love JavaScript 👍&lt;/textarea&gt; &lt;button id=&quot;stop&quot;&gt;Stop!&lt;/button&gt; &lt;button id=&quot;speak&quot;&gt;Speak&lt;/button&gt;&lt;/div&gt; JS 部分 宣告常數 msg 並建立一個SpeechSynthesisUtterance物件，這個物件主要包含兩種資訊，一個是要讀出的內容(what to read)，另一個是要如何讀它(how to read)。 宣告空陣列 voices，之後我們會放入由SpeechSynthesis.getVoices()取得的聲音種類陣列。 後面的四個常數分別取得聲音種類選單、調整速度/音高的滑動桿、開始讀出文字按鈕、停止讀出文字按鈕。 123456const msg = new SpeechSynthesisUtterance(); //come from WEB Speech APIlet voices = [];const voicesDropdown = document.querySelector(&#x27;[name=&quot;voice&quot;]&#x27;);const options = document.querySelectorAll(&#x27;[type=&quot;range&quot;], [name=&quot;text&quot;]&#x27;);const speakButton = document.querySelector(&#x27;#speak&#x27;);const stopButton = document.querySelector(&#x27;#stop&#x27;); text是SpeechSynthesisUtterance的一個屬性，用來指定要讀出的內容，下面我們指定要讀出的內容是textarea的文字。 1msg.text = document.querySelector(&#x27;[name=&quot;text&quot;]&#x27;).value; 接下來我們需要取得網頁支援的聲音種類並把它們做成選項放到選單裡面。 在做選單前，我們還要確保真的有拿到聲音種類的陣列，所以在speechSynthesis註冊voiceschanged event listener以populateVoices()作為事件處理函式。 在populateVoices()裡，我們首先將取得的聲音陣列放到voices裡面，在 console 印出陣列內容的話，可以發現陣列中的元素都是SpeechSynthesisVoice物件，這個物件擁有該種聲音的名稱、語言等等的屬性。 然後我們可以把 voices 陣列進行 map，把每種聲音都做成選項，因為 map 結束是一個陣列，還要加上join()讓它變成 HTML 格式的大字串，之後才能放入voicesDropdown當作選項。 123456789function populateVoices()&#123; voices = this.getVoices(); console.log(voices); voicesDropdown.innerHTML = voices .map(voice =&gt; `&lt;option value=&quot;$&#123;voice.name&#125;&quot;&gt;$&#123;voice.name&#125; ($&#123;voice.lang&#125;)&lt;/option&gt;`) .join(&#x27;&#x27;);&#125; speechSynthesis.addEventListener(&#x27;voiceschanged&#x27;,populateVoices); voices陣列的內容 : toggle()用來開始讀出文字或停止讀出文字，我們預設參數startOver = true表示在正常情況下都要開始讀文字。方法最上面寫speechSynthesis.cancel();的功能是停止讀文字，因為希望每一次讀都是重新開始讀。 123456function toggle(startOver = true)&#123; speechSynthesis.cancel(); // stop speaking if(startOver)&#123; speechSynthesis.speak(msg); // restart speaking &#125;&#125; 在選單(voiceDropdown)註冊change event listener，用來把讀文字的聲音種類，改成我們選擇的那種。 事件處理函式setVoice()，用來調整讀文字時的聲音種類。前面有說過SpeechSynthesisUtterance可以決定 how to read，所以它有一個voice屬性可以指定聲音種類。 要注意的是我們指定的聲音種類要是一個SpeechSynthesisVoice物件而不是給它聲音的名稱就好，所以還要在voices陣列尋找擁有和選項的value一樣聲音名稱(name)的SpeechSynthesisVoice物件。 在方法最後呼叫toggle()，就可以發現隨著每一次選的選項不同，它會重新讀一次文字。 1234567function setVoice()&#123; console.log(&#x27;changing voice&#x27;); msg.voice = voices.find(voice =&gt; voice.name === this.value); toggle();&#125;voicesDropdown.addEventListener(&#x27;change&#x27;, setVoice); 倒數第二個要處理的是讀文字時的速度和音高調整，因為SpeechSynthesisUtterance本身有pitch和rate屬性可供修改，所以我們只要拿設定好的&lt;input&gt;的 name 和 value 來修改SpeechSynthesisUtterance對應的屬性值就好。 在兩個&lt;input&gt;上都註冊change event listener，可以讓每一次滑桿值有改變時，就重新指定聲音屬性並重新開始讀文字(別忘記在setOption()的最後放入toggle())。 1234567function setOption()&#123; console.log(this.name,this.value); msg[this.name] = this.value; toggle();&#125;options.forEach(option =&gt; option.addEventListener(&#x27;change&#x27;,setOption)) 最後就是關於開始和停止讀文字鈕的部分啦~ 開始讀文字的按鈕比較簡單，只要註冊click event listener然用toggle()處理就好。 認真要說的話，停止讀文字的按鈕也沒有難到哪裡，只是這邊我們不能直接用... , toggle(false)，而是要寫... , ()=&gt;toggle(false)才會有停止讀文字的效果。 12speakButton.addEventListener(&#x27;click&#x27;,toggle);stopButton.addEventListener(&#x27;click&#x27;,() =&gt; toggle(false)); 補充資料: Web Speech API SpeechSynthesis SpeechSynthesisUtterance SpeechSynthesisVoice 範例網頁請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第22天","slug":"ironman2021D22","date":"2021-09-22T07:29:10.000Z","updated":"2022-03-13T17:23:29.121Z","comments":true,"path":"2021/09/22/ironman2021D22/","link":"","permalink":"https://qi-xiang.github.io/2021/09/22/ironman2021D22/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 當滑鼠移入&lt;a&gt;所代表的連結時，快速移動一個白框，產生文字背景為白底的聚光燈效果。 解析程式碼 HTML 部分 總共分成兩個部分，一個是上方的導覽列(.menu)，另一個是放置眾多文字段落和連結的容器(.wrapper)。 1234567891011121314151617&lt;nav&gt; &lt;ul class=&quot;menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Order Status&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Tweets&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Read Our History&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Contact Us&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt;&lt;div class=&quot;wrapper&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, &lt;a href=&quot;&quot;&gt;consectetur&lt;/a&gt; adipisicing elit. Est &lt;a href=&quot;&quot;&gt;explicabo&lt;/a&gt; unde natus necessitatibus esse obcaecati distinctio, aut itaque, qui vitae!&lt;/p&gt; &lt;p&gt;Aspernatur sapiente quae sint &lt;a href=&quot;&quot;&gt;soluta&lt;/a&gt; modi, atque praesentium laborum pariatur earum &lt;a href=&quot;&quot;&gt;quaerat&lt;/a&gt; cupiditate consequuntur facilis ullam dignissimos, aperiam quam veniam.&lt;/p&gt; &lt;p&gt;Cum ipsam quod, incidunt sit ex &lt;a href=&quot;&quot;&gt;tempore&lt;/a&gt; placeat maxime &lt;a href=&quot;&quot;&gt;corrupti&lt;/a&gt; possimus &lt;a href=&quot;&quot;&gt;veritatis&lt;/a&gt; ipsum fugit recusandae est doloremque? Hic, &lt;a href=&quot;&quot;&gt;quibusdam&lt;/a&gt;, nulla.&lt;/p&gt; &lt;p&gt;Esse quibusdam, ad, ducimus cupiditate &lt;a href=&quot;&quot;&gt;nulla&lt;/a&gt;, quae magni odit &lt;a href=&quot;&quot;&gt;totam&lt;/a&gt; ut consequatur eveniet sunt quam provident sapiente dicta neque quod.&lt;/p&gt; &lt;p&gt;Aliquam &lt;a href=&quot;&quot;&gt;dicta&lt;/a&gt; sequi culpa fugiat &lt;a href=&quot;&quot;&gt;consequuntur&lt;/a&gt; pariatur optio ad minima, maxime &lt;a href=&quot;&quot;&gt;odio&lt;/a&gt;, distinctio magni impedit tempore enim repellendus &lt;a href=&quot;&quot;&gt;repudiandae&lt;/a&gt; quas!&lt;/p&gt;&lt;/div&gt; 在這邊先破梗一下，類似聚光燈的白底效果，其實是靠在文件上新增一個&lt;span&gt;來達成。 CSS 部分 這次的 CSS 很重要，需要稍微說明一下。 .highlight 這個 class 選擇器，是要用來加到前面說的那個&lt;span&gt;上面。 在滑鼠移動到&lt;a&gt;元素上面的時候，我們會利用 JS 取得&lt;a&gt;元素的寬、高，還有元素離視窗上方(top)、左方的距離(left)，讓&lt;span&gt;的寬、高和目前所在的&lt;a&gt;元素一致且因為設定&lt;span&gt;的position: absolute;，可以利用取得的top、left，令&lt;span&gt;和&lt;a&gt;貼在一起。 為避免&lt;span&gt;貼到和&lt;a&gt;同一個位置造成覆蓋，我們把z-index設為-1，讓&lt;a&gt;在上層而&lt;span&gt;在下層，最後設定background: white;，就會發現到&lt;span&gt;完全變成&lt;a&gt;的背景了呢~ 123456789101112.highlight &#123; transition: all 0.2s; border-bottom: 2px solid white; position: absolute; top: 0; background: white; left: 0; z-index: -1; border-radius: 20px; display: block; box-shadow: 0 0 10px rgba(0,0,0,0.2);&#125; JS 部分 宣告常數triggerts用來放置所有取得的&lt;a&gt;元素(NodeList)。 宣告常數highlight用來放置我們建立的&lt;span&gt;元素。 12const triggers = document.querySelectorAll(&#x27;a&#x27;);const highlight = document.createElement(&#x27;span&#x27;); 把.highlight這個 CSS class 選擇器套用到新建的&lt;span&gt;元素，然後將其加入到body裡面 12highlight.classList.add(&#x27;highlight&#x27;);document.body.append(highlight); 我們希望在移入&lt;a&gt;時觸發事件處理函式highlightlink()，所以利用forEach()在每個&lt;a&gt;上註冊mouseenter event listener。 123function highlightLink()&#123;&#125;triggers.forEach(trigger =&gt; trigger.addEventListener(&#x27;mouseenter&#x27;,highlightLink)); 在事件處理函式highlightLink()裡，我們首先要做的就是取得先前提到滑鼠移入的那個&lt;a&gt;標籤的寬、高和它離視窗上方(top)、左方(left)的距離。 1234function highlightLink()&#123; const linkCoords = this.getBoundingClientRect(); console.log(linkCoords);&#125; Element.getBoundingClientRect() : 這個方法會回傳一個DOMRect物件，DOMRect本身是一個可以包住該元素的最小方形(包含padding、borderWidth)，而從這個物件可以得知呼叫元素的width、height、left、top、bottom等等…。 接下來，我們依序指定&lt;span&gt;元素的寬高和位置，讓它的寬高和位置與滑鼠移入的&lt;a&gt;相同。(一定要記得加上單位喔!) 1234567function highlightLink()&#123; /*上略...*/ highlight.style.width = `$&#123;linkCoords.width&#125;px`; highlight.style.height = `$&#123;linkCoords.height&#125;px`; highlight.style.top = `$&#123;linkCoords.top&#125;px`; highlight.style.left = `$&#123;linkCoords.left&#125;px`; &#125; 嗯，看起來還蠻正常的落在soluta。 (捲軸往下拉) 滑鼠一樣移到soluta，但&lt;span&gt;卻浮在更上面的位置。 會有這樣的問題出現是因為DOMRect始終是以初始視窗的左上角計算元素的top和left，當我們把捲軸往下拉，它的位置沒有加上捲軸的移動量，自然就會出現在較上方的位置。 下面我們對left、top進行修正，分別加上x和y方向的捲軸移動量，這樣就完成了。 1234567function highlightLink()&#123; /*上略...*/ highlight.style.width = `$&#123;linkCoords.width&#125;px`; highlight.style.height = `$&#123;linkCoords.height&#125;px`; highlight.style.top = `$&#123;linkCoords.top + window.scrollY&#125;px`; highlight.style.left = `$&#123;linkCoords.left + window.scrollX&#125;px`;&#125; 當然我們也可以把這些屬性值都寫到一個物件裡，再個別呼叫物件屬性。 123456789101112131415function highlightLink()&#123; /*上略...*/ const coords = &#123; width: linkCoords.width, height: linkCoords.height, top: linkCoords.top + window.scrollY, left: linkCoords.left + window.scrollX &#125; highlight.style.width = `$&#123;coords.width&#125;px`; highlight.style.height = `$&#123;coords.height&#125;px`; highlight.style.top = `$&#123;coords.top&#125;px`; highlight.style.left = `$&#123;coords.left&#125;px`; &#125; 補充資料: Element.getBoundingClientRect() DOMRect 今天的內容也相對簡單，相信大家都可以輕鬆愉快的學習~ 範例網頁請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第21天","slug":"ironman2021D21","date":"2021-09-21T07:29:06.000Z","updated":"2022-03-13T17:23:27.133Z","comments":true,"path":"2021/09/21/ironman2021D21/","link":"","permalink":"https://qi-xiang.github.io/2021/09/21/ironman2021D21/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 取得使用者的位置資訊，實作出簡易的羅盤和速度表。 設定本地伺服器 這次的範例會需要取得位置的存取權限，而在取得過程必須是透過https或是localhost這類的secure origin才行，以下我們透過npm install和npm start架起自己的 little server (localhost)。 如果發現下面的指令無效的話，表示沒有安裝Node.js，可以點這邊下載 LTS 的版本，都用預設的安裝就好。 第一步 : 先移動到編輯檔案的工作目錄，接著輸入npm install，它會幫你安裝一些套件 第二步 : 輸入npm start，它會去執行package.json裡的start，開始運行一個 little server。(紅色框是目前的網頁位置) 這次不用 VisualStudio 的 Go Live Server，是因為它沒有提供 external server url，也讓行動裝置沒辦法直接用來測試。 解析程式碼 HTML 部分 總體而言只有兩個重點，一個是羅盤的 svg(.arrow) 圖，另一個是速度表(.speed)。 1234567&lt;svg class=&quot;arrow&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; version=&quot;1.1&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewBox=&quot;0 0 64 64&quot; enable-background=&quot;new 0 0 64 64&quot; xml:space=&quot;preserve&quot;&gt;&lt;g&gt;&lt;path fill=&quot;#ffffff&quot; d=&quot;M32,1.824C15.361,1.824,1.825,15.361,1.825,32c0,16.639,13.537,30.176,30.175,30.176 S62.175,48.639,62.175,32C62.175,15.361,48.639,1.824,32,1.824z M29.715,3.988h1.12l2.333,3.807V3.988h1.069v5.701h-1.155 l-2.298-3.718v3.718h-1.069V3.988z M9.323,33.917H8.102l-1.136-4.262l-1.132,4.262H4.587l-1.361-5.701h1.178l0.859,3.916 l1.042-3.916h1.369l0.999,3.982l0.875-3.982h1.159L9.323,33.917z M33.995,59.828c-0.181,0.285-0.438,0.497-0.77,0.636 c-0.332,0.139-0.745,0.208-1.241,0.208c-0.721,0-1.274-0.167-1.661-0.5c-0.386-0.333-0.617-0.819-0.692-1.456l1.12-0.109 c0.067,0.376,0.204,0.652,0.41,0.828c0.206,0.176,0.484,0.264,0.834,0.264c0.371,0,0.65-0.078,0.838-0.235 c0.188-0.157,0.282-0.34,0.282-0.55c0-0.135-0.04-0.25-0.119-0.344c-0.079-0.095-0.217-0.177-0.414-0.247 c-0.135-0.047-0.442-0.13-0.922-0.249c-0.617-0.153-1.05-0.341-1.299-0.564c-0.35-0.314-0.525-0.696-0.525-1.147 c0-0.29,0.082-0.562,0.247-0.815c0.165-0.253,0.402-0.445,0.712-0.577c0.31-0.132,0.684-0.198,1.122-0.198 c0.716,0,1.254,0.157,1.616,0.471c0.362,0.314,0.552,0.733,0.57,1.256l-1.151,0.051c-0.049-0.293-0.155-0.504-0.317-0.632 c-0.162-0.128-0.405-0.193-0.729-0.193c-0.334,0-0.596,0.069-0.786,0.206c-0.122,0.088-0.183,0.206-0.183,0.354 c0,0.135,0.057,0.25,0.171,0.346c0.145,0.122,0.498,0.249,1.058,0.381c0.56,0.132,0.974,0.269,1.243,0.41 c0.268,0.141,0.478,0.334,0.63,0.58c0.152,0.245,0.227,0.548,0.227,0.908C34.267,59.237,34.176,59.543,33.995,59.828z M32,52.795 c-11.466,0-20.795-9.329-20.795-20.795c0-11.466,9.329-20.795,20.795-20.795S52.795,20.534,52.795,32 C52.795,43.466,43.466,52.795,32,52.795z M55.014,33.917v-5.701h4.227v0.965h-3.076v1.264h2.862v0.96h-2.862v1.552h3.185v0.961 H55.014z&quot;/&gt;&lt;g&gt;&lt;path fill=&quot;#000000&quot; d=&quot;M48.904,31.863c-4.074-1.358-8.148-2.717-12.226-4.066c-0.265-0.087-0.399-0.223-0.486-0.486 c-1.349-4.077-2.708-8.151-4.066-12.226c-0.029-0.087-0.074-0.169-0.132-0.3c-0.054,0.152-0.09,0.245-0.122,0.34 c-1.352,4.053-2.707,8.104-4.048,12.161c-0.096,0.292-0.246,0.428-0.532,0.522c-4.056,1.342-8.108,2.696-12.16,4.049 c-0.097,0.032-0.189,0.074-0.344,0.137c0.172,0.06,0.267,0.093,0.362,0.125c4.074,1.358,8.148,2.717,12.224,4.072 c0.204,0.068,0.337,0.158,0.412,0.386c1.243,3.757,2.498,7.511,3.75,11.265c0.144,0.432,0.291,0.862,0.463,1.373 c0.068-0.185,0.108-0.285,0.142-0.386c1.349-4.042,2.701-8.083,4.04-12.128c0.094-0.284,0.231-0.438,0.523-0.534 c4.056-1.341,8.108-2.696,12.161-4.048c0.099-0.033,0.195-0.076,0.347-0.137C49.067,31.925,48.987,31.891,48.904,31.863z M37.475,32.038c-1.316,0.439-2.631,0.879-3.947,1.314c-0.095,0.031-0.139,0.081-0.17,0.173c-0.434,1.313-0.873,2.625-1.311,3.937 c-0.012,0.033-0.024,0.066-0.046,0.126c-0.056-0.166-0.104-0.306-0.15-0.446c-0.407-1.219-0.814-2.437-1.218-3.657 c-0.025-0.074-0.068-0.104-0.134-0.125c-1.323-0.44-2.646-0.881-3.968-1.322c-0.031-0.01-0.062-0.022-0.118-0.041 c0.05-0.02,0.081-0.034,0.112-0.045c1.315-0.439,2.631-0.879,3.947-1.314c0.093-0.03,0.142-0.075,0.173-0.17 c0.435-1.316,0.875-2.632,1.314-3.947c0.01-0.031,0.022-0.062,0.039-0.11c0.019,0.042,0.033,0.069,0.043,0.097 c0.441,1.323,0.882,2.645,1.321,3.969c0.028,0.085,0.072,0.129,0.158,0.158c1.324,0.438,2.646,0.879,3.969,1.32 c0.027,0.009,0.053,0.02,0.1,0.038C37.538,32.013,37.507,32.027,37.475,32.038z&quot;/&gt;&lt;path fill=&quot;#000000&quot; d=&quot;M24.436,27.633c-1.069-2.137-2.119-4.237-3.216-6.43c2.189,1.094,4.292,2.145,6.433,3.216 c-0.359,0.713-0.706,1.404-1.057,2.091c-0.023,0.045-0.078,0.082-0.127,0.106C25.807,26.949,25.143,27.28,24.436,27.633z&quot;/&gt;&lt;path fill=&quot;#000000&quot; d=&quot;M39.573,27.632c-0.696-0.348-1.351-0.673-2.002-1.005c-0.076-0.038-0.155-0.104-0.193-0.177 c-0.338-0.661-0.666-1.326-1.019-2.033c2.121-1.061,4.228-2.115,6.43-3.217C41.69,23.399,40.635,25.509,39.573,27.632z&quot;/&gt;&lt;path fill=&quot;#000000&quot; d=&quot;M24.436,36.339c0.712,0.357,1.394,0.698,2.074,1.043c0.046,0.024,0.088,0.073,0.113,0.121 c0.339,0.671,0.674,1.345,1.028,2.051c-2.126,1.063-4.232,2.117-6.43,3.216C22.317,40.577,23.37,38.472,24.436,36.339z&quot;/&gt;&lt;path fill=&quot;#000000&quot; d=&quot;M36.358,39.555c0.354-0.707,0.688-1.38,1.028-2.05c0.028-0.056,0.084-0.111,0.14-0.139 c0.67-0.339,1.343-0.674,2.047-1.026c1.066,2.131,2.118,4.235,3.215,6.43C40.601,41.676,38.503,40.628,36.358,39.555z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;h1 class=&quot;speed&quot;&gt; &lt;span class=&quot;speed-value&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;units&quot;&gt;KM/H&lt;/span&gt;&lt;/h1&gt; JS 部分 宣告常數arrow用來放取得的 Svg 羅盤圖片。 宣告常數speed用來放自速度表(.speed)取得的速度(.speed-value)。 12const arrow = document.querySelector(&#x27;.arrow&#x27;);const speed = document.querySelector(&#x27;.speed-value&#x27;); Navigator.geolocation會回傳一個唯讀的 Geolocation 物件，這個物件可以被用來存取裝置的位置資訊。 Geolocation物件有一個方法watchPosition()，用來註冊使用者裝置位置更新的監聽器。我們在下面的例子傳入2個參數，分別作為成功取得位置資訊(success)和無法取得位置資訊(error)的回傳函式。 無法取得位置資訊，會拿到PositionError物件。 成功取得位置資訊的話，會拿到Position物件，這個物件的內容如下: 在Position物件的coords屬性裡面，我們可以發現包含經緯度(longitude、latitude)、定位精準度(accuracy)、移動速度(speed)還有偏離北方的度數(heading)等等…。 在成功取得位置資訊的情況下，我們把取得的Position物件(data)丟到第一個回傳函式，然後把速度表上的速度換成自位置資訊得知的速度，再把 svg 圖也旋轉自位置資訊得知的北方偏移量就完成了。 在無法取得位置資訊的情況下，我們把取得的PositionError物件(err)丟到第二個回傳函式，然後把錯誤印到 console 上並且提示使用者。 12345678navigator.geolocation.watchPosition((data)=&gt;&#123; console.log(data); speed.textContent = data.coords.speed; arrow.style.transform = `rotate($&#123;data.coords.heading&#125;deg)`; &#125;,(err) =&gt;&#123; console.err(err); alert(&#x27;Hey! You gotta allow that to happen!!!&#x27;);&#125;); 今天的內容相對前幾天的 Webcam 要來得和藹可親許多，我覺得學習像這樣用一鬆一緊的方式比較會有持續下去的動力 \\(&gt; &lt;)/ 補充資料: Navigator.geolocation Geolocation Geolocation.watchPosition() 範例網頁請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第20天","slug":"ironman2021D20","date":"2021-09-20T07:29:01.000Z","updated":"2022-03-13T17:23:24.736Z","comments":true,"path":"2021/09/20/ironman2021D20/","link":"","permalink":"https://qi-xiang.github.io/2021/09/20/ironman2021D20/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 利用 Web Speech API 取得使用者的麥克風存取權限進行語音辨識，然後把識別出的內容寫到網頁上。 設定本地伺服器 跟昨天一樣，要取得使用者的媒體裝置必須是在安全連線之下(secure origin)，所以我們必須自己架一個 little server。 今天不採用 Wes Bos 用 NPM 架 Server 的方法，因為我發現只要在Visual Studio 有安裝 Live Server 這個延伸模組就可以不用安裝一些 NPM 看不懂的套件，也能達到一樣的效果。 點擊左方的方塊(延伸模組 or Extension)，然後搜尋Live Server安裝後啟用即可 打開你的網頁檔案，右下角就會有一個Go Live的按鈕，點下去就可以用localhost即時預覽網頁 這樣有比用 NPM 來得輕鬆很多吧~~~ 解析程式碼 HTML 部分 div(.words) 用來放經過語音辨識後所產生的文字段落(&lt;p&gt;~&lt;/p&gt;)。 1&lt;div class=&quot;words&quot; contenteditable&gt;&lt;/div&gt; JS 部分 SpeechRecognition本身是一個在 browser 之下的 global variable，但是因為瀏覽器支援性的問題，我們在 Chrome 必須使用帶有前綴字的webkitSpeechRecognition。 1window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; 首先建立一個SpeechRecognition物件recognition來幫我們做語音辨識。 設定SpeechRecognition物件的屬性interimResults為 true，它就會將現在辨識到的所有內容都回傳，如果是 false 的話，則只有停止說話才回傳內容。 設定SpeechRecognition物件的屬性lang為en-US，表示要辨識的語言是英文。 123const recognition = new SpeechRecognition();recognition.interimResults = true;recognition.lang = &#x27;en-US&#x27;; 建立&lt;p&gt;標籤用來放入辨識出的文字內容。 宣告常數words並取得 div(.words)。 words.appendChild(p);，將&lt;p&gt;標籤的文字段落放到div(.words)裡面，換句話說就是把辨識出的內容先放到&lt;p&gt;再放到&lt;div class=&quot;words&quot;&gt;裡面。 123let p = document.creatElement(&#x27;p&#x27;);const words = document.querySelector(&#x27;.words&#x27;);words.appendChild(p); 替SpeechRecognition物件recognition註冊result event的監聽器，如果有回傳result就觸發事件，然後把這個Speech Recognition Event印到 console，觀察後你會發現我們需要用到的東西是放在‵e.results這個 lsit 裡面。 recognition.start();開始語音識別，原則上只會識別一次，當停止說話一段時間即停止。 1234567recognition.addEventListener(&#x27;result&#x27;,e=&gt;&#123; console.log(e); //log speech recognition event console.log(e.results); debugger; //breakpoint&#125;);recognition.start(); SpeechRecognitionEvent SpeechRecognitionEvent.results 其中 results[0] 隱含一些必要資訊，包括語音辨識出的內容(transcript)和是否已經停止辨識(isFinal)。 宣告常數transcript並透過兩次map取得results[0].transcript也就是語音辨識出的內容。 因為results本身不是 Array 不能用 map()，所以先用Array.from()換成 Array。 第一次的 map() 取的 results[0] 所構成的陣列，第二次 map() 取得 results[0] 內部 transcript 所構成的陣列，最後將陣列內的元素 transcript 用join()串成一個大字串。 p.textContent = transcript;，將這次辨識出的所有內容放到&lt;p&gt;標籤裡面。 12345678recognition.addEventListener(&#x27;result&#x27;,e=&gt;&#123; /*上略...*/ const transcript = Array.from(e.results) .map(result =&gt; result[0]) .map(result =&gt; result.transcript).join(&#x27;&#x27;); p.textContent = transcript; // will be overwrite&#125;); 在第一次語音辨識結束之後，接下來它不會主動開始下一次的語音辨識。 我們可以在recognition註冊end event，當語音辨識結束就觸發下一次語音辨識開始(recognition.start)。 1recognition.addEventListener(&#x27;end&#x27;,recognition.start); 目前為止我們還有一個問題沒有解決，就是在每一次的語音辨識的過程，&lt;p&gt;標籤會不斷被覆寫，因為我們沒有為每一次的語音辨識建立自己的&lt;p&gt;標籤，一直都是在改原來的那個。 下面我們用 if 判斷當這次的語音辨識結束，就新增一個新的&lt;p&gt;標籤到&lt;div class=&quot;words&quot;&gt;上，這樣就不會有覆寫的狀況。 1234567recognition.addEventListener(&#x27;result&#x27;,e=&gt;&#123; /*上略...*/ if(e.results[0].isFinal)&#123; p = document.createElement(&#x27;p&#x27;); words.appendChild(p); &#125;&#125;); 最後，我們還可以加點有趣的東西，當語音辨識到特定內容，就在 console 上印出提示。 12345678recognition.addEventListener(&#x27;result&#x27;,e=&gt;&#123; //上略...// if(transcript.includes(&#x27;rainning day&#x27;))&#123; console.log(&#x27;It is a bad weather.&#x27;); &#125; console.log(transcript);&#125;); 補充資料: 使用 Web Speech API SpeechRecognition 範例網頁請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第19天","slug":"ironman2021D19","date":"2021-09-19T07:28:54.000Z","updated":"2022-03-13T17:23:21.237Z","comments":true,"path":"2021/09/19/ironman2021D19/","link":"","permalink":"https://qi-xiang.github.io/2021/09/19/ironman2021D19/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 取得使用者的鏡頭影像，藉此實作出網頁版的相機以及影像濾鏡效果。 設定本地伺服器 這次的範例會需要取得鏡頭的存取權限，而在取得過程必須是透過https或是localhost這類的secure origin才行，以下我們透過npm install和npm start架起自己的 little server (localhost)。 如果發現下面的指令無效的話，表示沒有安裝Node.js，可以點這邊下載 LTS 的版本，都用預設的安裝就好。 第一步 : 先移動到編輯檔案的工作目錄，接著輸入npm install，它會幫你安裝一些套件 第二步 : 輸入npm start，它會去執行package.json裡的start，開始運行一個 little server。(紅色框是目前的網頁位置) 解析程式碼 HTML 部分 div(.controls) : 裡面放置用來拍照的按鈕和調整綠幕效果的按鈕。 canvas(.photo) : 用來放入鏡頭的影像，之後會搭配一些濾鏡。 video(.player) : 固定在右上角的小影像視窗。 div(.strip) : 用來放入擷取下來的圖片。 audio(.snap) : 放入按下拍照按鈕時要撥放的音效。 12345678910111213141516171819202122232425262728293031&lt;div class=&quot;photobooth&quot;&gt; &lt;div class=&quot;controls&quot;&gt; &lt;button onClick=&quot;takePhoto()&quot;&gt;Take Photo&lt;/button&gt; &lt;div class=&quot;rgb&quot;&gt; &lt;label for=&quot;rmin&quot;&gt;Red Min:&lt;/label&gt; &lt;input type=&quot;range&quot; min=0 max=255 name=&quot;rmin&quot;&gt; &lt;label for=&quot;rmax&quot;&gt;Red Max:&lt;/label&gt; &lt;input type=&quot;range&quot; min=0 max=255 name=&quot;rmax&quot;&gt; &lt;br&gt; &lt;label for=&quot;gmin&quot;&gt;Green Min:&lt;/label&gt; &lt;input type=&quot;range&quot; min=0 max=255 name=&quot;gmin&quot;&gt; &lt;label for=&quot;gmax&quot;&gt;Green Max:&lt;/label&gt; &lt;input type=&quot;range&quot; min=0 max=255 name=&quot;gmax&quot;&gt; &lt;br&gt; &lt;label for=&quot;bmin&quot;&gt;Blue Min:&lt;/label&gt; &lt;input type=&quot;range&quot; min=0 max=255 name=&quot;bmin&quot;&gt; &lt;label for=&quot;bmax&quot;&gt;Blue Max:&lt;/label&gt; &lt;input type=&quot;range&quot; min=0 max=255 name=&quot;bmax&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;canvas class=&quot;photo&quot;&gt;&lt;/canvas&gt; &lt;video class=&quot;player&quot;&gt;&lt;/video&gt; &lt;div class=&quot;strip&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;audio class=&quot;snap&quot; src=&quot;./snap.mp3&quot; hidden&gt;&lt;/audio&gt; JS 部分 老樣子，我們要先取得所有要用到的元素。 .player 是小鏡頭畫面。 canvas 是可以套上濾鏡的大鏡頭畫面。 ctx 是canvas的渲染環境。 strip 是放照片的容器。 snap 是拍照的音效。 12345const video = document.querySelector(&#x27;.player&#x27;);const canvas = document.querySelector(&#x27;.photo&#x27;);const ctx = canvas.getContext(&#x27;2d&#x27;);const strip = document.querySelector(&#x27;.strip&#x27;);const snap = document.querySelector(&#x27;.snap&#x27;); 先來處理取得鏡頭影像的部分 : navigator.mediaDevices.getUserMedia()，用來取得使用者的媒體裝置，因為我們只需要取得影像，所以指定&#123;video:true,audio:false&#125;不存取音訊，最後回傳一個Promise。 我們用then()繼續進行處理，因為不能直接將取得的MediaStream指定為video的來源(它看不懂QQ)，還需要透過window.URL.createObjectURL()把MediaStream換成video可以理解的URL，然後video.play()開始播放影像。 到這邊，我們還需要用catch()來處理例外發生的狀況，當無法順利取得媒體裝置或是媒體裝置不存在，就會在 console 上印出錯誤訊息。 12345678910111213function getVideo()&#123; navigator.mediaDevices.getUserMedia(&#123;video:true,audio:false&#125;) .then(localMediaStream =&gt; &#123; console.log(localMediaStream); video.src = window.URL.createObjectURL(localMediaStream); video.play(); &#125;) .catch(err =&gt; &#123; console.log(`OH NO!!!`,err); &#125;);&#125;getVideo(); 把影像放到畫布(canvas)上 : 為了讓畫布的大小和取得的影像大小一致，使用 video.videoWidth、video.videoHeight取得影像的寬、長，然後修改畫布的寬(canvas.width)、長(canvas.height)。 setInterval()，設定每隔一段時間就把影像更新到畫布(這邊是設定16毫秒)。 ctx.drawImage()，把影像畫到畫布(canvas)上。 video.addEventListener('canplay',paintToCanvas)，如果影像現在是可以正常播放的話，就持續將影像輸出到畫布上。 123456789101112function paintToCanvas()&#123; const width = video.videoWidth; const height = video.videoHeight; canvas.width = width; canvas.height = height; setInterval(() =&gt;&#123; ctx.drawImage(video,0,0,width,height); &#125;,16);&#125;video.addEventListener(&#x27;canplay&#x27;,paintToCanvas); 按下Take Photo時的快門音效、把擷取下來的圖片放入strip內供下載 : snap.currentTime = 0，確保每一次都是從頭開始播放音效，snap.play()開始播放。 canvas.toDataURL('image/jpeg')將canvas上的影像轉換成image/jpeg格式的URL檔案連結。 const link = document.createElement('a')，在文件上新增一個&lt;a&gt;標籤。 link.href = data，將標籤連結指定為取得的影像圖檔連結。 link.setAttribute('download','handsome')，設定這個連結是可被點擊下載，同時下載的檔案名稱為handsome。 link.innerHTML = &lt;img src=&quot;$&#123;data&#125;&quot; alt=&quot;handsome man&quot; /&gt;，在&lt;a&gt;內部放入我們取得的圖片，現在只要點擊圖片就會把圖片下載下來。 strip.insertBefore(link,strip.firstChild)，將整個&lt;a&gt;&lt;img&gt;&lt;/a&gt;(擷取的影像圖)插入到.strip裡面並且是第一個位置。 1234567891011121314function takePhoto()&#123; //Play the sound snap.currentTime = 0; snap.play(); const data = canvas.toDataURL(&#x27;image/jpeg&#x27;); console.log(data); const link = document.createElement(&#x27;a&#x27;); link.href = data; link.setAttribute(&#x27;download&#x27;,&#x27;handsome&#x27;); //link.textContent = &#x27;Download Image&#x27;; link.innerHTML = `&lt;img src=&quot;$&#123;data&#125;&quot; alt=&quot;handsome man&quot; /&gt;`; strip.insertBefore(link,strip.firstChild);&#125; 影像的濾鏡效果 : 不同的濾鏡效果其實只是將CanvasRenderingContext2D.getImageData()取得的畫布像素(pixels)數據以每四個為一組(R-G-B-A)的方式修改，然後再將修改完的像素用CanvasRenderingContext2D.putImageData()放回畫布。 1. 紅色濾鏡 增強紅色並減弱綠、藍色 12345678function redEffect(pixels)&#123; for(let i=0;i &lt; pixels.data.lenght;i+=4)&#123; pixels.data[i + 0] = pixels.data[i + 0] + 100;// R pixels.data[i + 1] = pixels.data[i + 0] - 50;// G pixels.data[i + 2] = pixels.data[i + 0] * 0.5;// B &#125; return pixels;&#125; 2. 色彩分離 實際上是讓色板產生位移 (這部分不太好理解@@) 12345678function rgbSplit(pixels)&#123; for(let i=0;i &lt; pixels.data.lenght;i+=4)&#123; pixels.data[i - 150] = pixels.data[i + 0];// R pixels.data[i + 500] = pixels.data[i + 0];// G pixels.data[i - 550] = pixels.data[i + 0];// B &#125; return pixels;&#125; 3. 綠幕 讓一定數值範圍內的 R、G、B 消失。 建立一個空物件levels，接著放入每一個 range 的名稱和數值。 以每四個為一組的方式取得畫布像素的 R、G、B 數值，接著把顏色進行比對，舉紅色為例，如果像素的 R 值處在 rmin 和 rmax 之間，就把該像素的透明度設定為0(在畫面上消失)。 1234567891011121314151617181920212223242526function greenScreen(pixels) &#123; const levels = &#123;&#125;; document.querySelectorAll(&#x27;.rgb input&#x27;).forEach((input) =&gt; &#123; levels[input.name] = input.value; &#125;); for (i = 0; i &lt; pixels.data.length; i = i + 4) &#123; red = pixels.data[i + 0]; green = pixels.data[i + 1]; blue = pixels.data[i + 2]; alpha = pixels.data[i + 3]; if (red &gt;= levels.rmin &amp;&amp; green &gt;= levels.gmin &amp;&amp; blue &gt;= levels.bmin &amp;&amp; red &lt;= levels.rmax &amp;&amp; green &lt;= levels.gmax &amp;&amp; blue &lt;= levels.bmax) &#123; // take it out! pixels.data[i + 3] = 0; &#125; &#125; return pixels; &#125; 套用濾鏡 : (以套用紅色濾鏡為例，其他濾鏡也是同理) 12345678910111213141516171819function paintToCanvas()&#123; const width = video.videoWidth; const height = video.videoHeight; canvas.width = width; canvas.height = height; return setInterval(() =&gt;&#123; ctx.drawImage(video,0,0,width,height); //take the pixels out let pixels = ctx.getImageData(0,0,width,height); //mass with them pixels = redEffect(pixels); //put them back ctx.putImageData(pixels,0,0); &#125;,16);&#125; 這次的練習是目前為止最複雜的，連我自己本身也花了非常多的時間查資料，但仍然沒有辦法把細節交代清楚。 所以大家可能要多花些精力在學習這次的課程內容上，大家加油~~~ 補充資料: Enabling the Microphone/Camera in Chrome for (Local) Unsecure Origins Navigator Navigator.mediaDevices MediaDevices.getUserMedia() URL.createObjectURL() CanvasRenderingContext2D.drawImage() HTMLCanvasElement.toDataURL() Document.createElement() HTMLMediaElement Element.setAttribute() Node.insertBefore() debugger CanvasRenderingContext2D.putImageData() CanvasRenderingContext2D.getImageData() 範例網頁請點此 ps. 這次的網頁比較特殊，如果打開鏡頭仍然無法看到效果的話，可能就要自己 fork 程式碼到本地端測試~","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第18天","slug":"ironman2021D18","date":"2021-09-18T07:08:37.000Z","updated":"2022-03-13T17:23:18.940Z","comments":true,"path":"2021/09/18/ironman2021D18/","link":"","permalink":"https://qi-xiang.github.io/2021/09/18/ironman2021D18/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 今天也是複習回，主要是拿來重新複習下 Array 的map()和reduce()的用法。我們的最終目標是算出影片的長度總和並以時、分、秒呈現在 console裡。 解析程式碼 HTML 部分 以下是我們要用來計算影片總時數的清單，其中data-time屬性值標示出影片的長度。 123456789101112131415161718&lt;ul class=&quot;videos&quot;&gt; &lt;li data-time=&quot;5:43&quot;&gt; Video 1 &lt;/li&gt; &lt;li data-time=&quot;2:33&quot;&gt; Video 2 &lt;/li&gt; &lt;li data-time=&quot;3:45&quot;&gt; Video 3 &lt;/li&gt; &lt;li data-time=&quot;0:47&quot;&gt; Video 4 &lt;/li&gt; &lt;li data-time=&quot;5:21&quot;&gt; Video 5 &lt;/li&gt; &lt;!--以下省略--&gt;&lt;ul&gt; JS 部分 一開始，我們宣告常數timeNodes用來放我們取得的所有清單項目(&lt;li&gt;~&lt;/li&gt;)，因為之後會用到 Array 的reduce()、map()，這裡就順便把NodeList用Array.from()轉換成 Array。 1const timeNodes = Array.from(document.querySelectorAll(&#x27;[data-time]&#x27;)); 宣告常數seconds存入所有影片的秒數總和。 第一個map()幫我們取得個別影片時間所構成的陣列(分:秒)。 第二個map()幫我們把影片時間的分和秒切開(間隔符號:)，第三個map()幫我們把陣列中的元素都轉換成浮點數，最後把影片的長度都換成秒(mins * 60 + secs)。 把影片長度都換成以秒為單位後，就可以用reduce()將它們加在一起囉! 1234567const seconds = timeNodes .map(node =&gt; node.dataset.time) .map(timeCode =&gt; &#123; const [mins, secs] = timeCode.split(&#x27;:&#x27;).map(parseFloat); return (mins * 60) + secs; &#125;) .reduce((total, vidSeconds) =&gt; total + vidSeconds); 第一次map()後產生的陣列 第二、三次map()後產生的陣列 所有影片長度的秒數總和 接下來，把得到的總秒數換成時、分、秒的形式就完成本日的目標囉! 123456789let secondsLeft = seconds;//Math.floor() 回傳小於等於所給數字的最大整數const hours = Math.floor(secondsLeft / 3600);secondsLeft = secondsLeft % 3600;const mins = Math.floor(secondsLeft / 60);secondsLeft = secondsLeft % 60;console.log(hours, mins, secondsLeft); 補充資料: Array.from() parseFloat() Array.prototype.map() Array.prototype.reduce() Math.floor()","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第17天","slug":"ironman2021D17","date":"2021-09-17T07:08:32.000Z","updated":"2022-03-13T17:23:15.236Z","comments":true,"path":"2021/09/17/ironman2021D17/","link":"","permalink":"https://qi-xiang.github.io/2021/09/17/ironman2021D17/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 將陣列元素拿掉冠詞再進行排序，然後個別轉成 HTML 的格式放入清單中。(今天是複習回，相信只要有認真學習前面的課程內容，一定可以輕鬆完成的!!!) 解析程式碼 HTML 部分 嗯，就是一個空的清單。 1&lt;ul id=&quot;bands&quot;&gt;&lt;/ul&gt; JS 部分 (ps. 這次基本上都是在複習之前Array的東西，所以就不再贅述Array方法的運用) 我們要拿來做排序的陣列bands。 1const bands = [&#x27;The Plot in You&#x27;, &#x27;The Devil Wears Prada&#x27;, &#x27;Pierce the Veil&#x27;, &#x27;Norma Jean&#x27;, &#x27;The Bled&#x27;, &#x27;Say Anything&#x27;, &#x27;The Midway State&#x27;, &#x27;We Came as Romans&#x27;, &#x27;Counterparts&#x27;, &#x27;Oh, Sleeper&#x27;, &#x27;A Skylit Drive&#x27;, &#x27;Anywhere But Here&#x27;, &#x27;An Old Dog&#x27;]; 依照陣列元素的字母順序排列。 1234567const sortedBands = bands.sort((a,b) =&gt; &#123; if(a &gt; b)&#123; return 1; &#125;else&#123; return -1; &#125;&#125;); 我們希望去掉冠詞(articles)後再做排序，所以撰寫strip()用來去掉冠詞。 replace(/^(a |the |an )/i, ''): 將陣列元素的冠詞(不分大小寫)以空白取代。 trim() : 去掉字串兩邊的空白。 123function strip(bandName)&#123; return bandName.replace(/^(a |the |an )/i, &#x27;&#x27;).trim();&#125; 改成去掉冠詞再排序: 1234567const sortedBands = bands.sort(function(a,b)&#123; if(strip(a) &gt; strip(b))&#123; return 1; &#125;else&#123; return -1; &#125;&#125;); 精簡一點的寫法: 123const sortedBands = bands.sort((a,b) =&gt; &#123; return strip(a) &gt; strip(b) ? 1 : -1;&#125;); 將排序過的陣列元素轉換成 HTML 格式放入清單(#bands)作為其中的項目。 1document.querySelector(&#x27;#bands&#x27;).innerHTML = sortedBands.map(band =&gt; `&lt;li&gt;$&#123;band&#125;&lt;/li&gt;`); 這個時候打開瀏覽器，我們會發現好像有那裡怪怪的，清單項目之前怎麼有的會有逗號(,)呢? 那是因為我們放進去的是被用toString()先轉型過後的字串，但原本陣列元素之間就有用逗號(,)作為間隔符號，在轉型後雖然去掉[]，但是逗號(,)依然還在，也就這樣被放進去了。 我們可以用老方法join()幫我們先把陣列元素以空白作為間隔符號串聯成字串再放進去#band的innerHTML，這樣逗號就消失啦。 1document.querySelector(&#x27;#bands&#x27;).innerHTML = sortedBands.map(band =&gt; `&lt;li&gt;$&#123;band&#125;&lt;/li&gt;`).join(&quot;&quot;); 今天的內容基本上是在複習之前學過的東西，觀看 JS30 的教學影片時，可以考慮暫停影片，自己練習看看喔! 補充資料: Array.prototype.sort() Array.prototype.map() String.prototype.replace() String.prototype.trim() Array.prototype.join() Template literals 範例網頁請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第16天","slug":"ironman2021D16","date":"2021-09-16T07:08:27.000Z","updated":"2022-03-13T17:23:12.670Z","comments":true,"path":"2021/09/16/ironman2021D16/","link":"","permalink":"https://qi-xiang.github.io/2021/09/16/ironman2021D16/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 讓文字陰影跟著滑鼠一起移動。 解析程式碼 HTML 部分 在.hero內放入我們預計要用來產生文字陰影(Text Shadow)效果的文字(h1)。 h1上有一個特殊的屬性:contenteditable，表示&lt;h1&gt;&lt;/h1&gt;之間的內容是可以被修改的。 123&lt;div class=&quot;hero&quot;&gt; &lt;h1 contenteditable&gt;🔥WOAH!&lt;/h1&gt;&lt;/div&gt; &lt;h1&gt;&lt;/h1&gt;之間的內容可被修改如下: 修改前 修改後 JS 部分 在實作文字陰影效果之前，我們要先取得.hero和內部的h1。 12const hero = document.querySelector(&#x27;.hero&#x27;);const text = hero.querySelector(&#x27;h1&#x27;); 由於我們的目的是產生文字陰影隨著滑鼠移動的效果，所以在.hero上註冊mousemove 事件的監聽器並以shadow()進行事件處理。 1hero.addEventListener(&#x27;mousemove&#x27;,shadow); shadow() : const &#123; offsetWidth: width, offsetHeight: height&#125; = hero; : 最初，我們必須先取得.hero的width、height，用來計算後續文字陰影的移動量。 let &#123; offsetX: x, offsetY: y&#125; = e; : 我們也必須知道現在滑鼠所在的座標。 注意，這裡我們使用的是 ES6 Destructuring Assignment(解構賦值)的語法所以不使用像是const width = hero.offsetWidth;、const height = hero.offsetHeight;這種較繁瑣的寫法。 12345678910function shadow(e)&#123; //const width = hero.offsetWidth; //const height = hero.offsetHeight; const &#123; offsetWidth: width, offsetHeight: height&#125; = hero; //where the person&#x27;s cursor was //let x = e.offsetX; //let y = e.offsetY; let &#123; offsetX: x, offsetY: y&#125; = e;&#125; 因為event.offsetX、event.offsetY取得的是滑鼠相對於事件源元素（srcElement）的X,Y坐標，所以當我們把滑鼠移動到h1得到的座標就會是以h1的左上角為(0,0)開始的位置。 這樣的位置是有問題的，我們原本要取得的應該是滑鼠在視窗裡面的位置(或說是滑鼠相對.hero的位置)，所以必須要做一點修正。 我們在觸發mousemove event的 DOM 物件不是.hero的情況下(this !== e.target)進行座標修正，只要滑鼠處於h1內部，就分別把(x,y)加上h1相對.hero左方和上方的距離。 12345678function shadow(e)&#123; /*上略...*/ //if hovering h1 instead of hero, then modify the x and the y values if (this !== e.target)&#123; x = x + e.target.offsetLeft; y = y + e.target.offsetTop; &#125;&#125; 接下來，我們要決定文字陰影實際上可以移動的距離和範圍。 宣告常數walk作為在(x,y)方向所能移動的最遠距離，這裡我們設為500，也就是向左或向右各250、向上或向下各250。 const xWalk = Math.round((x / width * walk) - (walk / 2));，把.hero的中心點x 座標指定為0，x的範圍從-250~250(視窗最左邊到最右邊)。 const yWalk = Math.round((y / height * walk) - (walk / 2));，把.hero的中心點y 座標指定為0，y的範圍從-250~250(視窗最上面到最下面)。 結合兩者，畫面上的座標 : 左上角(-250,-250)、正中央(0,0)、右下角(250,250)。 12345678const walk = 500;function shadow(e)&#123; /*上略...*/ //how far the text shadow should actually go const xWalk = Math.round((x / width * walk) - (walk / 2)); const yWalk = Math.round((y / height * walk) - (walk / 2));&#125; TextShadow能移動的範圍 (以walk = 500為例) 決定TextShadow可以移動的範圍後，接下來只要設定TextShadow的移動方向和顏色就完成囉! 123456789function shadow(e)&#123; /*上略...*/ text.style.textShadow = ` $&#123;xWalk&#125;px $&#123;yWalk&#125;px 0 rgba(255,0,255,0.7), $&#123;xWalk * -1&#125;px $&#123;yWalk&#125;px 0 rgba(0,255,255,0.7), $&#123;yWalk&#125;px $&#123;xWalk * -1&#125;px 0 rgba(0,255,0,0.7), $&#123;yWalk * -1&#125;px $&#123;xWalk&#125;px 0 rgba(0,0,255,0.7) `;&#125; 補充資料: contenteditable [筆記] ES6: Destructuring Assignment 解構賦值的使用 JS一秒區分clientX,offsetX,screenX,pageX之間關係 範例網頁請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第15天","slug":"ironman2021D15","date":"2021-09-15T07:08:22.000Z","updated":"2022-03-13T17:23:10.207Z","comments":true,"path":"2021/09/15/ironman2021D15/","link":"","permalink":"https://qi-xiang.github.io/2021/09/15/ironman2021D15/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 將被新增到menu的項目儲存到localStorage中，使得後續刷新頁面時，可以從localStorage調用資料回復之前新增在menu的項目。 解析程式碼 HTML 部分 最外層的.wrapper代表的是整個的 menu，.plates則用來放入 menu 的內容項目。最後，.add-items是一個表單元素，裡面有一個文字輸入框(&lt;input type=&quot;text&quot;&gt;&lt;/input&gt;)用來填入要新增的項目名稱，還有一個用來加入項目到 menu 的 submit button(&lt;input type=&quot;submit&quot;&gt;&lt;/input&gt;)。 1234567891011&lt;div class=&quot;wrapper&quot;&gt; &lt;h2&gt;LOCAL TAPAS&lt;/h2&gt; &lt;p&gt;&lt;/p&gt; &lt;ul class=&quot;plates&quot;&gt; &lt;li&gt;Loading Tapas...&lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;add-items&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;item&quot; placeholder=&quot;Item Name&quot; required&gt; &lt;input type=&quot;submit&quot; value=&quot;+ Add Item&quot;&gt; &lt;/form&gt;&lt;/div&gt; JS 部分 宣告常數addItems用來存放取得的整個 menu(.add-items)。 宣告常數itemsList用來存放 menu 裡的所有項目(.plates)。 宣告常數items為一個空陣列，用來存放我們每次在文字輸入框填入要新增到 menu 的 item。 123const addItems = document.querySelector(&#x27;.add-items&#x27;);const itemsList = document.querySelector(&#x27;.plates&#x27;);const items = []; addItem() : 我們首先用e.preventDefault()避免每次提交新的內容進入items造成頁面的 reloading。 宣告常數text用來存放在文字輸入框填入的項目名稱。 建立物件item並賦予兩個屬性text(項目的名稱)、done(是否被勾選)，這裡我們原本可以用text:text;，但在 ES6 裡可以被簡寫為text。 將建立出的物件放入(push)陣列items中，之後用this.reset()清掉在文字輸入框的文字以利下一次新增項目。 123456789101112function addItem(e)&#123; e.preventDefault();//prevent page from reloading const text = this.querySelector(&#x27;[name=&quot;item&quot;]&#x27;).value; const item = &#123; text, //text: text done: false &#125; items.push(item); this.reset(); //form element clear the input&#125;addItems.addEventListener(&#x27;submit&#x27;,addItem); populateList(): 用來將items裡所有的item逐一轉換成 HTML 的格式，藉此更新 menu 上的項目。 透過map()將陣列中的item(方法裡用plate代稱)，逐一用&lt;li&gt;~&lt;li&gt;的格式重新組合成一個有checkBox可以勾選的列表項目。 因為map()回傳的是一個陣列，所以在最後用join()將陣列中的元素以空白作為間隔符號串聯成一個 HTML 格式的字串並修改列表(ul)裡的項目內容(innerHTML)。 1234567891011//create the actual html here function populateList(plates = [], platesList)&#123; //plates default: empty, prvent to crash javascript if you forget to pass it platesList.innerHTML = plates.map((plate,i) =&gt;&#123; //i: index return ` &lt;li&gt; &lt;input type=&quot;checkbox&quot; data-index=$&#123;i&#125; id=&quot;item$&#123;i&#125;&quot; $&#123;plate.done ? &#x27;checked&#x27; : &#x27;&#x27;&#125;&gt; &lt;label for=&quot;item$&#123;i&#125;&quot;&gt;$&#123;plate.text&#125;&lt;/label&gt; &lt;/li&gt; `; &#125;).join(&#x27;&#x27;); &#125; JS 的部分完成到這裡，基本上就可以將新建立的項目放到 menu 中。 但是將網頁重新整理(F5)，我們可以發現原來放到 menu 中的東西都不見了。那要怎麼保留我們之前在 menu 放入的項目呢? 相信 localStorage 可以幫我們這個忙。 Window.localStorage localStorage 允許我們存取目前文件(Document)隸屬網域來源的Storage 物件，簡單來說我們可以用key-value(鍵-值)的方式來存取這個Storage物件的資料，localStorage存放的資料是沒有時間限制的(不會關閉網頁就不見)。另外，這邊的鍵-值都是以字串型態存放。 實際在localStorage放資料(localStorage.setItem()): 1localStorage.setItem(&#x27;myCat&#x27;, &#x27;Tom&#x27;); 打開檢查模式，查看我們放的資料(Application -&gt; Local Storage): 資料真的被放到 Local Storage 裡面了，我們之後就可以用 Local Storage 的方法調用這些已存的資料。 用 localStorage 存取資料 items : 我們原本宣告常數items為一個空陣列，但是我們也可以改成如果localStorage有資料(localStorage.getItem('items'))就將其放入items。要注意localStorage放的資料是字串型態，所以還要藉助JSON.parse()把它還原成物件再傳遞給items。 addItem() : 每一次加入新的item到items，我們都需要同時更新現在menu的項目內容，所以我們在方法裡面加上populateList(items,itemsList);。 localStorage.setItem('items',JSON.stringify(items));用來把我們新增的item存進localStorage保存新增在menu的項目。要注意items本身是物件型別(Object)，所以要先用JSON.stringify()將其轉換成字串再存入localStorage。 12345678const items = JSON.parse(localStorage.getItem(&#x27;items&#x27;)) || []; // dump data from localstorage if existed function addItem(e)&#123; /*上略*/ populateList(items,itemsList); localStorage.setItem(&#x27;items&#x27;,JSON.stringify(items)); /*下略...*/ &#125; 只要做到這裡，之前加入到menu的item就不會在重新整理網頁的時候消失不見，每次都會從localStorage取得之前的資料(如果有資料的話)。 但這樣好像還是少了什麼，如果我們將checkBox勾起來再去重新整理網頁，就會發現checkBox又回到沒勾選的狀態。要儲存checkBox的勾選狀態，我們可以用另一個方法toggleDone()來處理。 toggleDone() : Event.target 指向最初觸發事件的 DOM 物件。 if(!e.target.matches('input')) return;，如果觸發事件的 DOM 物件不是input element的話，就停止繼續執行。 宣告常數el存放觸發事件的 DOM 物件。 宣告常數index存放觸發事件的 DOM 物件的data-index屬性。 items[index].done = !items[index].done;，讓觸發事件的 DOM 物件的done變為相反值(true to false；false to true)，前面我們在populateList()裡設定item (plate)的done屬性是true就將checkBox打勾(checked)。($&#123;plate.done ? 'checked' : ''&#125;) 最後我們需要將變更後的items再次的放入localStorage中，要注意先用JSON.stringify()轉換成字串再放入，接著用populateList()去更新現在menu的內容就完成了。 12345678910function toggleDone(e)&#123; if(!e.target.matches(&#x27;input&#x27;)) return; const el = e.target; const index = el.dataset.index; items[index].done = !items[index].done; localStorage.setItem(&#x27;items&#x27;,JSON.stringify(items)); populateList(items,itemsList);&#125;itemsList.addEventListener(&#x27;click&#x27;,toggleDone); 1234567891011//create the actual html herefunction populateList(plates = [], platesList)&#123; //plates default: empty, prvent to crash javascript if you forget to pass it platesList.innerHTML = plates.map((plate,i) =&gt;&#123; //i: index return ` &lt;li&gt; &lt;input type=&quot;checkbox&quot; data-index=$&#123;i&#125; id=&quot;item$&#123;i&#125;&quot; $&#123;plate.done ? &#x27;checked&#x27; : &#x27;&#x27;&#125;&gt; &lt;label for=&quot;item$&#123;i&#125;&quot;&gt;$&#123;plate.text&#125;&lt;/label&gt; &lt;/li&gt; `; &#125;).join(&#x27;&#x27;);&#125; 補充資料: Array.prototype.map() Window.localStorage Storage Event.target Event Delegation — 事件委派介紹 與 觸發委派的回呼函數 範例網頁請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第14天","slug":"ironman2021D14","date":"2021-09-14T07:08:17.000Z","updated":"2022-03-13T17:23:08.149Z","comments":true,"path":"2021/09/14/ironman2021D14/","link":"","permalink":"https://qi-xiang.github.io/2021/09/14/ironman2021D14/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 瞭解 JavaScript 的 Passed by Value 和 Passed by Reference 以及 Object 的 shallow copy 和 deep copy。 解析程式碼 JS 部分 Passed by Value 在 JavaScript 裡，如果變數的資料型態屬於 Primitive(原生型別)，則在傳遞變數時，採用的是 Passed by Value (傳遞值)。 常見的 Primitive: String Number BigInt Boolean Symbol 在下面的兩個例子，我們分別將age、name傳遞給age2、name2，之後改變age2、name2的數值。結果原本的age、name均不會受到影響，因為在傳遞過程是 Passed by Value，將原本存於age、name的值複製一份給age2、name2。 123456let age = 100;let age2 = age;console.log(age,age2);age = 200;console.log(age,age2); 123456let name = &#x27;Mes&#x27;;let name2 = name;console.log(name,name2);name = &#x27;wesley&#x27;;console.log(name,name2); 簡易概念圖 Passed by Reference 在 JavaScript 裡，如果變數的資料型態屬於 Object(物件型別)，則在傳遞變數時，採用的是 Passed by Reference (傳遞位址)。 常見的 Object: Array Object 下面的例子，我們將陣列 players 傳遞給常數 team，之後將team[3](Poppy)改成Lux，再把兩個陣列都印到 console，會發現到兩個陣列的第四個位置都被修改成新的值(Lux)。 這是因為物件在傳遞的過程中採取的是 Passed by Reference，也就是將物件在記憶體上的位置傳遞給另一個物件(兩者共享同一個記憶體位置)，所以只要更改其中一方，另一方也會受到影響。 123456const players = [&#x27;Wes&#x27;,&#x27;Sarah&#x27;,&#x27;Ryan&#x27;,&#x27;Poppy&#x27;];const team = players;console.log(players,team); team[3] = &#x27;Lux&#x27;;console.log(players,team); 如果想修改陣列的值又不影響另一個陣列的話，我們可以使用slice()來複製陣列並回傳新陣列(擁有自己的記憶體空間)。 下面的例子，我們呼叫players.slice()將陣列players完整的複製一份到新陣列中並傳遞給team2，之後再修改team2的第四個位置，這次我們發現到原來的陣列players並沒有被修改到。 注意:slice()進行的是shallow copy(淺複製)!!! 1234const team2 = players.slice()team2[3] = &#x27;Lux&#x27;;console.log(players,team2) 其他修改陣列的值又不影響另一個陣列的方法有: concat() : 將多個陣列進行串聯和slice()一樣會回傳串聯後的新陣列。 Spread : 將陣列中的元素展開並逐個放到新陣列中。 Array.from() : 建立一個新的 Array 實體。 123456const team3 = [].concat(players);//use the new ES6 Spreadconst team4 = [...players];const team5 = Array.from(players); 另一個例子，我們宣告物件person並把它傳遞給captain，在captain上新增number: 90後將兩個物件都印到 consle，此時會發現在captain新增的number: 90，也會被加到person上。會這樣是因為物件在傳遞過程是 Passed by Reference，兩物件同時指向一個記憶體空間。 123456789const person = &#123; name: &#x27;Wes Bos&#x27;, age: 80&#125;;const captain = person;captain.number = 99;console.log(person,captain); 如果不想修改到另一個物件的話，我們可以使用Object.assign(target, ...sources)來複製一個或多個物件的屬性到另一個目標物件，最後回傳目標物件。 下面我們利用Object.assign(&#123;&#125;,person,&#123;number: 99,age:12&#125;);，將物件person和&#123;number:99,age:12&#125;的屬性複製到目標物件({ })。 如果複製的多個物件的屬性有重複，以後面物件的屬性為準進行合併。舉例來說age是重複出現的屬性，最後複製屬性值時，要以後面出現的age:12為準合併物件。 注意 : Object.assign()做的是 shallow copy(淺複製)，如果要複製的物件屬性包含子物件，就會複製到子物件的參照(reference)!!!。 1234567const person = &#123; name: &#x27;Wes Bos&#x27;, age: 80&#125;;const cap2 = Object.assign(&#123;&#125;,person,&#123;number: 99,age:12&#125;);console.log(person,cap2); 原來的person並沒有被改動到。 簡單概念圖 Shallow Copy &amp; Deep Copy 前面我們有提到，Object.assign()做的是 shallow copy(淺複製)，若要複製的物件屬性包含子物件，就會複製到子物件的參照。 所以只要去改動新物件的子物件屬性值，就會連帶影響原本複製的物件子屬性值。 下面我們用Object.assign()複製來源物件(wes)的屬性到目標物件({})，再將目標物件傳遞給dev物件，要留意wes的屬性包含子物件屬性(social)。 例子中我們修改複製來的物件屬性(name)和子物件屬性(social.twitter)，之後把wes、dev物件印到 console 會發現複製的來源物件wes的屬性(name)不受影響，但wes的子物件屬性(social.twitter)卻被影響。 12345678910111213141516const wes = &#123; name: &#x27;Wes&#x27;, age: 100, social: &#123; twitter: &#x27;@wesbos&#x27;, facebook: &#x27;wesbos.developer&#x27; &#125;&#125;//shallow copyconst dev = Object.assign(&#123;&#125;,wes);dev.name = &#x27;Wesley&#x27;;console.log(wes,dev);dev.social.twitter = &#x27;@coolman&#x27;;console.log(wes.social,dev.social); 如果不想改動複製來源物件的子屬性值(social.twitter)，我們可以將要複製的物件用JSON.stringify()先轉換成 JSON String(因為是Primitive，所以是 Passed by Value)，再用JSON.parse()把它還原成物件再回傳給dev2。 下面我們一樣修改子物件的屬性值，但這次的原物件子屬性值並沒有受到影響。 12345678910111213const wes = &#123; name: &#x27;Wes&#x27;, age: 100, social: &#123; twitter: &#x27;@wesbos&#x27;, facebook: &#x27;wesbos.developer&#x27; &#125;&#125;// deep copyconst dev2 = JSON.parse(JSON.stringify(wes));//先轉成string再換回objectdev2.social.twitter = &#x27;@coolman&#x27;;console.log(wes.social,dev2.social); 補充資料: JavaScript: var, let, const 差異 Array.prototype.concat() Spread syntax (…) Array.from() Object.assign() JSON.stringify() JSON.parse()","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第13天","slug":"ironman2021D13","date":"2021-09-13T06:53:12.000Z","updated":"2022-03-13T17:23:06.125Z","comments":true,"path":"2021/09/13/ironman2021D13/","link":"","permalink":"https://qi-xiang.github.io/2021/09/13/ironman2021D13/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 當捲動捲軸到一定位置，原本隱藏的圖片會由右或左方滑入原本的空白格顯現出來；當捲軸捲動量超過圖片的底部，圖片就會向左或右方滑出並重新的被隱藏。 解析程式碼 本次的結構由&lt;p&gt;標籤的假文和穿插其中向左或向右對齊的&lt;img&gt;標籤的圖片所組成。在 CSS 裡，我們透過float:right;和float:left;刻意去產生文繞圖效果並讓圖片的透明度為0，因此出現一個個空格，但這些空格一開始並不是四四方方的，所以我們又設定text-align:justify;，讓文字向兩側對齊，也讓圖片留下的空格變成完美的方形。 HTML 部分 1234567891011121314151617181920212223242526272829303132&lt;div class=&quot;site-wrap&quot;&gt; &lt;h1&gt;Slide in on Scroll&lt;/h1&gt; &lt;p&gt;Consectetur adipisicing elit. Tempore tempora rerum, est autem cupiditate, corporis a qui libero ipsum delectus quidem dolor at nulla, adipisci veniam in reiciendis aut asperiores omnis blanditiis quod quas laborum nam! Fuga ad tempora in aspernatur pariaturlores sunt esse magni, ut, dignissimos.&lt;/p&gt; &lt;p&gt;Lorem ipsum cupiditate, corporis a qui libero ipsum delectus quidem dolor at nulla, adipisci veniam in reiciendis aut asperiores omnis blanditiis quod quas laborum nam! Fuga ad tempora in aspernatur pariatur fugit quibusdam dolores sunt esse magni, ut, dignissimos.&lt;/p&gt; &lt;p&gt;Adipisicing elit. Tempore tempora rerum..&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempore tempora rerum, est autem cupiditate, corporis a qui libero ipsum delectus quidem dolor at nulla, adipisci veniam in reiciendis aut asperiores omnis blanditiis quod quas laborum nam! Fuga ad tempora in aspernatur pariatur fugit quibusdam dolores sunt esse magni, ut, dignissimos.&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempore tempora rerum, est autem cupiditate, corporis a qui libero ipsum delectus quidem dolor at nulla, adipisci veniam in reiciendis aut asperiores omnis blanditiis quod quas laborum nam! Fuga ad tempora in aspernatur pariatur fugit quibusdam dolores sunt esse magni, ut, dignissimos.&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempore tempora rerum, est autem cupiditate, corporis a qui libero ipsum delectus quidem dolor at nulla, adipisci veniam in reiciendis aut asperiores omnis blanditiis quod quas laborum nam! Fuga ad tempora in aspernatur pariatur fugit quibusdam dolores sunt esse magni, ut, dignissimos.&lt;/p&gt; &lt;img src=&quot;http://unsplash.it/400/400&quot; class=&quot;align-left slide-in&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptates, deserunt facilis et iste corrupti omnis tenetur est. Iste ut est dicta dolor itaque adipisci, dolorum minima, veritatis earum provident error molestias. Ratione magni illo sint vel velit ut excepturi consectetur suscipit, earum modi accusamus voluptatem nostrum, praesentium numquam, reiciendis voluptas sit id quisquam. Consequatur in quis reprehenderit modi perspiciatis necessitatibus saepe, quidem, suscipit iure natus dignissimos ipsam, eligendi deleniti accusantium, rerum quibusdam fugit perferendis et optio recusandae sed ratione. Culpa, dolorum reprehenderit harum ab voluptas fuga, nisi eligendi natus maiores illum quas quos et aperiam aut doloremque optio maxime fugiat doloribus. Eum dolorum expedita quam, nesciunt&lt;/p&gt; &lt;img src=&quot;http://unsplash.it/400/401&quot; class=&quot;align-right slide-in&quot;&gt; &lt;p&gt; at provident praesentium atque quas rerum optio dignissimos repudiandae ullam illum quibusdam. Vel ad error quibusdam, illo ex totam placeat. Quos excepturi fuga, molestiae ea quisquam minus, ratione dicta consectetur officia omnis, doloribus voluptatibus? Veniam ipsum veritatis architecto, provident quas consequatur doloremque quam quidem earum expedita, ad delectus voluptatum, omnis praesentium nostrum qui aspernatur ea eaque adipisci et cumque ab? Ea voluptatum dolore itaque odio. Eius minima distinctio harum, officia ab nihil exercitationem. Tempora rem nemo nam temporibus molestias facilis minus ipsam quam doloribus consequatur debitis nesciunt tempore officiis aperiam quisquam, molestiae voluptates cum, fuga culpa. Distinctio accusamus quibusdam, tempore perspiciatis dolorum optio facere consequatur quidem ullam beatae architecto, ipsam sequi officiis dignissimos amet impedit natus necessitatibus tenetur repellendus dolor rem! Dicta dolorem, iure, facilis illo ex nihil ipsa amet officia, optio temporibus eum autem odit repellendus nisi. Possimus modi, corrupti error debitis doloribus dicta libero earum, sequi porro ut excepturi nostrum ea voluptatem nihil culpa? Ullam expedita eligendi obcaecati reiciendis velit provident omnis quas qui in corrupti est dolore facere ad hic, animi soluta assumenda consequuntur reprehenderit! Voluptate dolor nihil veniam laborum voluptas nisi pariatur sed optio accusantium quam consectetur, corrupti, sequi et consequuntur, excepturi doloremque. Tempore quis velit corporis neque fugit non sequi eaque rem hic. Facere, inventore, aspernatur. Accusantium modi atque, asperiores qui nobis soluta cumque suscipit excepturi possimus doloremque odit saepe perferendis temporibus molestiae nostrum voluptatum quis id sint quidem nesciunt culpa. Rerum labore dolor beatae blanditiis praesentium explicabo velit optio esse aperiam similique, voluptatem cum, maiores ipsa tempore. Reiciendis sed culpa atque inventore, nam ullam enim expedita consectetur id velit iusto alias vitae explicabo nemo neque odio reprehenderit soluta sint eaque. Aperiam, qui ut tenetur, voluptate doloremque officiis dicta quaerat voluptatem rerum natus magni. Eum amet autem dolor ullam.&lt;/p&gt; &lt;img src=&quot;http://unsplash.it/200/500&quot; class=&quot;align-left slide-in&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Distinctio maiores adipisci quibusdam repudiandae dolor vero placeat esse sit! Quibusdam saepe aperiam explicabo placeat optio, consequuntur nihil voluptatibus expedita quia vero perferendis, deserunt et incidunt eveniet &lt;img src=&quot;http://unsplash.it/200/200&quot; class=&quot;align-right slide-in&quot;&gt; temporibus doloremque possimus facilis. Possimus labore, officia dolore! Eaque ratione saepe, alias harum laboriosam deserunt laudantium blanditiis eum explicabo placeat reiciendis labore iste sint. Consectetur expedita dignissimos, non quos distinctio, eos rerum facilis eligendi. Asperiores laudantium, rerum ratione consequatur, culpa consectetur possimus atque ab tempore illum non dolor nesciunt. Neque, rerum. A vel non incidunt, quod doloremque dignissimos necessitatibus aliquid laboriosam architecto at cupiditate commodi expedita in, quae blanditiis. Deserunt labore sequi, repellat laboriosam est, doloremque culpa reiciendis tempore excepturi. Enim nostrum fugit itaque vel corporis ullam sed tenetur ipsa qui rem quam error sint, libero. Laboriosam rem, ratione. Autem blanditiis&lt;/p&gt; &lt;p&gt;laborum neque repudiandae quam, cumque, voluptate veritatis itaque, placeat veniam ad nisi. Expedita, laborum reprehenderit ratione soluta velit natus, odit mollitia. Corporis rerum minima fugiat in nostrum. Assumenda natus cupiditate hic quidem ex, quas, amet ipsum esse dolore facilis beatae maxime qui inventore, iste? Maiores dignissimos dolore culpa debitis voluptatem harum, excepturi enim reiciendis, tempora ab ipsam illum aspernatur quasi qui porro saepe iure sunt eligendi tenetur quaerat ducimus quas sequi omnis aperiam suscipit! Molestiae obcaecati officiis quo, ratione eveniet, provident pariatur. Veniam quasi expedita distinctio, itaque molestiae sequi, dolorum nisi repellendus quia facilis iusto dignissimos nam? Tenetur fugit quos autem nihil, perspiciatis expedita enim tempore, alias ab maiores quis necessitatibus distinctio molestias eum, quidem. Delectus impedit quidem laborum, fugit vel neque quo, ipsam, quasi aspernatur quas odio nihil? Veniam amet reiciendis blanditiis quis reprehenderit repudiandae neque, ab ducimus, odit excepturi voluptate saepe ipsam. Voluptatem eum error voluptas porro officiis, amet! Molestias, fugit, ut! Tempore non magnam, amet, facere ducimus accusantium eos veritatis neque.&lt;/p&gt; &lt;img src=&quot;http://unsplash.it/400/400&quot; class=&quot;align-right slide-in&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Distinctio maiores adipisci quibusdam repudiandae dolor vero placeat esse sit! Quibusdam saepe aperiam explicabo placeat optio, consequuntur nihil voluptatibus expedita quia vero perferendis, deserunt et incidunt eveniet temporibus doloremque possimus facilis. Possimus labore, officia dolore! Eaque ratione saepe, alias harum laboriosam deserunt laudantium blanditiis eum explicabo placeat reiciendis labore iste sint. Consectetur expedita dignissimos, non quos distinctio, eos rerum facilis eligendi. Asperiores laudantium, rerum ratione consequatur, culpa consectetur possimus atque ab tempore illum non dolor nesciunt. Neque, rerum. A vel non incidunt, quod doloremque dignissimos necessitatibus aliquid laboriosam architecto at cupiditate commodi expedita in, quae blanditiis. Deserunt labore sequi, repellat laboriosam est, doloremque culpa reiciendis tempore excepturi. Enim nostrum fugit itaque vel corporis ullam sed tenetur ipsa qui rem quam error sint, libero. Laboriosam rem, ratione. Autem blanditiis laborum neque repudiandae quam, cumque, voluptate veritatis itaque, placeat veniam ad nisi. Expedita, laborum reprehenderit ratione soluta velit natus, odit mollitia. Corporis rerum minima fugiat in nostrum. Assumenda natus cupiditate hic quidem ex, quas, amet ipsum esse dolore facilis beatae maxime qui inventore, iste? Maiores dignissimos dolore culpa debitis voluptatem harum, excepturi enim reiciendis, tempora ab ipsam illum aspernatur quasi qui porro saepe iure sunt eligendi tenetur quaerat ducimus quas sequi omnis aperiam suscipit! Molestiae obcaecati officiis quo, ratione eveniet, provident pariatur. Veniam quasi expedita distinctio, itaque molestiae sequi, dolorum nisi repellendus quia facilis iusto dignissimos nam? Tenetur fugit quos autem nihil, perspiciatis expedita enim tempore, alias ab maiores quis necessitatibus distinctio molestias eum, quidem. Delectus impedit quidem laborum, fugit vel neque quo, ipsam, quasi aspernatur quas odio nihil? Veniam amet reiciendis blanditiis quis reprehenderit repudiandae neque, ab ducimus, odit excepturi voluptate saepe ipsam. Voluptatem eum error voluptas porro officiis, amet! Molestias, fugit, ut! Tempore non magnam, amet, facere ducimus accusantium eos veritatis neque.&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Distinctio maiores adipisci quibusdam repudiandae dolor vero placeat esse sit! Quibusdam saepe aperiam explicabo placeat optio, consequuntur nihil voluptatibus expedita quia vero perferendis, deserunt et incidunt eveniet temporibus doloremque possimus facilis. Possimus labore, officia dolore! Eaque ratione saepe, alias harum laboriosam deserunt laudantium blanditiis eum explicabo placeat reiciendis labore iste sint. Consectetur expedita dignissimos, non quos distinctio, eos rerum facilis eligendi. Asperiores laudantium, rerum ratione consequatur, culpa consectetur possimus atque ab tempore illum non dolor nesciunt. Neque, rerum. A vel non incidunt, quod doloremque dignissimos necessitatibus aliquid laboriosam architecto at cupiditate commodi expedita in, quae blanditiis. Deserunt labore sequi, repellat laboriosam est, doloremque culpa reiciendis tempore excepturi. Enim nostrum fugit itaque vel corporis ullam sed tenetur ipsa qui rem quam error sint, libero. Laboriosam rem, ratione. Autem blanditiis laborum neque repudiandae quam, cumque, voluptate veritatis itaque, placeat veniam ad nisi. Expedita, laborum reprehenderit ratione soluta velit natus, odit mollitia. Corporis rerum minima fugiat in nostrum. Assumenda natus cupiditate hic quidem ex, quas, amet ipsum esse dolore facilis beatae maxime qui inventore, iste? Maiores dignissimos dolore culpa debitis voluptatem harum, excepturi enim reiciendis, tempora ab ipsam illum aspernatur quasi qui porro saepe iure sunt eligendi tenetur quaerat ducimus quas sequi omnis aperiam suscipit! Molestiae obcaecati officiis quo, ratione eveniet, provident pariatur. Veniam quasi expedita distinctio, itaque molestiae sequi, dolorum nisi repellendus quia facilis iusto dignissimos nam? Tenetur fugit quos autem nihil, perspiciatis expedita enim tempore, alias ab maiores quis necessitatibus distinctio molestias eum, quidem. Delectus impedit quidem laborum, fugit vel neque quo, ipsam, quasi aspernatur quas odio nihil? Veniam amet reiciendis blanditiis quis reprehenderit repudiandae neque, ab ducimus, odit excepturi voluptate saepe ipsam. Voluptatem eum error voluptas porro officiis, amet! Molestias, fugit, ut! Tempore non magnam, amet, facere ducimus accusantium eos veritatis neque.&lt;/p&gt;&lt;/div&gt; JS 部分 我們的目的是讓圖片隨著捲軸下滑一個個的從左或右滑進來，為了達成這個目的，我們會在視窗(window)上註冊scroll 事件的監聽器。 如果將每次觸發的scroll 事件用console.count(e)計算並印出到console上，你會發現只是稍微的滑動滾輪就觸發數次scroll 事件。而太頻繁地觸發事件的處理對瀏覽器來說是很大的負擔，也因此我們必須借助debounce()來幫我們延遲事件的處理，預設是延遲20毫秒。 1234567891011121314151617/*用來延遲執行方法*/function debounce(func, wait = 20, immediate = true) &#123; var timeout; return function() &#123; var context = this, args = arguments; var later = function() &#123; timeout = null; if (!immediate) func.apply(context, args); &#125;; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); &#125;;&#125;;window.addEventListener(&#x27;scroll&#x27;,e =&gt; console.count(e)); 宣告常數slideImages放入要滑進來的圖片們。 1const sliderImages = document.querySelectorAll(&#x27;.slide-in&#x27;); 觸發scroll 事件時，我們並沒有在第一時間處理它，而是利用debounce(checkSlide)讓checkSlide()被延遲20毫秒才執行。 在checkSlide()裡，我們首先必須決定圖片要在哪時候滑進來和滑出去。在這次的課程裡，我們決定要讓2分之1的圖片出現在視窗下緣時，讓圖片滑進來、捲軸移動超過圖片底端時，讓圖片滑出去。 我們使用sliderImages.forEach()分別計算2分之1圖片出現在下緣的距離(slideInAt)以及圖片的底端距離視窗上方的距離(imageBottom) window.scrollY(目前的捲軸捲動量) + window.innerHeight(視窗內部高度) = 視窗下緣離視窗頂部的距離。如果將這段距離再減去slideImage.height / 2(2分之1的圖片高度)，就會是實際上圖片的滑入點(slideInAt)。 slideImage.offsetTop(圖片頂部離視窗頂部的距離) + slideImage.height(圖片的高度) = 圖片底部離視窗頂部的距離(imageBottom)。 12345678910function checkSlide(e)&#123; sliderImages.forEach(slideImage =&gt;&#123; /*取得視窗下緣並預留2分之1的圖片高度*/ const slideInAt = (window.scrollY + window.innerHeight) - slideImage.height / 2; /*取得圖片底部離視窗頂部的距離*/ const imageBottom = slideImage.offsetTop + slideImage.height; &#125;);&#125;;window.addEventListener(&#x27;scroll&#x27;,debounce(checkSlide)); 宣告常數isHalfShown判斷圖片是否已有2分之1出現在視窗的下緣。 宣告常數isNotScrolledPast判斷捲軸的捲動量是否已經超過圖片的底部。 最後，利用 if 判斷圖片已經有2分之1出現在視窗下緣(isHalfShown = true)並且捲軸捲動量不超過圖片底部(isNotScrolledPast = true)就為圖片(slideImage)加上 .active選擇器，讓圖片滑入並顯示；反之則拿掉.active選擇器，讓圖片滑出並隱藏。 1234567891011121314function checkSlide(e)&#123; sliderImages.forEach(slideImage =&gt;&#123; /*上略*/ const isHalfShown = slideInAt &gt; slideImage.offsetTop; const isNotScrolledPast = window.scrollY &lt; imageBottom; if(isHalfShown &amp;&amp; isNotScrolledPast)&#123; slideImage.classList.add(&#x27;active&#x27;); &#125;else&#123; slideImage.classList.remove(&#x27;active&#x27;); &#125; &#125;);&#125;; 圖片初始都向左或右位移並隱藏，.active選擇器用來取消圖片原有的位移，讓圖片回到原始的位置(滑進來)。 12345678910111213/*CSS*/.align-left.slide-in &#123; transform: translateX(-30%) scale(0.95);&#125; .align-right.slide-in &#123; transform: translateX(30%) scale(0.95);&#125;.slide-in.active &#123; opacity: 1; transform: translateX(0%) scale(1);&#125; 補充資料: HTMLElement.offsetTop text-align 範例網頁請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第12天","slug":"ironman2021D12","date":"2021-09-12T06:53:06.000Z","updated":"2022-03-13T17:23:03.501Z","comments":true,"path":"2021/09/12/ironman2021D12/","link":"","permalink":"https://qi-xiang.github.io/2021/09/12/ironman2021D12/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 預先設定一組secretCode，如果在視窗畫面內輸入的文字與secretCode相同則在視窗畫面加上圖案。 (ps.背景圖是後來改的，原版是空白畫面。) 解析程式碼 這次我們需要藉助網路上別人寫好的 JavaScript API，讓他幫忙在每次視窗畫面中輸入文字等於secretCode時，在視窗畫面上新增一個生動的圖案。 觀看完整的 JavaScript API 內容 1&lt;script type=&quot;text/javascript&quot; src=&quot;https://www.cornify.com/js/cornify.js&quot;&gt;&lt;/script&gt; JS 部分 宣告常數 pressed 為一個空陣列，用來存放我們在視窗畫面所輸入的值。 宣告常數secretCode作為預設的文字密碼。 12const pressed = [];const secretCode = &#x27;saber&#x27;; 我們替整個視窗註冊keyup 事件(放開按鍵時觸發)的監聽器，藉由console.log(e.key);可以在console看到我們按下的是哪一個按鍵，緊接著我們將按下的那個按鍵(key)放入陣列pressed的末端。 為了比對輸入文字是否等於secretCode，我們可以利用splice(start,deleteCount)來讓陣列的長度跟secretCode保持一樣，沒做這個處理的話，我們會發現陣列中的元素愈來愈多、長度愈來愈長，永遠沒有和secretCode相同的可能。 splice(start,deleteCount)可以刪除陣列自start索引開始的deleteCount個元素，要注意的是deleteCount要大於0才會開始刪去元素，範例中的secretCode長度是5，也就是說只有輸入到第6次才會開始刪去元素。 有趣的是我們將deleteCount指定為pressed.length - secretCode則效果和直接指定為1相同。只要pressed的長度到達6，經過計算後deleteCount是1，刪去一個元素後，pressed長度又變為5，由此周而復始(5-&gt;6；6-&gt;5)。 指定start = -secretCode.length - 1的效果是讓我們從最早被 push 進陣列(最前端)的元素開始刪除。 12345window.addEventListener(&#x27;keyup&#x27;,(e)=&gt;&#123; console.log(e.key); pressed.push(e.key); pressed.splice(-secretCode.length - 1,pressed.length - secretCode.length);&#125;); 最後，我們利用 if 判斷用pressed.join('')串聯出的字串是否有包含secretCode，如果有包含就在console印出DING DING!並呼叫 API 中的cornify_add()在視窗畫面裡加上圖片。我們也可以再補上console.log(pressed);，查看目前pressed陣列內的元素。 12345678910window.addEventListener(&#x27;keyup&#x27;,(e)=&gt;&#123; /***省略***/ /***省略***/ if(pressed.join(&#x27;&#x27;).includes(secretCode))&#123; console.log(&#x27;DING DING!&#x27;); cornify_add(); &#125; console.log(pressed);&#125;); 補充資料: keyup事件 Array.prototype.splice() 範例網頁請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第11天","slug":"ironman2021D11","date":"2021-09-11T06:53:01.000Z","updated":"2022-03-13T17:23:01.162Z","comments":true,"path":"2021/09/11/ironman2021D11/","link":"","permalink":"https://qi-xiang.github.io/2021/09/11/ironman2021D11/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 靈活運用 video 元素的相關屬性、方法，實作出一個擁有快進快退、播放速度倍率、控制音量大小、拖拉時間軸功能的簡易影片播放器。 解析程式碼 HTML 部分 .player 代表整個影片播放器，包含影片(.player__video)、播放控制列(.player__controls)兩部分。 播放控制列內部又可細分為四個部分: 1. 影片播放的時間軸 : .progress、.progress__filled 2. 播放/暫停鈕 : .toggle 3. 音量/播放速度倍率 : .player__slider 4. 快進/快退 : .player__button 1234567891011121314&lt;div class=&quot;player&quot;&gt; &lt;video class=&quot;player__video viewer&quot; src=&quot;652333414.mp4&quot;&gt;&lt;/video&gt; &lt;div class=&quot;player__controls&quot;&gt; &lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress__filled&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;button class=&quot;player__button toggle&quot; title=&quot;Toggle Play&quot;&gt;►&lt;/button&gt; &lt;input type=&quot;range&quot; name=&quot;volume&quot; class=&quot;player__slider&quot; min=&quot;0&quot; max=&quot;1&quot; step=&quot;0.05&quot; value=&quot;1&quot;&gt; &lt;input type=&quot;range&quot; name=&quot;playbackRate&quot; class=&quot;player__slider&quot; min=&quot;0.5&quot; max=&quot;2&quot; step=&quot;0.1&quot; value=&quot;1&quot;&gt; &lt;button data-skip=&quot;-10&quot; class=&quot;player__button&quot;&gt;« 10s&lt;/button&gt; &lt;button data-skip=&quot;25&quot; class=&quot;player__button&quot;&gt;25s »&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; JS 部分 首先，取得所有要用到 HTML 標籤並放到對應宣告的常數中。 12345678910/*get element we need*/const player = document.querySelector(&#x27;.player&#x27;);const video = player.querySelector(&#x27;.viewer&#x27;);const progress = player.querySelector(&#x27;.progress&#x27;);const progressBar = player.querySelector(&#x27;.progress__filled&#x27;);const toggle = player.querySelector(&#x27;.toggle&#x27;);const skipButtons = player.querySelectorAll(&#x27;[data-skip]&#x27;);const ranges = player.querySelectorAll(&#x27;.player__slider&#x27;); 下面我們將各個播放器的功能一個個拆出來做 : 1. 影片的播放/暫停 功能目的 : 我們希望在點擊影片或播放/暫停鈕時，播放或暫停影片。 在video(影片)、toggle(播放/暫停鈕)上都註冊click 事件監聽器，觸發事件後用togglePlay()進行處理。 在togglePlay()裡，我們宣告一個常數method，經過條件判斷，當video.paused回傳 true 則 method = play；當video.paused回傳 false 則method = pause。 這邊有一個特殊的寫法video[method]();。舉例來說，當method = play則實際效果相當於video.play();。 12345678function togglePlay()&#123; const method = video.paused ? &#x27;play&#x27; : &#x27;pause&#x27;; video[method]();&#125;/*控制影片的播放*/video.addEventListener(&#x27;click&#x27;,togglePlay);toggle.addEventListener(&#x27;click&#x27;,togglePlay); 2. 更新播放/暫停圖示 功能目的 : 我們希望在影片播放/暫停的狀態下，同步更新圖示。 在video(影片)上註冊play 事件和pause 事件兩個監聽器並都以updateButton()進行事件處理。 在updateButton()裡，我們宣告一個常數icon指定當影片處於暫停狀態則icon = '►'，接著利用toggle.textContent = icon修改按鈕的圖示，當影片處於播放狀態的處理也是用一樣的方式。 12345678function updateButton()&#123; const icon = this.paused ? &#x27;►&#x27; : &#x27;❚ ❚&#x27;; toggle.textContent = icon;&#125;/*讓播放鍵的圖示改變*/video.addEventListener(&#x27;play&#x27;,updateButton);video.addEventListener(&#x27;pause&#x27;,updateButton); 3. 影片的快進/快退 功能目的 : 我們希望在點擊快進/快退按鈕時，同步調整影片的時間軸。 在skipButtons(快進、快退按鈕)裡的所有button都註冊click 事件並以skip()進行事件處理。 在skip()裡，我們將video.currentTime(影片現在播放的時間點)加上我們要快進或快退的秒數。 由於video.currentTime本身是 float 型別，因此需要將this.dataset.skip(快進/快退的秒數)用parseFloat()轉換成float型別之後再進行運算。 123456function skip()&#123; video.currentTime += parseFloat(this.dataset.skip);&#125;/*調整影片的快進和倒退*/skipButtons.forEach(button =&gt; button.addEventListener(&#x27;click&#x27;,skip)); 4. 調整影片的播放速度(倍率)、音量大小 功能目的 : 我們希望在滑鼠在倍率或音量條上移動改變數值時，同步反映到video(影片)上。 在速度倍率和音量條上都註冊change 事件和mousemove 事件，分別在數值改變和滑鼠拖曳時觸發事件，之後用handleRangeUpdate()進行事件處理。 在handleRangeUpdate()裡，我們使用和之前一樣的特殊語法video[this.name] = this.value;對video的屬性值進行調整。舉例來說，如果this.name = volume、this.value = 0，則video[this.name] = this.value;的效果和video.volume = 0;一樣。 1234567function handleRangeUpdate()&#123; video[this.name] = this.value;&#125;/*調整影片的播放速度、音量*/ranges.forEach(range =&gt; range.addEventListener(&#x27;change&#x27;,handleRangeUpdate));ranges.forEach(range =&gt; range.addEventListener(&#x27;mousemove&#x27;,handleRangeUpdate)); 5. 更新時間軸 功能目的 : 我們希望在影片播放的過程中，不斷地更新時間軸。 在video(影片)上註冊timeupdate 事件的監聽器，當影片的播放時間(currentTime)有變動就觸發事件，之後用handleProgress()進行事件處理。 在handleProgress()裡，我們宣告常數percent並放入video.currentTime(影片現在時間)除以video.duration(影片的總長度)再乘以100得到的比例值。 接著用progressBar.style.flexBasis = `$&#123;percent&#125;%`;，用percent指定時間軸的長度佔比。 1234567function handleProgress()&#123; const percent = (video.currentTime / video.duration) * 100 progressBar.style.flexBasis = `$&#123;percent&#125;%`; &#125;/*持續更新時間軸*/video.addEventListener(&#x27;timeupdate&#x27;,handleProgress); 6. 用拖拉的方式移動時間軸 功能目的 : 我們希望按住滑鼠拖或點擊時間軸的同時，更新video(影片)現在播放的時間。 宣告mousedown作為 flag 判斷現在是否有按住滑鼠。 我們在progress註冊click 事件、mousemove 事件、mousedown 事件、mouseup 事件監聽器。 觸發click 事件時，我們可以直接就以scrub(e)進行事件的處理。 但在觸發mousemove 事件時，我們需要先判斷是否有按住滑鼠，所以要借助mousedown 事件和mouseup 事件的幫忙，在mousedown 事件觸發地當下將 flag(mousedown) 設為 true，反之觸發mouseup 事件則將 flag(mousedown) 設為 false。最後用mousedown &amp;&amp; scrub(e)判斷是否執行scrub(e)，只有當flag(mousedown) 是 true 的時候，才接著執行scrub(e)完成事件處理。 在scrub(e)裡，我們宣告常數scrubTime放入將滑鼠在元素內部的X座標(e.offsetX)除以時間軸的長度(progress.offsetWidth)再乘以影片長度(video.duration)所得到要前往的時間點。最後將影片現在的時間(video.currentTime)指定為要前往的時間點(scrubTime)。 1234567891011function scrub(e)&#123; const scrubTime = (e.offsetX / progress.offsetWidth) * video.duration; video.currentTime = scrubTime;&#125;/*拖拉時間軸*/let mousedown = false;progress.addEventListener(&#x27;click&#x27;,scrub);progress.addEventListener(&#x27;mousemove&#x27;,(e)=&gt; mousedown &amp;&amp; scrub(e));progress.addEventListener(&#x27;mousedown&#x27;,() =&gt; mousedown = true);progress.addEventListener(&#x27;mouseup&#x27;,() =&gt; mousedown = false); 補充說明: HTMLVideoElement繼承自HTMLMediaElement所以一些video元素的屬性都可以到HTMLMediaElement查詢。 使用HTMLElement.offsetWidth所取得的元素(element)寬度包括透過 CSS 設定的width、border、padding等等…。 補充資料: HTMLMediaElement HTMLElement.dataset HTMLElement.offsetWidth JS一秒區分clientX,offsetX,screenX,pageX之間關係 範例網頁請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第10天","slug":"ironman2021D10","date":"2021-09-10T06:36:06.000Z","updated":"2022-03-13T17:22:48.689Z","comments":true,"path":"2021/09/10/ironman2021D10/","link":"","permalink":"https://qi-xiang.github.io/2021/09/10/ironman2021D10/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 在已經勾選一個核取方塊的前提下，按住shift鍵並勾選第二個方塊，最後將第一、二個方塊之間的方塊都勾選起來，實現同時勾選複數方塊的目的。 解析程式碼 HTML 部分 由最外層的 div(.inbox) 包覆住內部多個 div(.item)，每個div(.item) 都是以一個核取方塊(checkbox)搭配說明文字(p)組合而成。 1234567891011121314151617181920212223242526272829303132333435363738&lt;div class=&quot;inbox&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;This is an inbox layout.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Check one item&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Hold down your Shift key&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Check a lower item&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Everything in between should also be set to checked&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Try to do it without any libraries&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Just regular JavaScript&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Good Luck!&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Don&#x27;t forget to tweet your result!&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; JS 部分 首先，宣告一個常數 checkboxes 並取得所有網頁上的核取方塊(checkbox)。 接著，宣告一個變數 lastChecked 用來幫我們記住上一次勾選的核取方塊(checkbox)。 12const checkboxes = document.querySelectorAll(&#x27;.inbox input[type=&quot;checkbox&quot;]&#x27;);let lastChecked; 我們在每個 checkbox 上都註冊 click 事件監聽器，當事件觸發就以handleCheck()進行事件處理。 在handleCheck()裡面，我們可以用lastChecked = this;來記住上一次選取的方塊。 12345function handleCheck(e)&#123; lastChecked = this;//更新上次勾選的點&#125;checkboxes.forEach(checkbox =&gt; checkbox.addEventListener(&#x27;click&#x27;,handleCheck)); 我們進行多選核取方塊的邏輯是先勾選其中一個作為起始點，之後按住shift鍵勾選終點方塊，而在起、終點之間的方塊都會被勾選。 在handleCheck()裡，可以使用 if 判斷現在是不是有按下shift鍵並同時勾選方塊，之後再做勾選間隔方塊的處理。 12345678function handleCheck(e)&#123; //檢查是否有按下shift鍵並選取方塊 if(e.shiftKey &amp;&amp; this.checked)&#123; &#125; lastChecked = this;//更新上次勾選的點 &#125; 宣告一個變數inBetween判斷checkbox是否處在起、終點的checkbox之間。 在checkboxes上呼叫forEach()對其下的每一個checkbox進行判斷。當這個checkbox是剛剛按住shift鍵勾選的checkbox，此時將inBetween設為 true；當這個checkbox是lastChecked，此時改將inBetween設為 false。 最後一個 if 判斷用來幫我們將起、終點之間的方塊通通勾選起來。 12345678910111213141516171819function handleCheck(e)&#123; let inBetween = false;//用來判斷checkbox是否被夾在起、終點之間 //檢查是否有按下shift鍵並選取方塊 if(e.shiftKey &amp;&amp; this.checked)&#123; checkboxes.forEach(checkbox =&gt; &#123; //將起始點的inBetween設為true、結束點的inBetewwn設為false作為斷點 if(checkbox === this || checkbox === lastChecked)&#123; inBetween = !inBetween; &#125; if(inBetween)&#123;//打勾夾在起點和終點的checkbox checkbox.checked = true; &#125; &#125;) &#125; lastChecked = this;//更新上次勾選的點&#125; 舉例說明: 假設現在先勾選第一個方塊，之後按住shift鍵並勾選第八個方塊，此時第一個方塊就會是lastChecked，而第八個方塊則是this剛剛勾選的。 在checkboxes上呼叫forEach()對其下的每一個checkbox進行判斷時，遇到第一個方塊也就是lastChecked就將inBetween改成 true，遇到第八個方塊也就是this則將inBetween改成 false。 最後，第一個方塊到第七個方塊的inBetween都會是 true，第八個方塊則是 false。作 if 判斷時，我們將inBetween是 true 的勾選起來，勾到第八個剛好inBetween是 false 成為一個勾選的終止點，成功地一次勾選八個方塊。 補充資料: KeyboardEvent.shiftKey 範例網頁請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第9天","slug":"ironman2021D9","date":"2021-09-09T06:36:01.000Z","updated":"2022-03-13T17:22:46.358Z","comments":true,"path":"2021/09/09/ironman2021D9/","link":"","permalink":"https://qi-xiang.github.io/2021/09/09/ironman2021D9/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 學會使用一些操作 console 的 JS 方法。 在網頁元素上設置斷點 在下面的例子中，只要我們點擊文字，文字就會變大並且顏色變為綠色。 現在假設我們知道這個效果是經由 JS 之手做出來，但不知道實際上是 JS 的哪一部分發揮功能。這個時候，我們可以利用網頁的檢查功能來設定 JS 執行時的 break point，讓它在觸發效果的那一行 JS 程式碼停下來。 首先打開網頁的檢查功能，將要查看變化的元素標籤選起來並按右鍵選擇 break on -&gt; attribute modification。 接著點擊文字，會發現文字的顏色改變，但文字大小卻沒有改變。 這是因為我們在這個元素標籤上設定了一個只要屬性值改變就觸發的斷點，所以執行到 JS 的 p.style.color = '#BADA55'; 修改到標籤屬性就停止繼續往下執行下一行 JS。 如果想要繼續執行下一行 JS，只要按圖片中的藍色播放鈕，它就會跳到下一行繼續執行，同時也可以發現文字變大。 總而言之，在元素標籤上設定斷點是 debug 的一個好方法，我們可以逐步觀察程式碼的執行過程並快速找出問題點。 一些有關 console 的 JS 方法 1. console.log() Regular: 直接輸出字串到 console 上。 Interpolated: 格式化輸出字串到 console 上，類似 Java 的 printf 方法。 Styled: 在輸出字串到 console 的同時，用指定的 CSS 修飾字串。 12345678// Regularconsole.log(&#x27;Hello World&#x27;)// Interpolatedconsole.log(&#x27;I am very interested in %s animation.&#x27;,&#x27;Japanese&#x27;);// Styledconsole.log(&#x27;%c I am very interested in Japanese animation.&#x27;,&#x27;font-weight: bold;background: skyblue;color:white;font-size:20px;&#x27;); 2. console.warn() 呼叫console.warn()在 console 輸出警告訊息。 12// warning!console.warn(&#x27;Something is wrong!&#x27;); 3. console.error() 呼叫console.error()在 console 輸出錯誤訊息。 12// Errorconsole.error(&#x27;There is a fatal error!&#x27;); 4. console.info() 呼叫console.info()在 console 輸出提示訊息。 12// Infoconsole.info(&#x27;info message&#x27;); 5. console.assert() 呼叫console.assert()時，若前方的判斷結果回傳 false 則印出後方字串到 console 上。 123// Testingconst p = document.querySelector(&#x27;p&#x27;);console.assert(p.classList.contains(&#x27;ouch&#x27;),&#x27;That is wrong!&#x27;); 6. console.clear() 呼叫console.clear()清空 console 的內容。 12// clearingconsole.clear(); 7. console.dir() 呼叫console.log(DOM Element)輸出該元素標籤到 console 上。 呼叫console.dir(DOM Element)以 JSON 格式將該元素的 property 全部輸出到 console 上。 不過我在 console 看到的結果是相同的。 123// Viewing DOM Elementsconsole.log(p);console.dir(p); 8. console.group()/groupEnd() 呼叫console.group(label);進行分組、console.groupEnd(label);結束分組。 label: 組別名稱 如果初始呼叫的是console.groupCollapsed(label)，則會預設以摺疊方式呈現。 123456789// Grouping togetherdogs.forEach(dog =&gt; &#123; //console.groupCollapsed(`$&#123;dog.name&#125;`); console.group(`$&#123;dog.name&#125;`); console.log(`This is $&#123;dog.name&#125;.`); console.log(`$&#123;dog.name&#125; is $&#123;dog.age&#125; years old.`); console.log(`$&#123;dog.name&#125; is $&#123;dog.age * 7&#125; years old.`); console.groupEnd(`$&#123;dog.name&#125;`);&#125;) 呼叫console.group(label) 呼叫console.groupCollapsed(label) 9. console.count() 呼叫console.count(label);可以得到 label 出現過的次數。 1234567// countingconsole.count(&#x27;Saber&#x27;);console.count(&#x27;Saber&#x27;);console.count(&#x27;Saber&#x27;);console.count(&#x27;Miku&#x27;);console.count(&#x27;Saber&#x27;);console.count(&#x27;Miku&#x27;); 10. console.time()/timeEnd() 呼叫console.time()/timeEnd()可以取得執行到某一行 JS 經過的時間。 12345678// timingconsole.time(&#x27;fetching data&#x27;);fetch(&#x27;https://api.github.com/users/wesbos&#x27;) .then(data =&gt; data.json()) .then(data =&gt; &#123; console.timeEnd(&#x27;fetching data&#x27;); console.log(data); &#125;); 補充資料: Console API reference","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第8天","slug":"ironman2021D8","date":"2021-09-08T06:35:55.000Z","updated":"2022-03-13T17:22:43.608Z","comments":true,"path":"2021/09/08/ironman2021D8/","link":"","permalink":"https://qi-xiang.github.io/2021/09/08/ironman2021D8/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 使用 JavaScript 實作出能在 HTML Canvas 上用筆刷畫圖的極簡版小畫家。 解析程式碼 HTML 部分 在 body 內放入 canvas 標籤作為我們的畫布，這裡雖然指定大小為 800*800，但之後會利用 JS 把它改成跟視窗(window)一樣大。 1&lt;canvas id=&quot;draw&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; JS 部分 取得 canvas 標籤後，將畫布的寬、高，將其改成跟視窗內部的寬、高一樣的數值。 123const canvas = document.querySelector(&#x27;#draw&#x27;);canvas.width = window.innerWidth;canvas.height = window.innerHeight; canvas 只是一個空白的畫布，實際上我們需要“取得畫布的渲染環境(rendering context)”才能在渲染環境上作畫。 我們呼叫 canvas 的 getContext() 方法並放入 “2d” 作為參數，順利取得 canvas 的 2D 渲染環境，若是要取得 3D 渲染環境只要放入 “3d” 作為參數就好。 緊接著，我們調整 context 的 strokeStyle 屬性值，更改作畫時的畫筆顏色。 context 的 lineJoin 是用來設定兩條長度不為0的線段如何在接合處連接，把值設定為 “round” 則在相連部分以扇形連接。 context 的 lineCap 是用來設定線段末端的呈現方式，把值設定為 “round” 則在末端部分以扇形呈現。 context 的 lineWidth 用來設定線條的粗細。 12345const ctx = canvas.getContext(&#x27;2d&#x27;);ctx.strokeStyle = &#x27;#BADASS&#x27;;ctx.lineJoin = &#x27;round&#x27;;ctx.lineCap = &#x27;round&#x27;;ctx.lineWidth = 100; 我們希望在視窗下按住滑鼠拖曳時作畫，所以在 canvas 上註冊4個事件監聽器。 觸發’mousedown’事件時，設定 isDrawing = true，表示現在可以作畫；設定 [lastX,lastY] = [e.offsetX,e.offsetY]，更新作畫的起始點。 觸發’mousemove’事件時，用 draw() 方法持續的進行作畫。 觸發’mouseup’、'mouseout’時，皆設定 isDrawing = false，表示在滑鼠沒被按住和滑鼠離開視窗的情況下都停止作畫。 123456789101112let isDrawing = false;//flaglet lastX = 0;let lastY = 0;canvas.addEventListener(&#x27;mousemove&#x27;,draw);canvas.addEventListener(&#x27;mousedown&#x27;,(e)=&gt; &#123; isDrawing = true; [lastX,lastY] = [e.offsetX,e.offsetY]; &#125;);canvas.addEventListener(&#x27;mouseup&#x27;,()=&gt; isDrawing = false);canvas.addEventListener(&#x27;mouseout&#x27;,()=&gt; isDrawing = false); 事件處理方法 draw()，在最初就先判斷現在能不能作畫，不能的話(isDrawing = false)就直接返回。 ctx.beginPath() 用來建立一個新的作畫路徑。 ctx.moveTo() 用來移動路徑起始點的座標。 ctx.lineTo() 用來指定這條路徑的終點座標。 ctx.stroke() 將這條路徑描出來。 [lastX,lastY] = [e.offsetX,e.offset] 用來不斷更新&quot;此次&quot;按住滑鼠拖曳作畫過程中持續變動的路徑起始點。 1234567891011function draw(e)&#123; if(!isDrawing) return; ctx.beginPath(); //start from ctx.moveTo(lastX,lastY); //go to ctx.lineTo(e.offsetX,e.offsetY); ctx.stroke(); [lastX,lastY] = [e.offsetX,e.offsetY];&#125; HSL 的 H(Hue，色相角度)，是由 0~360 為止的色相循環，0是紅色、120是綠色、240是藍色，Hue 本身不加單位，詳細說明可以參考下方補充資料 CSS Coke 大大的文章。 宣告 hue 變數指定畫筆顏色，並持續的將 hue + 1，當 hue &gt;= 360時，代表顏色已經循環過一次，故將其重設為0。 宣告 direction 變數作為目前該加粗畫筆還是讓畫筆變細的判斷，direction 的初始值是 true 也就是讓畫筆變粗。第一個 if 判斷目前的畫筆粗細是不是 &gt;= 100 或 &lt;= 1，如果條件符合就將 direction 變為相反值(true 變 false)。在第二個的 if-else 判斷，如果 direction = true 就加粗畫筆、反之則讓畫筆變得更細。 123456789101112131415161718192021let hue = 0;let direction = true;function draw(e)&#123; /*.......省略*/ ctx.strokeStyle = `hsl($&#123;hue&#125;,100%,50%)`; /*.......省略*/ hue++; if(hue &gt;= 360)&#123; hue = 0; &#125; if(ctx.lineWidth &gt;= 100 || ctx.lineWidth &lt;= 1)&#123; direction = !direction; &#125; if(direction)&#123; ctx.lineWidth++; &#125;else&#123; ctx.lineWidth--; &#125;&#125; 最後來介紹一個特別的東西，ctx 的 globalCompositeOperation，主要用來處理疊圖(線段重疊)的情況，若將其設定為 ‘multiply’ 則將上層像素與相對應的下層像素相乘，整體效果是讓顏色更加趨於黑色。 1ctx.globalCompositeOperation = &#x27;multiply&#x27;; 補充資料: Canvas 基本用途 CanvasRenderingContext2D.strokeStyle CanvasRenderingContext2D.lineJoin CanvasRenderingContext2D.lineCap CanvasRenderingContext2D.lineWidth CanvasRenderingContext2D.beginPath() CanvasRenderingContext2D.moveTo() CanvasRenderingContext2D.lineTo() RGB、HSL、Hex 網頁色彩碼，看完這篇全懂了 JS一秒區分clientX,offsetX,screenX,pageX之間關係 CanvasRenderingContext2D.globalCompositeOperation 範例網頁請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第7天","slug":"ironman2021D7","date":"2021-09-07T06:35:50.000Z","updated":"2022-03-13T17:22:40.164Z","comments":true,"path":"2021/09/07/ironman2021D7/","link":"","permalink":"https://qi-xiang.github.io/2021/09/07/ironman2021D7/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 練習使用JS Array 的 some()、every()、find()、findIndex()。 解析程式碼 JS 部分 練習題使用到的資料: 1234567891011121314const people = [ &#123; name: &#x27;Wes&#x27;, year: 1988 &#125;, &#123; name: &#x27;Kait&#x27;, year: 1986 &#125;, &#123; name: &#x27;Irv&#x27;, year: 1970 &#125;, &#123; name: &#x27;Lux&#x27;, year: 2015 &#125;];const comments = [ &#123; text: &#x27;Love this!&#x27;, id: 523423 &#125;, &#123; text: &#x27;Super good&#x27;, id: 823423 &#125;, &#123; text: &#x27;You are the best&#x27;, id: 2039842 &#125;, &#123; text: &#x27;Ramen is my fav food ever&#x27;, id: 123523 &#125;, &#123; text: &#x27;Nice Nice Nice!&#x27;, id: 542328 &#125;]; 1. Is at least one person 19 or older? Array.prototype.some() some() 可以給定一個函式，測試陣列中是否至少有一個元素符合指定的條件，該方法回傳的是布林值。 Date 建立一個 JavaScript Date 物件來取得某個時間點。Date 物件是從世界標準時間（UTC） 1970 年 1 月 1 日開始算起。 第一題，我們檢查是否至少有一個 person 的年紀大於 19歲。指定一個 function 到 some() 中，在 function 裡面，我們宣告一個常數 currentYear來存放現在的年份，之後透過 if 判斷用現在的年份減去 person 的出生年，是否大於19，如果大於19就返回 true。 基本版: 12345const isAdult = people.some(function(person)&#123; const currentYear = (new Date()).getFullYear(); if(currentYear - person.year &gt;= 19) return true;&#125;); 簡化版: 1234const isAdult = people.some(person =&gt; &#123; const currentYear = (new Date()).getFullYear(); return currentYear - person.year &gt; 19;&#125;); 更簡化版: 123const isAdult = people.some(person =&gt; (new Date().getFullYear()) - person.year &gt;= 19 );console.log(isAdult); 2. Is everyone 19 or older? Array.prototype.every() every() 方法會測試陣列中的所有元素是否都符合函式所指定的條件，若全部元素都符合則返回 true，反之則返回 false。 我們使用 every() 方法，將陣列元素一個個的拿出來做條件判斷，若是有其中一個元素經過計算不符合設定的規則就 return false。 123const allAdults = people.every(person =&gt; (new Date().getFullYear()) - person.year &gt;= 19 );console.log(allAdults); 3. Find the comment with the ID of 823423. Array.prototype.find() find() 方法會回傳第一個符合函式定義條件的元素值，若沒有元素符合條件就回傳undefined。 下面我們使用 find() 找出 comment id 是 823423 的 comment。這邊是用===而不是==進行相等運算，因為在 js 中使用 == 進行相等運算，js 會幫你偷偷地轉換型別再進行比較，例如: '99' == 99 的結果就會是 true。===則是嚴格的相等運算，js 不會偷偷的做資料轉型，兩邊資料型態只要不一致，自然就會回傳 false。 基本版: 12345const comment = comments.find(function(comment)&#123; if(comment.id === 823423)&#123; return true; &#125;&#125;); 簡化版: 123const comment = comments.find(comment =&gt; comment.id === 823423);console.log(comment); 4. Delete the comment with the ID of 823423. Array.prototype.findIndex() findIndex()方法將按照指定的函式，尋找陣列中第一個符合條件的元素，並回傳元素的 index（索引）。如果沒有找到符合的元素就回傳 -1 。 Array.prototype.slice() slice()方法會回傳一個新的陣列，它會切割出原陣列從索引 begin 至 end（不含 end）的元素。原本的陣列不會被影響。 我們使用 findIndex() 尋找到第一個 comment id 是 823423 的元素並取得該元素的索引值(index)。 透過 slice()將陣列進行切割，我們可以將找出的元素值從陣列中移除並宣告常數承接回傳的新陣列。(複習一下，前面說過...可以把陣列中的元素一個個地展開。) 1234567891011const index = comments.findIndex(comment =&gt; comment.id === 823423);console.log(index);const newComments = [ ...comments.slice(0,index), ...comments.slice(index + 1)];console.table(comments);console.table(newComments); 補充資料: 相等比較 ===、== Array.prototype.slice() Array.prototype.findIndex() Array.prototype.find() Array.prototype.every() Date Array.prototype.some()","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第6天","slug":"ironman2021D6","date":"2021-09-06T06:27:37.000Z","updated":"2022-03-13T17:22:37.512Z","comments":true,"path":"2021/09/06/ironman2021D6/","link":"","permalink":"https://qi-xiang.github.io/2021/09/06/ironman2021D6/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 利用 Fetch API 取得 JSON 格式的資料，隨著輸入關鍵字的不同，將特定資料篩選出來並呈現在網頁上。 解析程式碼 JS 部分 將要取得的資料來源網址放入 endpoint中，並建立一個空的city陣列。 123const endpoint = &#x27;https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json&#x27;;const cities = [];/*empty array*/ fetch() 是 Fetch API 的一個方法，主要用於發出資料的 request 並回傳 Promise，有點類似於XMLHttpRequest，但在使用上較有彈性。 Promise 物件代表的是一個將要完成或失敗的非同步操作，以及它所產生的值。 then() 方法最多需要兩個參數，分別作為 Promise 成功和失敗時的 callback function 並返回 Promise。 json() 方法會接收一個 response stream，在讀取完成之後返回一個解析成 JSON 格式的 Promise。 我們透過 fetch() 向 endpoint 發送 request，之後將 return 的 Promise 以 json 格式進行解構，最後將這些資料一筆筆的 push 到空的 cities 陣列中。...data的主要用意在於將原本的 data 陣列中的元素個別拆出來放進 cities 裡面，如果直接寫cities.push(data)則 data 會變成在 cities 內部的一個陣列型態元素。 123fetch(endpoint) .then(blob =&gt; blob.json()) .then(data =&gt; cities.push(...data)); findMatches() 需要用到兩個參數，wordToMatch 用來傳入要尋找的文字，cities 則是原本的資料陣列，最後回傳經過 filter() 過濾後的 cities 陣列。 在 filter() 裡，我們將 cities 的每一個元素用 RegExp 物件進行正規表示式的字元比對，之後將包含關鍵字的 city 或是 state回傳。 RegExp() 用來建立一個正規表達式的物件，wordToMatch 是要進行比對的內容，'gi'則是 flag，g 代表搜尋出所有符合比對的文字，而不是比對出第一筆就停止，i 代表比對時不分大小寫。 123456function findMatches(wordToMatch, cities)&#123; return cities.filter(place =&gt; &#123; const regex = new RegExp(wordToMatch,&#x27;gi&#x27;); return place.city.match(regex) || place.state.match(regex); &#125;)&#125; numberWithCommas() 主要用來幫我們在每三位數字加上逗號(ex.1,000)。toString() 可以幫我們將 x 轉成字串，之後利用 replace() 進行正規表示式的判斷並取代字元。 123function numberWithCommas(x)&#123; return x.toString().replace(/\\B(?=(\\d&#123;3&#125;)+(?!\\d))/g,&#x27;,&#x27;);&#125; 宣告 matchArray 並放入找到的結果陣列。接著，將陣列中的元素換成 HTML 的格式。再來宣告一個 Regex 物件，然後宣告兩個常數並各自以正規表示式判斷並取代(replace)原有的文字內容，改以 HTML 的方式呈現。 之後，透過 Template literals 的格式傳回一個&lt;li&gt;...&lt;/li&gt;。最後，使用 join() 將陣列中的所有元素以空字串為分隔，形成一個很長的字串再放入.suggestions的標籤中。 123456789101112131415function displayMatches()&#123; const matchArray = findMatches(this.value,cities); const html = matchArray.map(place =&gt;&#123; const regex = new RegExp(this.value, &#x27;gi&#x27;); const cityName = place.city.replace(regex,`&lt;span class=&quot;hl&quot;&gt;$&#123;this.value&#125;&lt;/span&gt;`); const stateName = place.state.replace(regex,`&lt;span class=&quot;hl&quot;&gt;$&#123;this.value&#125;&lt;/span&gt;`); return ` &lt;li&gt; &lt;span class=&quot;name&quot;&gt;$&#123;cityName&#125;, $&#123;stateName&#125;&lt;/span&gt; &lt;span class=&quot;ppulation&quot;&gt;$&#123;numberWithCommas(place.population)&#125;&lt;/span&gt; &lt;/li&gt; ` &#125;).join(&#x27;&#x27;); suggestions.innerHTML = html;&#125; 分別宣告常數 searchInput、suggestions 並取得 .search、.suggestions標籤。最後為搜尋欄(searchInput) 註冊change和keyup事件，當欄位數值發生改變或放開鍵盤的那個剎那都會觸發事件，兩個事件都是以 displayMatches() 進行事件處理。 12345const searchInput = document.querySelector(&#x27;.search&#x27;);const suggestions = document.querySelector(&#x27;.suggestions&#x27;);searchInput.addEventListener(&#x27;change&#x27;,displayMatches)searchInput.addEventListener(&#x27;keyup&#x27;,displayMatches); 補充資料: Promise 使用 Fetch Promise.prototype.then() Response.json() Spread syntax (…) RegExp() 比較 keydown, keypress, keyup 的差異 實際效果請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第5天","slug":"ironman2021D5","date":"2021-09-05T06:27:31.000Z","updated":"2022-03-13T17:22:35.061Z","comments":true,"path":"2021/09/05/ironman2021D5/","link":"","permalink":"https://qi-xiang.github.io/2021/09/05/ironman2021D5/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 利用 flexbox、transition 等 CSS 屬性，搭配 JS 監聽 transitionend、click 事件，最終實作出一個美觀的 Image Gallery。 解析程式碼 HTML 部分 由最外層的.panels包覆住內部的5個.panel所形成的一個巢狀結構。 123456789101112131415161718192021222324252627&lt;div class=&quot;panels&quot;&gt; &lt;div class=&quot;panel panel1&quot;&gt; &lt;p&gt;Hey&lt;/p&gt; &lt;p&gt;Let&#x27;s&lt;/p&gt; &lt;p&gt;Dance&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel panel2&quot;&gt; &lt;p&gt;Give&lt;/p&gt; &lt;p&gt;Take&lt;/p&gt; &lt;p&gt;Receive&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel panel3&quot;&gt; &lt;p&gt;Experience&lt;/p&gt; &lt;p&gt;It&lt;/p&gt; &lt;p&gt;Today&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel panel4&quot;&gt; &lt;p&gt;Give&lt;/p&gt; &lt;p&gt;All&lt;/p&gt; &lt;p&gt;You can&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel panel5&quot;&gt; &lt;p&gt;Life&lt;/p&gt; &lt;p&gt;In&lt;/p&gt; &lt;p&gt;Motion&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; CSS 部分 (僅說明影片中更動的部分) 先將最外層的 .panels 顯示類型設定為 flex，它同時也作為一個 flex-container 包覆住內部的五個 flex-items 也就是 .panel。 1234.panels &#123; /*其餘略過*/ display: flex;&#125; flex 是 flex-grow、flex-shrink、flex-basis 的簡寫，只有指定一個值給 flex 時，則代表設定的是 flex-grow，其餘屬性以預設值帶入。 flex-grow 可以指定 flex-container 的剩餘空間該如何分配，下面所有的 .panel 的 flex-grow 都是 1，也就是均勻分配剩餘空間。 接著，將每一個 .panel 的顯示類型都設定為 flex (此時的.panel 對下面的&lt;p&gt;&lt;/p&gt;來說就是 flex-container) 並將其下的 flex-item 在水平、鉛直方向都置中。 最後，設定 flex-direction 將 flex-box 的 main-axis 更改為直列。 1234567.panel &#123; flex: 1; /*將每個 flex-item 的大小都設為一樣並填滿*/ display: flex; justify-content: center; /*在水平方向置中*/ align-items: center;/*在鉛直方向置中*/ flex-direction: column; &#125; 將 .panel (flex-container)下的 &lt;p&gt;&lt;/p&gt; (flex-item) 的 flex 屬性設定為 1、0、auto，也就是均勻分配 flex-container 的剩餘空間、flex-item 長度超過 flex-container 時的收縮量設為 0、flex-item 在 flex container 的初始大小設為自動(auto)。 接著，也將&lt;p&gt;&lt;/p&gt;當作是一個 flex-container，設定顯示類型為 flex。透過 justify-content、align-items，將標籤內的文字(flex-item) 水平、鉛直置中排列。 1234567.panel &gt; * &#123; /*其餘省略*/ flex: 1 0 auto; display: flex; justify-content: center; align-items: center;&#125; 初始狀態，分別將在 .panel 上方和下方的 &lt;p&gt;&lt;/p&gt; 都各上移、下移 100% 以達到隱藏的效果。 123456.panel &gt; *:first-child&#123; transform: translateY(-100%);/*上移*/&#125;.panel &gt; *:last-child&#123; transform: translateY(100%);/*下移*/&#125; 接著設定當.panel上有open-active這個 class 時，就將原本隱藏的文字分別下移和上移顯示出來。 123456.panel.open-active &gt; *:first-child&#123; transform: translateY(0);&#125;.panel.open-active &gt; *:last-child&#123; transform: translateY(0);&#125; .panel開啟時，將內部文字放大為 40px 並將 flex-container 剩餘分配的位置變為原來的5倍。 1234.panel.open &#123; font-size: 40px; flex: 5;&#125; 補充資料: CSS flex 屬性 圖解 Flexbox 基本屬性 FLEXBOX FROGGY-學習 flexbox 的小遊戲 JS 部分 取得所有的.panel 並放到 NodeList 'panels' 中。 1const panels = document.querySelectorAll(&#x27;.panel&#x27;); 為 panels 中的每一個.panel都註冊兩個事件監聽器，當 click 或 transitionend 事件發生時，就分別以 toggleOpen 和 toggleActive 方法進行事件處理。 12panels.forEach(panel =&gt; panel.addEventListener(&#x27;click&#x27;,toggleOpen));panels.forEach(panel =&gt; panel.addEventListener(&#x27;transitionend&#x27;,toggleActive)); 點擊任意一個.panel，toggleOpen() 方法會替觸發事件的.panel依照情況的不同，新增或是移除.open 這個 class，若是觸發事件的.panel原本沒有.open則新增，有的話則移除.open。 當 transitionend 事件發生，toggleActive() 會作出如同 toggleOpen() 一樣的判斷，決定新增還是移除.open-active這個 class。因為同時會被觸發的 transitionend 事件有很多個，我們決定在觸發 transitionend 事件的 CSS 屬性是 flex 時，才採取處理。為什麼不寫 e.propertyName == 'flex-grow' 是因為在 Safari 顯示的是 flex 而 Chrome、FireFox 顯示的是 flex-grow，為避免這個差異導致錯誤，我們可以使用 include(‘flex’)，當 propertyName 含有 flex 就進行事件處理。 123456789function toggleOpen()&#123; this.classList.toggle(&#x27;open&#x27;);&#125;function toggleActive(e)&#123; if(e.propertyName.includes(&#x27;flex&#x27;))&#123; this.classList.toggle(&#x27;open-active&#x27;); &#125;&#125; 補充資料: Element.classList String.prototype.includes() 實際效果請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第4天","slug":"ironman2021D4","date":"2021-09-04T06:23:16.000Z","updated":"2022-03-13T17:22:32.670Z","comments":true,"path":"2021/09/04/ironman2021D4/","link":"","permalink":"https://qi-xiang.github.io/2021/09/04/ironman2021D4/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 練習一些 Array 常用的方法，包括 filter()、sort()、map()、reduce()。 解析程式碼 JS 部分 前七個練習題要使用的資料如下: 12345678910111213141516171819202122232425262728/*JS*/// Get your shorts on - this is an array workout!// ## Array Cardio Day 1// Some data we can work withconst inventors = [ &#123; first: &#x27;Albert&#x27;, last: &#x27;Einstein&#x27;, year: 1879, passed: 1955 &#125;, &#123; first: &#x27;Isaac&#x27;, last: &#x27;Newton&#x27;, year: 1643, passed: 1727 &#125;, &#123; first: &#x27;Galileo&#x27;, last: &#x27;Galilei&#x27;, year: 1564, passed: 1642 &#125;, &#123; first: &#x27;Marie&#x27;, last: &#x27;Curie&#x27;, year: 1867, passed: 1934 &#125;, &#123; first: &#x27;Johannes&#x27;, last: &#x27;Kepler&#x27;, year: 1571, passed: 1630 &#125;, &#123; first: &#x27;Nicolaus&#x27;, last: &#x27;Copernicus&#x27;, year: 1473, passed: 1543 &#125;, &#123; first: &#x27;Max&#x27;, last: &#x27;Planck&#x27;, year: 1858, passed: 1947 &#125;, &#123; first: &#x27;Katherine&#x27;, last: &#x27;Blodgett&#x27;, year: 1898, passed: 1979 &#125;, &#123; first: &#x27;Ada&#x27;, last: &#x27;Lovelace&#x27;, year: 1815, passed: 1852 &#125;, &#123; first: &#x27;Sarah E.&#x27;, last: &#x27;Goode&#x27;, year: 1855, passed: 1905 &#125;, &#123; first: &#x27;Lise&#x27;, last: &#x27;Meitner&#x27;, year: 1878, passed: 1968 &#125;, &#123; first: &#x27;Hanna&#x27;, last: &#x27;Hammarström&#x27;, year: 1829, passed: 1909 &#125;];const people = [ &#x27;Bernhard, Sandra&#x27;, &#x27;Bethea, Erin&#x27;, &#x27;Becker, Carl&#x27;, &#x27;Bentsen, Lloyd&#x27;, &#x27;Beckett, Samuel&#x27;, &#x27;Blake, William&#x27;, &#x27;Berger, Ric&#x27;, &#x27;Beddoes, Mick&#x27;, &#x27;Beethoven, Ludwig&#x27;, &#x27;Belloc, Hilaire&#x27;, &#x27;Begin, Menachem&#x27;, &#x27;Bellow, Saul&#x27;, &#x27;Benchley, Robert&#x27;, &#x27;Blair, Robert&#x27;, &#x27;Benenson, Peter&#x27;, &#x27;Benjamin, Walter&#x27;, &#x27;Berlin, Irving&#x27;, &#x27;Benn, Tony&#x27;, &#x27;Benson, Leana&#x27;, &#x27;Bent, Silas&#x27;, &#x27;Berle, Milton&#x27;, &#x27;Berry, Halle&#x27;, &#x27;Biko, Steve&#x27;, &#x27;Beck, Glenn&#x27;, &#x27;Bergman, Ingmar&#x27;, &#x27;Black, Elk&#x27;, &#x27;Berio, Luciano&#x27;, &#x27;Berne, Eric&#x27;, &#x27;Berra, Yogi&#x27;, &#x27;Berry, Wendell&#x27;, &#x27;Bevan, Aneurin&#x27;, &#x27;Ben-Gurion, David&#x27;, &#x27;Bevel, Ken&#x27;, &#x27;Biden, Joseph&#x27;, &#x27;Bennington, Chester&#x27;, &#x27;Bierce, Ambrose&#x27;, &#x27;Billings, Josh&#x27;, &#x27;Birrell, Augustine&#x27;, &#x27;Blair, Tony&#x27;, &#x27;Beecher, Henry&#x27;, &#x27;Biondo, Frank&#x27;]; 1. Filter the list of inventors for those who were born in the 1500’s Array.prototype.filter() filter() 方法會透過指定的函式運算，決定保留哪些資料並形成一個新的陣列。 在 filter 裡 return true 代表要保留該筆資料，除此之外的資料都會被捨棄，我們沒必要再寫 else 去 return false。 filter() 的詳細內容 以下我們透過 filter() 過濾&quot;出生於16世紀的發明家&quot; 123456/*JS*/const fifteen = inventors.filter(function(inventor)&#123; if(inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt; 1600)&#123; return true; //keep it in the new array &#125;&#125;)/*除了有回傳true之外的東西都會被丟掉，不必再用else return false*/ 更簡潔的寫法: console.table()，可以將 Array 以表格的形式呈現出來。 123/*JS*/const fifteen = inventors.filter(inventor =&gt; (inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt; 1600));console.table(fifteen); 2. Give us an array of the inventors first and last names Array.prototype.map() map() 方法會建立一個和原陣列長度相同的陣列，其內容為原陣列的每一個元素經由指定的函式運算後所回傳的結果之集合。 map() 的詳細內容 以下我們使用 map() 方法，將發明家的 first name 和 last name 結合在一起，形成一個新的陣列。 123/*JS*/const fullNames = inventors.map(inventor =&gt; `$&#123;inventor.first&#125; $&#123;inventor.last&#125;`); /*Template literals*/console.table(fullNames); 3. Sort the inventors by birthdate, oldest to youngest Array.prototype.sort() sort() 方法會對一個陣列中的所有元素進行排序，並回傳此陣列，預設是以字串的 Unicode 編碼進行排序。 我們也可以指定一個 compareFunction ，用自訂的排序規則為陣列進行排序。 compareFunction(a, b)，回傳值小於0時，a 會被排在 b 的前面，反之若回傳值大於0時，a 會被排在 b 的後面。 sort() 的詳細內容 以下我們使用 sort()，將較早出生的發明家排在前面的位置。 1234567const ordered = inventors.sort(function(a,b)&#123; if(a.year &gt; b.year)&#123; return 1; /*a 往後排*/ &#125;else&#123; return -1; /*a 往前排*/ &#125;&#125;) 更簡潔的寫法: 12const ordered = inventors.sort((a,b) =&gt; a.year &gt; b.year ? 1 : -1);console.table(ordered); 4. How many years did all the inventors live all together? Array.prototype.reduce() reduce() 方法將一個累加器(accumulator)及陣列中每項元素傳入函式中進行運算，將陣列化為單一的值。 其中一種用法如下: 123Array.reduce((accumulator,currentValue) =&gt; &#123; return accumulator + currentValue; &#125;,initialValue); /*initialValue 是 accumulator 的初始值*/ reduce() 的詳細內容 12345const totalYears = inventors.reduce((total,inventor)=&gt;&#123; return total + (inventor.passed - inventor.year);&#125;,0);console.log(totalYears); 5. Sort the inventors by years lived 以下，我們將這些發明家依照壽命的長短由大到小進行排序。 透過 passed - year，我們可以很簡單的算出每一位發明家的壽命。 1234567const oldest = inventors.sort(function(a,b)&#123; const lastGuy = a.passed - a.year; const nextGuy = b.passed - b.year; return lastGuy &gt; nextGuy ? -1 : 1;&#125;);console.table(oldest) 6. Create a list of Boulevards in Paris that contain ‘de’ anywhere in the name 這題我們需要自行到 https://en.wikipedia.org/wiki/Category:Boulevards_in_Paris 右鍵檢查進入 console 進行解題。 Node.textContent Node.textContent 可以取得節點或其後代的文字內容。 textContent 的詳細內容 Array.prototype.includes() includes() 方法會判斷陣列是否包含特定的元素，並以此來回傳 true 或 false。 includes() 的詳細內容 Array.from() Array.from() 方法會從類陣列（array-like，例如: NodeList）或是可迭代（iterable）物件建立一個新的 Array 實體。 from() 的詳細內容 首先，我們取得包覆所有巴黎大道名稱的最上層 div 標籤(.mw-category)。接著，取得在其之下的所有連結(a)。最後，使用 map() 方法以所有連結的內部文字組成新陣列並透過 filter() 過濾出包含(include)'de’的所有大道名稱。 123456const category = document.querySelector(&#x27;.mw-category&#x27;);const links = Array.from(category.querySelectorAll(&#x27;a&#x27;));/*NodeList*/const de = links.map(link =&gt; link.textContent).filter(streetName =&gt; streetName.includes(&#x27;de&#x27;));console.table(de); 7. Sort the people alphabetically by last name String.prototype.split() split()方法可以使用指定的分隔字元(separator)將一個String分割成串列。 split() 的詳細說明 以下，用, (逗號和空格)作為分隔字元將 first name、last name 切開並放入一個陣列中，接下來就可以依照 aLast、bLast 的 Unicode 進行 last name 的排序(由小到大)。 12345const alpha = people.sort(function(lastOne,firstOne)&#123; const [aLast,aFirst] = lastOne.split(&#x27;, &#x27;); const [bLast,bFirst] = firstOne.split(&#x27;, &#x27;); return aLast &gt; bLast ? 1 : -1;&#125;); 另一種寫法: 12345const alpha = people.sort((lastOne,firstOne) =&gt; &#123; const [aLast,aFirst] = lastOne.split(&#x27;, &#x27;); const [bLast,bFirst] = firstOne.split(&#x27;, &#x27;); return aLast &gt; bLast ? 1 : -1;&#125;); 8. Sum up the instances of each of these 資料內容: 1const data = [&#x27;car&#x27;, &#x27;car&#x27;, &#x27;truck&#x27;, &#x27;truck&#x27;, &#x27;bike&#x27;, &#x27;walk&#x27;, &#x27;car&#x27;, &#x27;van&#x27;, &#x27;bike&#x27;, &#x27;walk&#x27;, &#x27;car&#x27;, &#x27;van&#x27;, &#x27;car&#x27;, &#x27;truck&#x27; ]; 一開始賦予累加器(obj)的初始值(initial value)為空物件({})，因為最初所有的 item 都不存在於 obj 中，所以透過 if 判斷當 obj[item] 不存在時，就建立 obj[item] 並賦予初始值0。其後就可正常將 item 持續累加至正確的交通工具分類中(obj[item]++)。 123456789const transportation = data.reduce(function(obj,item)&#123; if(!obj[item])&#123; obj[item] = 0; &#125; obj[item]++; return obj;&#125;,&#123;&#125;)console.table(transportation);","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第3天","slug":"ironman2021D3","date":"2021-09-03T05:39:53.000Z","updated":"2022-03-13T17:22:30.638Z","comments":true,"path":"2021/09/03/ironman2021D3/","link":"","permalink":"https://qi-xiang.github.io/2021/09/03/ironman2021D3/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 學習建立 CSS 變數並透過 JavaScript 監聽 mousemove、change 事件，接著主動去更新變數的值，讓使用者得以調整圖片框的大小和背景色、圖片的模糊程度等等…。 解析程式碼 HTML 部分 由最外層的代表控制列(.controls)的div元素包覆住內部用來調整圖片的三個 input 元素(#spacing、#blur、#base)。其中兩個 input 元素上有設定 data- 屬性，標明使用的單位。 1234567891011121314&lt;h2&gt;Update CSS Variables with &lt;span class=&#x27;hl&#x27;&gt;JS&lt;/span&gt;&lt;/h2&gt;&lt;div class=&quot;controls&quot;&gt; &lt;label for=&quot;spacing&quot;&gt;Spacing:&lt;/label&gt; &lt;input id=&quot;spacing&quot; type=&quot;range&quot; name=&quot;spacing&quot; min=&quot;10&quot; max=&quot;200&quot; value=&quot;10&quot; data-sizing=&quot;px&quot;&gt; &lt;label for=&quot;blur&quot;&gt;Blur:&lt;/label&gt; &lt;input id=&quot;blur&quot; type=&quot;range&quot; name=&quot;blur&quot; min=&quot;0&quot; max=&quot;25&quot; value=&quot;10&quot; data-sizing=&quot;px&quot;&gt; &lt;label for=&quot;base&quot;&gt;Base Color&lt;/label&gt; &lt;input id=&quot;base&quot; type=&quot;color&quot; name=&quot;base&quot; value=&quot;#ffc600&quot;&gt;&lt;/div&gt;&lt;img src=&quot;https://source.unsplash.com/7bwQXzbF6KE/800x500&quot;&gt; CSS 部分 用--變數名稱的方式，宣告三個 CSS 的全域變數，並且是在根元素之下。 12345:root&#123; /*CSS 全域變數*/ --base: #ffc600; --spacing: 10px; --blur: 10px;&#125; 要使用 CSS 變數，我們可以利用var()並在裡面放入要使用的變數名稱。 123456789img&#123; padding: var(--spacing); /*使用關鍵字 var( )並在括號內填入想套用的變數名稱*/ background: var(--base); filter: blur(var(--blur)); /*套上帶有模糊效果的濾鏡*/&#125;.hl&#123; color: var(--base);&#125; 補充說明1: CSS 變數的補充資料 &gt;&gt;&gt; :root 根目錄選取器 - 叫你阿爸出來講 補充說明2: 使用 CSS 的 filter 屬性，主要目的是套一層濾鏡到圖片上，常見的值除了有 blur 以外，還有 contrast、grayscale 等等…。 詳細見此 JS部分 取得所有的 input 標籤，要注意的是這裡的資料型態是 NodeList 而不是 Array。 相較 Array 而言，NodeList 能用的方法少很多。 12/*JS*/const inputs = document.querySelectorAll(&#x27;.controls input&#x27;); /*取得所有的 input 元素，資料型態是 NodeList 不是 Array*/ 將每個取得的 input 標籤都分別註冊兩個事件監聽器，當 input 標籤的 value 屬性有變動(change)或是滑鼠有在 input 標籤的桿上移動時，就透過 handleUpdate() 方法進行事件處理。 123456function handleUpdate()&#123; &#125;inputs.forEach(input =&gt; input.addEventListener(&#x27;change&#x27;,handleUpdate)); /*當數值改變*/inputs.forEach(input =&gt; input.addEventListener(&#x27;mousemove&#x27;,handleUpdate)); /*當滑鼠移動*/ 在 handleUpdate() 方法內宣告 suffix 變數，透過 dataset.sizing 取得對應屬性的單位。當屬性沒有單位時，指定 suffix 為空字串，避免因為是 undefined 出現錯誤。 最後，藉著 document.documentElement.style 取得文件上&quot;根元素&quot;的 CSS 屬性，進一步使用 setProperty() 調整 CSS 屬性值(注意，有些屬性必須要加上單位)。 1234function handleUpdate()&#123; const suffix = this.dataset.sizing || &#x27;&#x27;; /*取得單位，當單位不存在時就指定為空字串*/ document.documentElement.style.setProperty(`--$&#123;this.name&#125;`,this.value + suffix); /*Template literals*/&#125; 補充說明1: NodeList 的補充資料 – JavaScript HTML DOM Node Lists 補充說明2: 透過 dataset 實際取得的 data-自訂名稱 屬性內容如下: 我們可以進一步使用 dataset.自訂名稱，取得裡面代表單位的&quot;px&quot;。 (圖片中的 sizing 等同於標籤上的 data-sizing) 實際效果請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第2天","slug":"ironman2021D2","date":"2021-09-02T05:29:18.000Z","updated":"2022-03-13T17:22:28.483Z","comments":true,"path":"2021/09/02/ironman2021D2/","link":"","permalink":"https://qi-xiang.github.io/2021/09/02/ironman2021D2/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 透過 JavaScript 的 Date 物件分別取得&quot;時&quot;、“分”、&quot;秒&quot;並計算出在圓上的相對應角度，最後搭配 CSS 的 transform 和 transition 屬性，製作出一個簡易的時鐘。 解析程式碼 HTML 部分 由最外層的&quot;clock&quot;部分包住內層的&quot;clock-face&quot;和其內部的&quot;時針&quot;、“分針”、“秒針”，形成一個完整的巢狀結構。 1234567&lt;div class=&quot;clock&quot;&gt; &lt;div class=&quot;clock-face&quot;&gt; &lt;div class=&quot;hand hour-hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hand min-hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hand second-hand&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS 部分 首先，將物件 transform 的基準點，更改為最右端。接著，將所有指針都預先固定在12點鐘方向。最後，透過 transition 屬性還有 transition-timing-function屬性，分別調整 CSS animation 效果變化速度和做出指針移動時的彈跳效果。 12345678910111213.hand &#123; width: 50%; height: 6px; background: black; position: absolute; top: 50%; /*以下是影片中教學的部分*/ transform-origin: 100%; /*改變 transform 的 x-axis*/ transform: rotate(90deg); /*初始位置從12點鐘出發*/ transition: all 0.05s; /*調整 CSS animation 變動的速度*/ transition-timing-function: cubic-bezier(0.1, 2.7, 0.58, 1);&#125; 補充說明1: transform 預設是以物件中心作為平移、旋轉、縮放、傾斜時的基準點。詳細內容見此 補充說明2: transition timing function，可用來定義轉場發生的時間曲線，以四個參數的貝茲曲線代表。詳細內容見此 JS 部分 首先，分別取得代表&quot;時針&quot;、“分針”、&quot;秒針&quot;的標籤。 1234/*JS*/const secondHand = document.querySelector(&#x27;.second-hand&#x27;);const minsHand = document.querySelector(&#x27;.min-hand&#x27;)const hourHand = document.querySelector(&#x27;.hour-hand&#x27;) 建立 Date 物件，取得&quot;時&quot;、“分”、&quot;秒&quot;的資料，以此算出所應旋轉的角度(注意，角度必須加上早先設定的90度，才會是正確的)，之後分別調整 CSS 的 transform 屬性。 最後用 setInterval() 方法，設定每1000毫秒(1秒)就執行 setDate() 方法一次，藉此動態改變 rotate 的值。 (時針、分針、秒針的原理都一樣，只是在角度計算上有所差異) 123456789101112/*JS*/function setDate()&#123; const now = new Date(); /*時針、分針、秒針的原理都一樣*/ const seconds = now.getSeconds(); const secondsDegrees = ((seconds/60)*360) + 90;/*旋轉的角度要加上預設的90度*/ secondHand.style.transform = `rotate($&#123;secondsDegrees&#125;deg)`;&#125; setInterval(setDate,1000) 分別設定完&quot;時針&quot;、“分針”、&quot;秒針&quot;後，setDate() 方法如下。 1234567891011121314151617/*JS*/function setDate()&#123; const now = new Date(); /*時針、分針、秒針的原理都一樣*/ const seconds = now.getSeconds() const secondsDegrees = ((seconds/60)*360) + 90;/*旋轉的角度要加上預設的90度*/ secondHand.style.transform = `rotate($&#123;secondsDegrees&#125;deg)`; const mins = now.getMinutes(); const minsDegrees = ((mins/60)*360) + 90; minsHand.style.transform = `rotate($&#123;minsDegrees&#125;deg)`; const hours = now.getHours(); const hoursDegrees = ((hours/12)*360) + 90; hourHand.style.transform = `rotate($&#123;hoursDegrees&#125;deg)`;&#125; 以上都完成後，一個簡單的時鐘就出現了。但仔細一看就會發現指針在某個時間點會突然倒轉一圈。 舉&quot;秒針&quot;為例，在59秒~0秒之間，數值上的角度會從444度變為90度(分針也是如此)，整整倒轉354度接近一圈，這就解釋了為什麼指針會有突然倒轉的現象。 而我們可以分別記錄時針和分針所走的圈數，並將原來計算出的度數加上360度*圈數，解決指針倒轉的問題。 用 if 判斷到 0 秒(分)時，就將圈數加1。 12345678910111213141516171819202122232425var secRound = 0; /*紀錄秒針所走圈數*/var minRound = 0; /*紀錄秒針所走圈數*/function setDate()&#123; const now = new Date(); /*時針、分針、秒針的原理都一樣*/ const seconds = now.getSeconds() if(seconds == 0)&#123;/*避免回彈*/ secRound += 1; &#125; const secondsDegrees = ((seconds/60)*360) + 360*secRound + 90;/*旋轉的角度要加上預設的90度*/ secondHand.style.transform = `rotate($&#123;secondsDegrees&#125;deg)`; const mins = now.getMinutes(); if(mins == 0)&#123;/*避免回彈*/ minRound += 1; &#125; const minsDegrees = ((mins/60)*360) + 360*minRound + 90; minsHand.style.transform = `rotate($&#123;minsDegrees&#125;deg)`; const hours = now.getHours(); const hoursDegrees = ((hours/12)*360) + 90; hourHand.style.transform = `rotate($&#123;hoursDegrees&#125;deg)`;&#125; 最後的最後，我們還可以讓指針的位置更加精準。一般而言，秒針每走一格，分針應該跟著移動一點，同理時針也是如此。 對分針而言移動每過一分鐘移動6度，我們可以用 (秒數/60)*6，算出實際上每過一秒鐘，分針應該要跟著移動多少度。 對時針而言移動每過一小時移動30度，我們可以用 (分鐘數/60)*30，算出實際上每過一分鐘，時針應該要跟著移動多少度。 12345678910const mins = now.getMinutes();if(mins == 0)&#123;/*避免回彈*/ minRound += 1;&#125;const minsDegrees = ((mins/60)*360) + 360*minRound + ((seconds/60)*6) + 90;minsHand.style.transform = `rotate($&#123;minsDegrees&#125;deg)`;const hours = now.getHours();const hoursDegrees = ((hours/12)*360) + ((mins/60)*30) + 90;hourHand.style.transform = `rotate($&#123;hoursDegrees&#125;deg)`; 補充說明1: rotate($&#123;hoursDegrees&#125;deg) 是 ES6 Template literals 的寫法。詳細介紹 Template literals 範例網頁請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第1天","slug":"ironman2021D1","date":"2021-08-31T16:20:35.000Z","updated":"2022-03-13T17:22:26.495Z","comments":true,"path":"2021/09/01/ironman2021D1/","link":"","permalink":"https://qi-xiang.github.io/2021/09/01/ironman2021D1/","excerpt":"","text":"前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 本日目標 透過監聽 “transitionend 事件” 和 “keydown 事件”，調整 CSS 設定以及播放音效，最終建立一組爵士鼓並依照按下按鍵的不同播放不同的音效伴隨網頁上的 CSS 動畫效果。 解析程式碼 HTML 部分 基本結構是由最外層的 “keys” 包住內層9個 “key” 的巢狀結構，內層的 “key” 都有 data-key 屬性並有相異的數值，這些相異值在接下來判斷要播放哪個音檔和套用 CSS 設定到哪個 “key” 時很重要。 1234567891011121314151617181920212223242526272829303132333435363738&lt;div class=&quot;keys&quot;&gt; &lt;div data-key=&quot;65&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;A&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;clap&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;83&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;S&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;hihat&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;68&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;D&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;kick&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;70&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;F&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;openhat&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;71&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;G&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;boom&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;72&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;H&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;ride&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;74&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;J&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;snare&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;75&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;K&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;tom&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;76&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;L&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;tink&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 補充說明1: HTML5 新增了 data-* 自定義屬性(data attributes)，讓我們能以 data- 為開頭，建立自訂的屬性和值並隨時可以讀寫在元素上的資料數值，而不會影響到整個版面。 程式碼中的 data-key 就是一個不錯的例子。 補充說明2: &lt;kbd&gt; 是一個行內元素 (inline element) ，用來標示鍵盤符號。 JS 部分 首先，我們先依照按下按鍵的 keyCode 取得特定的音檔和 div 標籤。 12345/*JS*/window.addEventListener(&quot;keydown&quot;,function()&#123; const audio = document.querySelector(`audio[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); const key = document.querySelector(`.key[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`);&#125;) 因為實際上會有作用的按鍵只有9個，按到沒作用的按鍵時，理論上我們應該要終止執行方法避免錯誤，所以新增 if 判斷是否成功取得音檔，沒有取得就終止方法的執行。 123456/*JS*/window.addEventListener(&quot;keydown&quot;,function()&#123; const audio = document.querySelector(`audio[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); const key = document.querySelector(`.key[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); if(!audio)return; /*如果keyCode不存在則中止執行方法*/&#125;) 接著是播放音檔的部分，如果只單用 audio.play()的話，則在連續按下同一按鍵時，會出現聲音不連貫的效果，此時需要將每次播放音檔的時間軸都設為0，讓每次播放都是從頭開始。 123456789/*JS*/window.addEventListener(&quot;keydown&quot;,function()&#123; const audio = document.querySelector(`audio[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); const key = document.querySelector(`.key[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); if(!audio)return; /*如果keyCode不存在則中止執行方法*/ audio.currentTime = 0; /*確保每一次按下鍵盤都從頭播放音檔*/ audio.play(); /*播放音檔*/&#125;) 最後處理 CSS 的動畫效果，我們會套用 .playing 的 CSS 設定到播放音檔的 div 標籤上。 123456/*CSS*/.playing &#123; transform: scale(1.1); /*讓 div 標籤變大1.1倍*/ border-color: #ffc600; /*改變 border 的顏色*/ box-shadow: 0 0 1rem #ffc600; /*產生陰影*/&#125; 1234567891011/*JS*/window.addEventListener(&quot;keydown&quot;,function()&#123; const audio = document.querySelector(`audio[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); const key = document.querySelector(`.key[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); if(!audio)return; /*如果keyCode不存在則中止執行方法*/ audio.currentTime = 0; /*確保每一次按下鍵盤都從頭播放音檔*/ audio.play(); /*播放音檔*/ key.classList.add(&#x27;playing&#x27;);&#125;) 一定時間後，我們必須拿掉 .playing 的 CSS 設定，讓 div 標籤回到未被按鍵觸發的狀態。因此我們可以在每個 key 上都註冊 “transitionend 事件” 的監聽器，並用 removeTransition() 處理該事件。 123456789/*JS*/function removeTransition(e)&#123; this.classList.remove(&#x27;playing&#x27;);&#125;/*取得所有的 key 標籤*/const keys = document.querySelectorAll(`.key`);/*在每個 key 上都註冊 &quot;transitionend 事件&quot; 的監聽器*/keys.forEach(key =&gt; key.addEventListener(&#x27;transitionend&#x27;,removeTransition)); 到這裡基本上就完成了，但是如果把 removeTransition() 的 “transitionend 事件” 印到 console，可以發現 “transitionend 事件” 不只有一個。 我們可以選擇以 transform 結束觸發的那個 “transitionend 事件”，作為移除 CSS 設定的時機點。 123456/*JS*//*當transform完成就移除.playing*/function removeTransition(e)&#123; if(e.propertyName != &#x27;transform&#x27;) return; this.classList.remove(&#x27;playing&#x27;);&#125; 整理後的完整JS如下: 1234567891011121314151617181920/*JS*/function playSound(e)&#123; const audio = document.querySelector(`audio[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); const key = document.querySelector(`.key[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); if(!audio)return; /*如果keyCode不存在則中止執行方法*/ audio.currentTime = 0; /*確保每一次按下鍵盤都從頭播放音檔*/ audio.play(); /*播放音檔*/ key.classList.add(&#x27;playing&#x27;); &#125; /*當transform完成就移除.playing*/function removeTransition(e)&#123; if(e.propertyName != &#x27;transform&#x27;) return; this.classList.remove(&#x27;playing&#x27;);&#125;const keys = document.querySelectorAll(`.key`);keys.forEach(key =&gt; key.addEventListener(&#x27;transitionend&#x27;,removeTransition));window.addEventListener(&quot;keydown&quot;,playSound) 補充說明: 上面 `.key` 的用法是 JavaScript ES6 中新增的模版字符串（template literals)。 在過去我們需要用以下寫法在JS 的字串中放入 HTML 內容: 1234567/*JS*/let component_es5 = &#x27;&lt;header&gt;\\n&#x27;+&#x27;&lt;div class=&quot;banner&quot;&gt;\\n&#x27;+&#x27;&lt;img src=&quot;img1.jpg&quot;\\n&#x27;+&#x27;&lt;/div&gt;\\n&#x27;+&#x27;&lt;/header&gt;&#x27; 上面的寫法相當冗長，而且不具備閱讀性。在 ES6 中我們可以用反引號快速的解決這樣的狀況： 12345678/*JS*/let component_es6 = `&lt;header&gt; &lt;div class=&#x27;banner&#x27;&gt; &lt;img src=&quot;img1.jpg&gt; &lt;/div&gt;&lt;/header&gt;` – 資料來源: [筆記] JavaScript ES6 中的模版字符串（template literals）和標籤模版（tagged template） 實際效果請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"金魚也能學會寫網頁-基本版面設計、盒子模型","slug":"金魚也能學會寫網頁-基本版面設計、盒子模型","date":"2021-08-18T16:25:21.000Z","updated":"2022-03-13T17:26:21.326Z","comments":true,"path":"2021/08/19/金魚也能學會寫網頁-基本版面設計、盒子模型/","link":"","permalink":"https://qi-xiang.github.io/2021/08/19/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81-%E5%9F%BA%E6%9C%AC%E7%89%88%E9%9D%A2%E8%A8%AD%E8%A8%88%E3%80%81%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"一開始只是興趣使然，寫了一篇關於網頁框架的簡單筆記，不過幾經思考後，還是想把它寫成網頁相關的系列筆記，希望在忘了一些東西時，能有個地方可以快速找回記憶。☺️ 💡 Hint: 以下筆記內容所使用的作業系統為&quot;Windows 10&quot; 📝 float 的基本概念 float 在 CSS 中是最基本的版面設計技巧，不瞭解 float 的話，就很難利用 CSS 來進行版面的規劃設計。 不設定 float (預設) 網頁中的每個區塊會由上往下顯示。 設定 float: left; 原本區塊會由上往下顯示，設定後會變成由左往右排列顯示。 設定 float 的區塊通常都要指定 width，若是 width 不足，超過的部分會被強制放到下一行，造成版面錯置。 設定 float: right; 原本區塊會由上往下顯示，設定後會變成由右往左排列顯示，原始碼最上方的區塊會排在最右邊。 解除&quot;文繞圖&quot; 只有部分區塊有設定 float 時，在 float 區塊的後續元素可能會因為上方還有空間硬擠上來，產生&quot;文繞圖&quot;的效果。 在 float 之後的區塊上加上 clear 屬性，就可以解除文繞圖回復預設由上往下排列顯示。 基本上 float 和 clear 會被當作一組成對的指令。 版面設計實例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;網頁標題&lt;/h1&gt; &lt;div&gt; &lt;div class=&quot;box&quot;&gt; &lt;img class=&quot;picture&quot; src=&quot;https://picsum.photos/seed/157/500/300&quot; alt=&quot;&quot;&gt; &lt;dl class=&quot;data&quot;&gt; &lt;dt&gt;地點:&lt;/dt&gt; &lt;dd&gt;說明文字&lt;/dd&gt; &lt;dt&gt;簡介:&lt;/dt&gt; &lt;dd&gt;說明文字&lt;/dd&gt; &lt;/dl&gt; &lt;img class=&quot;picture&quot; src=&quot;https://picsum.photos/seed/111/500/300&quot; alt=&quot;&quot;&gt; &lt;dl class=&quot;data&quot;&gt; &lt;dt&gt;地點:&lt;/dt&gt; &lt;dd&gt;說明文字&lt;/dd&gt; &lt;dt&gt;簡介:&lt;/dt&gt; &lt;dd&gt;說明文字&lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;/div&gt; &lt;style&gt; body&#123; background-color: #fff6e6; &#125; h1&#123; text-align: center; margin-bottom: 30px; &#125; .box&#123; width: 960px; &#125; .picture&#123; float: left; margin-bottom: 30px; margin-right: 30px; &#125; .data&#123; float: left; &#125; dt&#123; clear: left; float: left; &#125; &lt;/style&gt;&lt;/body&gt;&lt;/html&gt; 盒子模型 (box model) 定義: The CSS box model describes the rectangular boxes that are generated for elements in the document tree and laid out according to the visual formatting model. 簡單來說平常寫的&lt;p&gt;lorem...&lt;/p&gt;，就可以看做是一個Box，而Box Model則規範Box在瀏覽器上的長相。 盒子模型的 width/height、margin、border、pading 等屬性值間的關係，共同構成了所謂的盒子模型。 熟悉盒子模型的概念後，才有辦法進一步規劃、計算整個版面的尺寸。 盒子模型概念圖 width/height: 內容顯示區域(content-box)的寬、高 boder: 邊框 margin: 外部間距 padding: 內部間距 實際上眼睛所見寬度 = border + padding + width 實際上眼睛所見高度 = border + padding + height 💡 Hint: 當 padding 或 border 兩者有其中一個不是 0 時，width 和 height 值就不會是實際上眼睛所看到的寬、高。","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"金魚也能學會寫網頁","slug":"金魚也能學會寫網頁","permalink":"https://qi-xiang.github.io/tags/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81/"}]},{"title":"金魚也能學會寫網頁-CSS超入門","slug":"金魚也能學會寫網頁-CSS超入門","date":"2021-08-18T04:10:00.000Z","updated":"2022-03-13T17:26:02.245Z","comments":true,"path":"2021/08/18/金魚也能學會寫網頁-CSS超入門/","link":"","permalink":"https://qi-xiang.github.io/2021/08/18/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81-CSS%E8%B6%85%E5%85%A5%E9%96%80/","excerpt":"","text":"一開始只是興趣使然，寫了一篇關於網頁框架的簡單筆記，不過幾經思考後，還是想把它寫成網頁相關的系列筆記，希望在忘了一些東西時，能有個地方可以快速找回記憶。☺️ 💡 Hint: 以下筆記內容所使用的作業系統為&quot;Windows 10&quot; 📝 簡單介紹 CSS CSS (Cascading Style Sheets) 是用來美化網頁，進行版面設計的語言。 HTML 與 CSS 的關係，就像大樓的骨架與內部裝潢或外牆設計的關係。 📓 如何在 HTML 中使用 CSS 在行內(inline)套用 直接在 HTML 的元素標籤上，利用 style 屬性指定 CSS。 這種方法最直覺，但原則上 HTML 程式碼是用來表示結構，不應混入負責視覺設計的 CSS。 除了用於測試外，不建議用這種方法。 1&lt;h1 style=&quot;color:red;&quot;&gt;標題&lt;/h1&gt; 在內部載入 在 HTML 的 head 元素中，利用 style 元素將 CSS 寫在其中。 雖然這種作法，可以將 HTML 原始碼與 CSS 的內容區隔開，但寫在 head 中的 CSS 卻也只能用在這個網頁上。 一般而言，也建議少用這種方式。 12345&lt;head&gt; &lt;style&gt; h1&#123;color: red;&#125; &lt;/style&gt;&lt;/head&gt; 從外部載入 將 CSS 程式碼統一放到一個外部檔案中(檔名.css)內，再到 HTML 內載入這個檔案。 在 HTML 中可以使用 link 元素或 @import 這二種方式載入。一般而言，常使用 link 元素。 123&lt;head&gt; &lt;link href=&quot;外部 CSS檔案的路徑&quot; rel=&quot;stylesheet&quot; media=&quot;all&quot;&gt;&lt;/head&gt; 或是 12345&lt;head&gt; &lt;style&gt; @import url(外部 CSS檔案的路徑); &lt;/style&gt;&lt;/head&gt; 📓 把 CSS 放到外部檔案的優點 多個網頁可以共用同一個 CSS。 將 CSS 全部放到外部檔案統一管理，就算有很多網頁，也只需要維護一個 CSS 檔案就好。 不過，具有一定規模的網站，通常 CSS 檔案都很大，若是都放在同一個檔案內，恐怕會難以管理。這個時候，可以依據需求再去切分成更細的多個 CSS 檔案。 💡 Hint: 但把 CSS 檔案切的太細，造成網頁需要同時用到多個 CSS 檔案的情況，可能會造成網頁加載時間變長。&quot; 📝 CSS 的寫法 CSS 的寫法非常單純，由它決定 HTML 中的「哪一區塊」的「哪個屬性」要「怎麼顯示」。 試著指定文字顏色 在 CSS 中設定顏色時，通常以十六進位表示。十六進位的 RGB 值本身不分大小寫，當1/3/5和2/4/6碼兩兩成對相同，可以改用3碼的方式設定。 以 #FF0000為例，用 #FF0000、#ff0000、#F00、#f00 的寫法都會是一樣的效果。 1&lt;h1 style=&quot;color:#FF0000;&quot;&gt;標題&lt;/h1&gt; 📝 CSS 中使用的單位 相對單位 單位 說明 px 將螢幕畫素視為1的單位 % 以百分比設定比例 em 將大寫 M 在文件上顯示的高度當作 1em ex 將小寫 x 在文件上顯示的高度當作 1ex 絕對單位 單位 說明 pt 以 1 point (1/72吋)視為1的單位 pc 以 1 picas (12 pt)視為1的單位 mm 以公厘為單位 cm 以公分為單位 in 以英吋(2.54公分)為單位","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"金魚也能學會寫網頁","slug":"金魚也能學會寫網頁","permalink":"https://qi-xiang.github.io/tags/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81/"}]},{"title":"Python 學習日記 EP 7 - 正規表示式","slug":"正規表示式","date":"2021-08-17T17:30:00.000Z","updated":"2022-03-13T17:27:00.761Z","comments":true,"path":"2021/08/18/正規表示式/","link":"","permalink":"https://qi-xiang.github.io/2021/08/18/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%A4%BA%E5%BC%8F/","excerpt":"","text":"參考書目: Python自動化的樂趣: 搞定重複瑣碎&amp;單調無聊的工作 📝 正規表示式 正規表示式(Regular Expression，Regex)，它能夠指定某種模式來進行比對搜尋。 使用正規表示式能節省很多時間，不僅是軟體的使用者連程式設計者也適用。 📓 建立 Regex 物件 Python 中所有正規表示式的函式都在 re 模組內。 1import re 呼叫 compile() 方法並傳入代表正規表示式的字串值，會回傳一個 Regex 模式物件，也就是 Regex 物件。 123456789import re#不用原始字串型態phoneNumRegex = re.compile(&#x27;\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d&#x27;)#使用原始字串型態phoneNumRegex = re.compile(r&#x27;\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d&#x27;)print(type(phoneNumRegex)) :::info 💡 Hint: 推薦使用&quot;原始字串&quot;型態的正規表示式會比較簡潔。 ::: 📓 比對 Regex 物件 Regex 物件的 search() 方法，可以傳入要尋找的字串，搜尋比對符合正規表示式的內容。若沒有找到符合的字串內容則回傳 None，反之有找到的話，則回傳一個 Match 物件。 Match 物件有 group() 方法，可以回傳實際符合比對的字串。 123456789101112import re#使用原始字串型態phoneNumRegex = re.compile(r&#x27;\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d&#x27;)#有找到符合字串result = phoneNumRegex.search(&#x27;Phone: 09-12345678&#x27;)print(&#x27;Phone number found: &#x27;+result.group())#沒找到符合字串result = phoneNumRegex.search(&#x27;Phone: 09-1234567&#x27;)print(&#x27;Phone number found: &#x27;+str(result)) 📓 重點回顧 先 import re 匯入正規表示模組 呼叫 compile() 方法，建立 Regex 物件 (推薦使用原始字串) 呼叫 Regex 物件的 search() 方法傳入想要比對的字串，回傳 Match 物件或 None 值 呼叫 Match 物件的 group() 方法，回傳比對符合的字串 📝 活用正規表示式 📓 利用括號分組 正規表示式字串內的第1對括號為第一組並以此類推。將不同整數傳入 group() 方法，可取得特定的分組。 對 group() 傳入 0 或不傳的話，則回傳整個比對符合的字串。 123456789101112131415import re#使用原始字串型態phoneNumRegex = re.compile(r&#x27;(\\d\\d)-(\\d\\d\\d\\d\\d\\d\\d\\d)&#x27;)#找到符合字串result = phoneNumRegex.search(&#x27;Phone: 09-12345678&#x27;)print(&#x27;Phone number found: &#x27;+result.group())print(&#x27;Phone number found: &#x27;+result.group(0))print(&#x27;Phone number found: &#x27;+result.group(1))print(&#x27;Phone number found: &#x27;+result.group(2)) 想要一次取得所有分組，可以呼叫 groups() 方法，以多元組型態回傳。 123456789import re#使用原始字串型態phoneNumRegex = re.compile(r&#x27;(\\d\\d)-(\\d\\d\\d\\d\\d\\d\\d\\d)&#x27;)#找到符合字串result = phoneNumRegex.search(&#x27;Phone: 09-12345678&#x27;)print(result.groups()) 由於括號在正規表示式中有特殊意義，若想比對括號可用轉義字元的方式，例如:\\(、\\)。 12345678910111213import re#使用原始字串型態phoneNumRegex = re.compile(r&#x27;(\\(\\d\\d\\))-(\\d\\d\\d\\d\\d\\d\\d\\d)&#x27;)#找到符合字串result = phoneNumRegex.search(&#x27;Phone: (09)-12345678&#x27;)print(&#x27;Phone number found: &#x27;+result.group())print(&#x27;Phone number found: &#x27;+result.group(1))print(&#x27;Phone number found: &#x27;+result.group(2)) 📓 管道比對多個分組 想要進行多個表示式的比對時，可以利用|作為區隔。例如: 正規表示式的 r'Bat|Spider'，會同時比對字串中是否有’Bat’或’Spider’，第一次比對符合的文字以 Match 物件型態回傳。 由於管道字元在正規表示式中有特殊意義，若想比對可用轉義字元的方式，例如:\\|。 123456789import retextRegex = re.compile(r&#x27;Bat|Spider&#x27;)result = textRegex.search(&#x27;Bat and Spider&#x27;)print(result.group())textRegex = re.compile(r&#x27;Bat|Spider&#x27;)result = textRegex.search(&#x27;Spider and Bat&#x27;)#交換順序print(result.group()) 123456import retextRegex = re.compile(r&#x27;(One|Two|Three) Fish&#x27;)result = textRegex.search(&#x27;Lura has One Fish.&#x27;)print(result.group(1))print(result.group()) 📓 可選擇性比對 (?) 要比對的內容是選擇性時，可在括號分組後面加上問號(?)，表示該內容出現與否都不影響正規比對結果。 可以把問號字元看成該分組可以出現1次或0次。 由於?在正規表示式中有特殊意義，若想比對可用轉義字元的方式，例如:\\?。 12345678import retextRegex = re.compile(r&#x27;(One|Two|Three)? Fish&#x27;)result = textRegex.search(&#x27; Fish.&#x27;)print(result.group())result = textRegex.search(&#x27;Lura has One Fish.&#x27;)print(result.group()) 📓 符合 0 次或多次 (*) 星號前面的分組可以出現任意次。 由於*在正規表示式中有特殊意義，若想比對可用轉義字元的方式，例如:\\*。 1234567891011import retextRegex = re.compile(r&#x27;(One|Two|Three)* Fish&#x27;)result = textRegex.search(&#x27; Fish.&#x27;)print(result.group())result = textRegex.search(&#x27;Lura has OneOneOne Fish.&#x27;)print(result.group())result = textRegex.search(&#x27;Lura has OneTwoOne Fish.&#x27;)print(result.group()) 📓 符合 1 次或多次 (+) 加號之前的分組一定要至少出現1次以上。 由於+在正規表示式中有特殊意義，若想比對可用轉義字元的方式，例如:\\+。 1234567891011import retextRegex = re.compile(r&#x27;(One|Two|Three)+ Fish&#x27;)result = textRegex.search(&#x27; Fish.&#x27;)print(result == None)result = textRegex.search(&#x27;Lura has OneOneOne Fish.&#x27;)print(result.group())result = textRegex.search(&#x27;Lura has OneTwoOne Fish.&#x27;)print(result.group()) 📓 指定出現次數 ({ }) 大括號可放在分組之後，用來指定該分組能夠出現幾次。 例如: (Hello){3}，表示分組可以出現3次 (Hello){3,5}，表示分組可以出現3~5次 (Hello){3,}，表示分組可以出現3次以上 (Hello){，5}，表示分組可以出現5次以下 12345678import retextRegex = re.compile(r&#x27;(Big)&#123;3&#125; Fish&#x27;)result = textRegex.search(&#x27;BigBigBig Fish.&#x27;)print(result.group())result = textRegex.search(&#x27;BigBig Fish.&#x27;)print(result == None) # return True 📓 貪婪/非貪婪 比對 比對(Hello){3,5}時，Python 會自動回傳找到的最長符合字串(貪婪比對)，也就是說 Hello 出現5次，Python 不會回傳5次以外的結果。但是若是想要找到最短的符合結果(非貪婪比對)，則可以在大括號之後加上問號。 123456789import retextRegex = re.compile(r&#x27;(Hello)&#123;3,5&#125;&#x27;)result = textRegex.search(&#x27;HelloHelloHelloHelloHello&#x27;)print(result.group())textRegex = re.compile(r&#x27;(Hello)&#123;3,5&#125;?&#x27;)result = textRegex.search(&#x27;HelloHelloHelloHelloHello&#x27;)print(result.group()) 📓 findall() 方法 Regex 物件本身還有一個 findall() 方法。findall() 方法不同於 search() 方法，它會返回一組字串串列，這個串列裡會放入所有比對符合的文字內容。 123456789import re#使用原始字串型態phoneNumRegex = re.compile(r&#x27;\\(\\d\\d\\)-\\d\\d\\d\\d\\d\\d\\d\\d&#x27;)#找到符合字串result = phoneNumRegex.findall(&#x27;Phone: (09)-12345678&#x27;)print(result) 若在正規表示式中有分組，則 findall() 返回的會是多元組串列。 123456789import re#使用原始字串型態phoneNumRegex = re.compile(r&#x27;(\\(\\d\\d\\))-(\\d\\d\\d\\d\\d\\d\\d\\d)&#x27;)#找到符合字串result = phoneNumRegex.findall(&#x27;Phone: (09)-12345678&#x27;)print(&#x27;Phone number found: &#x27;+result.group()) 📝 字元分類 字元分類對於縮短正規表示式很有幫助。 字元分類 表示 \\d 0~9的任何數字 \\D 除了0~9的數字之外的字元 \\w 任何字母、數字或底線字元 \\W 除了字母、數字或底線字元之外的字元 \\s 空格、定位符號或換行符號 \\S 除了空格、定位符號或換行符號之外的字元 📝 建立自己的字元分類 可以用中括號來定義自己的字元分類，也可利用聯字符號(-)指定字母或數字的範圍。 例如: [a-zA-Z0-9] 會去比對找出所有的大小寫字母還有數字。 1234567891011import retextRegex = re.compile(r&#x27;[a-zA-Z0-9]&#x27;)result = textRegex.search(&#x27;Where can I find the answer for the world?&#x27;) print(result.group())result = textRegex.findall(&#x27;Where can I find the answer for the world?&#x27;)print(result) 在字元分類的左側中括號後插入^符號，表示要取得相反的字元分類，也就是不在字元分類內的內容。 1234567import retextRegex = re.compile(r&#x27;[^a-zA-Z0-9]&#x27;)result = textRegex.findall(&#x27;Where can I find the answer for the world?&#x27;)print(result) 📝 ^與$字元 在正規表示式的起始處加上^，表示字串必須以^後的字串作為開頭才能符合比對。 12345678910import retextRegex = re.compile(r&#x27;^Hello&#x27;)result = textRegex.search(&#x27;Hello, Kevin.&#x27;)print(result.group())result = textRegex.search(&#x27;hello, Kevin.&#x27;)print(result == None) 在正規表示式的結尾處加上$，表示字串必須以$前的字串作為結尾才能符合比對。 12345678910111213141516import retextRegex = re.compile(r&#x27;\\d$&#x27;)result = textRegex.search(&#x27;3.141592653&#x27;)![](https://i.imgur.com/Z5Oqj9j.png)![](https://i.imgur.com/GFsm0kU.png)![](https://i.imgur.com/vKJBHrx.png)![](https://i.imgur.com/0jPIeLS.png)![](https://i.imgur.com/sDzIq6T.png)![](https://i.imgur.com/VjtZIJJ.png)print(result.group())result = textRegex.search(&#x27;3.141592653s&#x27;)print(result == None) 同時使用兩者則字串必須符合特定的開頭和結尾才能符合比對。 12345678910import retextRegex = re.compile(r&#x27;^\\d\\.\\d+\\w$&#x27;)result = textRegex.search(&#x27;3.141592653s&#x27;)print(result.group())result = textRegex.search(&#x27;3.141592653 &#x27;)print(result == None) 📝 萬用字元 在正規表示式中句點(.)稱為萬用字元(wildcard)，可尋找比對除了換行符號之外的字元。 句點字元在比對時，對應的是一個字元。 由於.在正規表示式中有特殊意義，若想比對可用轉義字元的方式，例如:\\.。 12345import re textRegex = re.compile(r&#x27;.at&#x27;)result = textRegex.findall(&#x27;The cat in the hat sat on the flat mat.&#x27;)print(result) 📓 .*比對所有字元 .*預設是使用貪婪比對，也就是找出最長的符合字串。使用 .*?則可以切換成非貪婪比對。 12345import re textRegex = re.compile(r&#x27;First: (.*) Second: (.*)&#x27;)result = textRegex.search(&#x27;First: Fried Chicken Second: Burger&#x27;)print(result.group()) 123456789import re textRegex = re.compile(r&#x27;&lt;.*&gt;&#x27;)result = textRegex.search(&#x27;&lt;Harry Potter&gt; Rowling, J. K.&gt;&#x27;)print(result.group())textRegex = re.compile(r&#x27;&lt;.*?&gt;&#x27;)result = textRegex.search(&#x27;&lt;Harry Potter&gt; Rowling, J. K.&gt;&#x27;)print(result.group()) 📓 .字元找出換行符號 .*會找出除了換行字元以外的字元，若連換行字元也要納入比對，則可在 compile() 方法內傳入 re.DOTALL 引數，這樣在比對時，所有字元都會符合比對。 123456789import re textRegex = re.compile(&#x27;.*&#x27;)result = textRegex.search(&#x27;First: Fried Chicken\\nSecond: Burger&#x27;)print(result.group())textRegex = re.compile(&#x27;.*&#x27;,re.DOTALL)result = textRegex.search(&#x27;First: Fried Chicken\\nSecond: Burger&#x27;)print(result.group()) 📝 不區分大小寫的比對 如果只在意比對的字母，而不在意大小寫，可以在 compile() 方法傳入 re.IGNORECASE 或 re.I。 12345678import re textRegex = re.compile(r&#x27;Hello&#x27;,re.I)result = textRegex.search(&#x27;HeLLO&#x27;)print(result.group())result = textRegex.search(&#x27;hElLo&#x27;)print(result.group()) 📝 取代比對符合的字串 透過 Regex 物件的 sub() 方法，正規表示式除了可以比對找出文字，也能用新的文字取代符合比對的文字。 sub() 方法要傳入2個引數，第1個是用來取代找出的文字，第2個引數是要進行比對的字串。 sub() 方法會回傳取代之後的完整字串。 12345import re textRegex = re.compile(r&#x27;Hello&#x27;)result = textRegex.sub(&#x27;Hey&#x27;,&#x27;Hello, Kevin&#x27;)print(result) 📝 處理複雜的正規表示式 如果要比對的正規表示式很長、複雜、難懂，可以考慮在正規表示式中加入空白和註解，在 compile() 方法傳入 re.VERBOSE，空白和註解就會被忽略。 用三個單引號(‘’')可以建立多行式字串。 123456789101112import re textRegex = re.compile(r&#x27;((\\d&#123;3&#125;|\\(\\d&#123;3&#125;\\))?(\\s|-|\\.)?\\d&#123;3&#125;(\\s|-|\\.)?\\d&#123;4&#125;(\\s*(ext|x|ext.)\\s*\\d&#123;2,5&#125;)?)&#x27;)textRegex = re.compile(r&#x27;&#x27;&#x27; (\\d&#123;3&#125;|\\(\\d&#123;3&#125;\\))? # area code (\\s|-|\\.)? # separator \\d&#123;3&#125; # first 3 digits (\\s|-|\\.) # separator \\d&#123;4&#125; # last 4 digits (\\s*(ext|x|ext.)\\s*\\d&#123;2,5&#125;)? # extension&#x27;&#x27;&#x27;,re.VERBOSE) 📝 傳入複數參數到compile()方法 compile() 方法只能接受1個值作為第2個參數，但透過管道字元(|)可以解決這個問題。 123import re textRegex = re.compile(r&#x27;Hello&#x27;,re.I | re.DOTALL | re.VERBOSE)","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Python 學習日記","slug":"Python-學習日記","permalink":"https://qi-xiang.github.io/tags/Python-%E5%AD%B8%E7%BF%92%E6%97%A5%E8%A8%98/"}]},{"title":"Python 學習日記 EP 6 - 字串的操作","slug":"字串的操作","date":"2021-08-14T16:20:00.000Z","updated":"2022-03-13T17:26:58.198Z","comments":true,"path":"2021/08/15/字串的操作/","link":"","permalink":"https://qi-xiang.github.io/2021/08/15/%E5%AD%97%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"參考書目: Python自動化的樂趣: 搞定重複瑣碎&amp;單調無聊的工作 📝 字串的處理 📓 雙引號 字串可以使用雙引號 &quot; 括住字串的起始和結尾，用法和單引號一樣。用雙引號的好處之一是在字串中可以使用單引號字元。 1sentence = &quot;This is Carol&#x27;s pencil.&quot; 但是，字串中需要有單引號和雙引號同時存在時，就要用到轉義字元。 📓 轉義字元 轉義字元(escape character)，可以讓我們輸入一些不能直接放在字串裡的字元。轉義字元就是將一條反斜線(\\)，放在想要輸入的特殊字元之前，兩個成一組視為一個字元。例如，單引號是以 \\'表示。如此一來便可以在字串中同時輸入單/雙引號。 轉義字元 實際字元 \\' 單引號 \\&quot; 雙引號 \\t 定位空格 \\n 換行 \\\\ 反斜線 1print(&quot;Hi Kevin!\\nHow are you?\\nI\\&#x27;m always here for you.&quot;) 📓 原始字串 在字串開頭的引號之前加上 r ，這個字串就會變成&quot;原始字串(raw string)&quot;。原始字串會忽略掉引號內的所有轉義字元，印出字串時，會連同轉義字元一起印出。 1print(r&quot;This is Carol\\&#x27;s pencil.&quot;) 📓 多行字串 儘管可以使用\\n轉義字元讓字串換行，但三重引號的多行字串更加好用。Python 中的多行字串是以三個單或雙引號包住，在三重引號包住範圍內的所有引號、定位空格等轉義字元，都會被視為字串的一部份，Python 的程式碼縮排規則不適用於多行字串。 1234567print(&#x27;&#x27;&#x27;Dear John,Lura&#x27;s fish has been moved to new fish tank.Sincerely, David&#x27;&#x27;&#x27;) 📓 多行註解 12345&quot;&quot;&quot;Multiline Comment in PythonMultiline Comment in PythonMultiline Comment in Python&quot;&quot;&quot; 📝 字串索引與切片 字串和串列相同都能透過索引和切片取得想要的部分。以字串Hello World!為例，一共有12個字元(包含空格)，索引就是 0 ~ 11。 123456sentence = &quot;Hello World!&quot;print(sentence[0])print(sentence[4])print(sentence[0:5])print(sentence[:6])print(sentence[5:]) 字串切片並不會影響原有字串。 📝 in 和 not in 運算子 如同串列一樣，字串也能夠使用 in、not in 運算子，比對特定的字元或字串是否存在，運算後回傳布林值 True 或 False。 123print(&#x27;Hello&#x27; in &#x27;Hello World&#x27;)print(&#x27;HELLO&#x27; in &#x27;Hello World&#x27;)print(&#x27;HELLO&#x27; not in &#x27;Hello World&#x27;) 📝 字串的方法(部分) 📓 upper()、lower() upper()，將字串中的所有字母轉成大寫並回傳字串 lower()，將字串中的所有字母轉成小寫並回傳字串 1234567sentence = &#x27;Hello World!&#x27;sentence = sentence.upper()print(sentence)sentence = sentence.lower()print(sentence) 📓 isupper()、islower() isupper()，若字串中的所有字母皆為大寫則回傳 True，否則回傳 False islower()，若字串中的所有字母皆為小寫則回傳 True，否則回傳 False 123456789sentence = &#x27;Hello World!&#x27;print(sentence.isupper())print(sentence.islower())print(&#x27;abc123&#x27;.islower())print(&#x27;abc123&#x27;.upper().islower()) 📓 字串比對方法 (isX) isalpha()，字串中只有字母且不是空字串則回傳 True，否則回傳 False isalnum()，字串中只有字母和數字且不是空字串則回傳 True，否則回傳 False isdecimal()，字串中只有數字且不是空字串則回傳 True，否則回傳 False isspace()，字串中只有空格、定位空格和換行且不是空字串則回傳 True，否則回傳 False 12345print(&#x27;hello&#x27;.isalpha())print(&#x27;hello123&#x27;.isalpha())print(&#x27;hello123&#x27;.isalnum())print(&#x27;123&#x27;.isdecimal())print(&#x27; &#x27;.isspace()) 📓 startswith()、endswith() startswith()，傳入要比對的字元，若字串以該字元為開頭，則回傳 True，否則回傳 False endswith()，傳入要比對的字元，若字串以該字元為結尾，則回傳 True，否則回傳 False 1234567print(&#x27;Hello World!&#x27;.startswith(&#x27;Hello&#x27;))print(&#x27;Hello World!&#x27;.endswith(&#x27;World!&#x27;))print(&#x27;abc123&#x27;.startswith(&#x27;abcde&#x27;))print(&#x27;abc123&#x27;.endswith(&#x27;12&#x27;)) 📓 join()、split() join()，以某字串呼叫 join() 方法並將串列傳入後，會返回一個將某字串與串列中的內容連接起來的新字串 12print(&#x27;,&#x27;.join([&#x27;fish&#x27;,&#x27;puppy&#x27;,&#x27;kitty&#x27;]))print(&#x27; and &#x27;.join([&#x27;fish&#x27;,&#x27;puppy&#x27;,&#x27;kitty&#x27;])) split()，功能與 join() 相反，以字串呼叫後，傳回以空格(預設)作為分割字元的串列。另外，亦可傳入特定的分割字元，指定該如何切割字串到串列中(分割字元不會被放到串列中) 123print(&#x27;Her name is Shelly Wang.&#x27;.split())print(&#x27;HerABnameABisABShellyABWang.&#x27;.split(&#x27;AB&#x27;)) 📓 rjust()、ljust()、center() rjust()，傳入引數作為靠右對齊時要插入的左方空格和原字串加起來的長度 ljust()，傳入引數作為靠左對齊時要插入的右方空格和原字串加起來的長度 center()，傳入引數作為置中對齊時要插入的左右空格和原字串加起來的長度 123print(&#x27;Hello&#x27;.rjust(10))print(&#x27;Hello&#x27;.ljust(10))print(&#x27;Hello&#x27;.center(10)) 123print(&#x27;Hello&#x27;.rjust(10,&#x27;*&#x27;))print(&#x27;Hello&#x27;.ljust(10,&#x27;-&#x27;))print(&#x27;Hello&#x27;.center(10,&#x27;=&#x27;)) 上述三個方法都可以再傳入第二個引數，指定要用什麼字元填補空格。 📓 strip()、rstrip()、lstrip() strip()，刪除字串左右兩邊的多餘空格 rstrip()，刪除字串右邊的多餘空格 lstrip()，刪除字串左邊的多餘空格 1234sentence = &#x27; Hello World! &#x27;print(sentence.strip())print(sentence.rstrip())print(sentence.lstrip()) 1234sentence = &#x27;LoremBaconInpusumRoroLoremLorem&#x27;print(sentence.strip(&#x27;Lorem&#x27;))print(sentence.rstrip(&#x27;Lorem&#x27;))print(sentence.lstrip(&#x27;Lorem&#x27;)) 這個方法亦可傳入引數，指定要刪除的左右字元。 📝 pyperclip 模組 pyperclip 模組有 copy() 和 paste() 方法，可向電腦系統中的剪貼簿傳送或接收文字。 pyperclip 不是 python 內建的模組，要先安裝才能使用。 123import pyperclippyperclip.copy(&#x27;Hello World!&#x27;)pyperclip.paste()","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Python 學習日記","slug":"Python-學習日記","permalink":"https://qi-xiang.github.io/tags/Python-%E5%AD%B8%E7%BF%92%E6%97%A5%E8%A8%98/"}]},{"title":"金魚也能學會寫網頁-網頁背景","slug":"金魚也能學會寫網頁-網頁背景","date":"2021-08-12T17:15:00.000Z","updated":"2022-03-13T17:26:11.255Z","comments":true,"path":"2021/08/13/金魚也能學會寫網頁-網頁背景/","link":"","permalink":"https://qi-xiang.github.io/2021/08/13/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81-%E7%B6%B2%E9%A0%81%E8%83%8C%E6%99%AF/","excerpt":"","text":"一開始只是興趣使然，寫了一篇關於網頁框架的簡單筆記，不過幾經思考後，還是想把它寫成網頁相關的系列筆記，希望在忘了一些東西時，能有個地方可以快速找回記憶。☺️ 💡 Hint: 以下筆記內容所使用的作業系統為&quot;Windows 10&quot; 📝 設定背景圖 background-image 將特定素材指定為背景圖，預設水平和垂直均重複(repeat)，讓圖片填滿整個元素 123&lt;div id=&quot;wrap&quot;&gt; &lt;h1 id=&quot;header&quot;&gt;標題&lt;/h1&gt;&lt;/div&gt; 123456789body&#123; /*url(背景圖位址)*/ background-image: url(https://bit.ly/3fSyTov);&#125;#header&#123; color: #ecbaba; font-size: 250%; text-align: center;&#125; background-repeat 設定背景圖重複方向，值: repeat(重複X軸和Y軸)、repeat-x(重複)、repeat-y(重複Y軸)、no-repeat(不重複) 123&lt;div id=&quot;wrap&quot;&gt; &lt;h1 id=&quot;header&quot;&gt;標題&lt;/h1&gt;&lt;/div&gt; 1234567891011body&#123; /*url(背景圖位址)*/ background-image: url(https://bit.ly/3fSyTov); background-repeat: no-repeat;/*圖片不重複*/ &#125;#header&#123; color: #ecbaba; font-size: 250%; text-align: center;&#125; background-position 設定背景圖的位置，水平方向值可為 left、center、right，垂直方向值可為 top、center、bottom，也可以用 px 等單位進行設定，預設是 left top (左上角)。 123&lt;div id=&quot;wrap&quot;&gt; &lt;h1 id=&quot;header&quot;&gt;標題&lt;/h1&gt;&lt;/div&gt; 123456789101112body&#123; /*url(背景圖位址)*/ background-image: url(https://bit.ly/3fSyTov); background-repeat: no-repeat;/*圖片不重複*/ background-position: center center; &#125;#header&#123; color: #ecbaba; font-size: 250%; text-align: center;&#125; 統整設定背景圖屬性 背景圖的相關屬性，可以用屬性簡寫(Shorthand)的方式統整設定。只要將背景圖相關的屬性值一起輸入並以“半形”空白做區隔即可，未指定的值會以預設值自動帶入。設定 background 屬性時，並沒有一定的順序，可依照個人習慣的順序填寫。 123&lt;div id=&quot;wrap&quot;&gt; &lt;h1 id=&quot;header&quot;&gt;標題&lt;/h1&gt;&lt;/div&gt; 12345678910111213body&#123; /*background-image: url(https://bit.ly/3fSyTov); background-repeat: no-repeat; background-position: center center;*/ background: #fff6e6 url(https://bit.ly/3fSyTov) no-repeat center bottom; &#125;#header&#123; color: #ecbaba; font-size: 250%; text-align: center;&#125;","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"金魚也能學會寫網頁","slug":"金魚也能學會寫網頁","permalink":"https://qi-xiang.github.io/tags/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81/"}]},{"title":"金魚也能學會寫網頁-基本屬性與選擇器","slug":"金魚也能學會寫網頁-基本屬性與選擇器","date":"2021-08-11T05:00:00.000Z","updated":"2022-03-13T17:26:19.229Z","comments":true,"path":"2021/08/11/金魚也能學會寫網頁-基本屬性與選擇器/","link":"","permalink":"https://qi-xiang.github.io/2021/08/11/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81-%E5%9F%BA%E6%9C%AC%E5%B1%AC%E6%80%A7%E8%88%87%E9%81%B8%E6%93%87%E5%99%A8/","excerpt":"","text":"一開始只是興趣使然，寫了一篇關於網頁框架的簡單筆記，不過幾經思考後，還是想把它寫成網頁相關的系列筆記，希望在忘了一些東西時，能有個地方可以快速找回記憶。☺️ 💡 Hint: 以下筆記內容所使用的作業系統為&quot;Windows 10&quot; 📝 CSS 註解 註解不會被顯示在瀏覽器上。在撰寫 CSS 時，適度加上註解，可以方便彼此了解這段語法是針對哪個項目進行設定，日後要做調整也會比較方便。 123456@charset &quot;utf-8&quot;; /*未設定編碼方式，使用中文時可能會出現亂碼*//*設定視窗底色*//*設定區塊顏色*/ 📝 載入外部 CSS 可以在 HTML 中使用 link 元素來載入外部 CSS 檔案 1&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; media=&quot;all&quot;&gt; href屬性: 指定外部 CSS 檔案路徑 rel: 指定載入的檔案類型，載入 CSS 檔固定填入 stylesheet media: 指定適用這個 CSS 設定的裝置，可用值包括 screen(螢 幕)、print(印表機)、handheld(手機)、tv(電視)等，all 表示均適用。 📝 設定視窗底色 background-color 設定背景顏色 123body&#123; background-color: #fff6e6;&#125; 📝 設定連結 為了在視覺上更易發現文字內容是連結可被點按，通常會設定滑入文字時顏色上的變化。要做出這個效果，就必須使用到&quot;虛擬類別&quot;。 color 設定文字顏色 用於連結的虛擬類別: 決定套用 CSS 設定的時機 虛擬類別 觸發時機 link 未連過的連結 visited 曾連過的連結 hover 滑鼠移入時 active 點按滑鼠時 12345678/*設定連結顏色*/a&#123; color: #000000; /*black*/&#125;/*當滑鼠移入時，文字變為紅色*/a:hover&#123; color: #ff0000; /*red*/&#125; 📝 設定文字對齊方式、大小 text-align 文字對齊方式，值有 left、center、right 三種 font-size 設定字型大小 12345h1&#123; color: #000000; text-align: center; font-size: 250%; /*文字大小變為預設的250%*/&#125; 📝 設定字體粗細 font-weight 調整字體粗細 font-weight 可用 100~900 的值指定9種不同的粗細 實務上通常使用 normal(一般) 和 bold(粗體) 2種 1234h1&#123; color: #000000; font-weight: bold;&#125; 📝 margin、border、padding border 框線 1234567h1&#123; border: #ff0000 1px solid; /*border: 框線顏色 框線粗細 框線種類*/ /*框線種類: none(無邊線)、solid(實線)、dotted(點線)、dashed(分段線)、double)雙線*/&#125; padding 框線內側邊界 123456h1&#123; padding: 5px; /*全*/ padding: 5px 20px;/*上下 左右*/ padding: 5px 20px 5px;/*上 左右 下*/ padding: 5px 20px 5px 20px;/*上 右 下 左*/&#125; margin 框線外側邊界 123456h1&#123; margin: 5px; /*全*/ margin: 5px 20px;/*上下 左右*/ margin: 5px 20px 5px;/*上 左右 下*/ margin: 5px 20px 5px 20px;/*上 右 下 左*/&#125; 💡Hint: border/padding/margin 可分別加上 “-top”、“-bottom”、“-right”、“-left”，指定要適用的方向 (上下左右)。 混合運用 123456h2&#123; color: #10ebd8; border: #94c8d1 1px dashed; border-left: #d0e35b 10px solid; padding: 5px 20px; margin-bottom: 0;&#125; 📝 CSS 選擇器 (基礎) 實際上在撰寫網頁時，常出現有同樣元素，但必須顯示成不同樣式的情形。這時就必須為元素加上名稱，以不同名稱區分元素。 設定名稱: id 屬性: id 屬性是用來識別 HTML 中特定區塊的屬性，同一 id 值只能在 HTML 中出現一次，重複使用同一 id 值在 HTML 中會造成語法錯誤。 1234&lt;div id=&quot;wrap&quot;&gt; &lt;h1&gt;標題內容&lt;/h1&gt; &lt;p id=&quot;lead&quot;&gt;段落內容&lt;/p&gt;&lt;div&gt; 123456#lead&#123; /*可寫作 p#lead 或 #lead*/ text-align: center; border-top: #6fb9a 1px dashed; border-bottom: #6fb9a 1px dashed; padding: 15px;&#125; class 屬性 class 屬性主要用來將樣式分類，因此與 id屬性不同，同樣的名稱可以在多處被使用。 1234&lt;div id=&quot;wrap&quot;&gt; &lt;h1&gt;標題內容&lt;/h1&gt; &lt;p class=&quot;lead&quot;&gt;段落內容&lt;/p&gt;&lt;div&gt; 1234567.lead&#123; /*可寫作 p.lead 限制為特定元素可使用的選擇器*/ /*或是 .lead 所有元素通用的選擇器*/ text-align: center; border-top: #6fbb9a 1px dashed; border-bottom: #6fbb9a 1px dashed; padding: 15px;&#125; 利用元素親子關係設定樣式 這種利用元素親子關係設定樣式範圍的方法，稱為&quot;子孫選擇器&quot; 撰寫格式: 父元素 子元素 1234&lt;div id=&quot;wrap&quot;&gt; &lt;h1&gt;&lt;span&gt;★&lt;/span&gt;標題內容&lt;span&gt;★&lt;/span&gt;&lt;/h1&gt; &lt;p id=&quot;lead&quot;&gt;段落內容&lt;/p&gt;&lt;div&gt; 123h1 span&#123;/*改變 h1 下 span 的顏色*/ color: #10ebd8;&#125; 群組選擇器 利用逗號串接多個選擇器一併進行管理 1234567891011121314151617181920212223242526272829303132333435363738394041h1,h2,h3&#123; color: #000000;&#125;#header,#footer&#123; color: #ff0000;&#125;.header,.footer&#123; color: #ffff00;&#125;``` **:bulb:Hint:** 更多的選擇器 - [W3Schools CSS Selector](https://www.w3schools.com/cssref/css_selectors.asp)---## :rocket: 選擇器的優先順位當多個選擇器同時指定同一位置同一屬性不同的值時，會依照 CSS 中判斷選擇器優先順位的機制，決定最後採用的樣式。原則上是以「寫在後面的優先於寫在前面的」，但選擇器撰寫時的「明確度」，也會影響優先順位。### 選擇器的明確度明確度(Specificity)是用來表示選擇器內容明確程度的值，值愈大優先程度就愈高。選擇器明確度相同時，後面出現的會較為優先。選擇器明確度一高一低時，則不論出現先後，以明確度最高的為優先。明確度的基本法則:![](https://i.imgur.com/jlsRwMs.png)### !important在屬性後方加上 **!important** 可直接無視明確度，直接指定它為最優先。但是胡亂使用 **!important**，可能會破壞 CSS 的規則，原則上應避免使用。* 原本的優先順位```css=#header .text&#123; /*優先*/ color: #000000;&#125;#header&#123; color: #000000;&#125; 使用 !important 後的優先順位 123456#header .text&#123; color: #000000;&#125;#header&#123; /*優先*/ color: #000000 !important; &#125;","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"金魚也能學會寫網頁","slug":"金魚也能學會寫網頁","permalink":"https://qi-xiang.github.io/tags/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81/"}]},{"title":"金魚也能學會寫網頁-表格與表單","slug":"金魚也能學會寫網頁-表格與表單","date":"2021-08-04T14:35:00.000Z","updated":"2022-03-13T17:26:37.695Z","comments":true,"path":"2021/08/04/金魚也能學會寫網頁-表格與表單/","link":"","permalink":"https://qi-xiang.github.io/2021/08/04/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81-%E8%A1%A8%E6%A0%BC%E8%88%87%E8%A1%A8%E5%96%AE/","excerpt":"","text":"一開始只是興趣使然，寫了一篇關於網頁框架的簡單筆記，不過幾經思考後，還是想把它寫成網頁相關的系列筆記，希望在忘了一些東西時，能有個地方可以快速找回記憶。☺️ 💡 Hint: 以下筆記內容所使用的作業系統為&quot;Windows 10&quot; 📝 製作表格 基本結構(2欄1列): 123456&lt;table&gt; &lt;tr&gt; &lt;td&gt;第一欄&lt;/td&gt; &lt;td&gt;第二欄&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格結構圖: 📓 基本構成元素 元素 說明 &lt;table&gt;&lt;/table&gt; 表示整個表格的區塊 &lt;tr&gt;&lt;/tr&gt; 表示橫欄 &lt;th&gt;&lt;/th&gt; 表示欄位標題 &lt;td&gt;&lt;/td&gt; 表示直欄 📓 實際的例子 123456789101112131415161718&lt;table border=&#x27;1&#x27;&gt; &lt;tr&gt; &lt;th&gt;姓名:&lt;/th&gt; &lt;td&gt;王小明&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;性別:&lt;/th&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;年齡:&lt;/th&gt; &lt;td&gt;10&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;身分:&lt;/th&gt; &lt;td&gt;學生&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 暫時加上 border 屬性(表格框線)，以便確認顯示結果。 📝 設定表單區塊 製作表單時，必須要以&lt;form&gt;~&lt;/form&gt;宣告整個表單區塊。&lt;form&gt;~&lt;/form&gt;之間的範圍，就是在按下傳送按鈕後，實際會傳送到主機的範圍。 📓 &lt;form&gt;元素基本語法 1&lt;form id=&quot;表單名稱&quot; action=&quot;資料接收端的路徑&quot; method=&#x27;資料傳送方式&#x27;&gt;&lt;/form&gt; id屬性: 識別資料來自哪個表單 action屬性: 資料接收端的路徑(多半是網站主機上的程式) method屬性: 資料傳送方式，可設定為 get(將資料當作URL的一部份進行傳送) 或 post(將資料當作文件文本傳送) 1234567891011121314151617181920&lt;form id=&quot;entryform&quot; action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;table border=&#x27;1&#x27;&gt; &lt;tr&gt; &lt;th&gt;姓名:&lt;/th&gt; &lt;td&gt;王小明&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;性別:&lt;/th&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;年齡:&lt;/th&gt; &lt;td&gt;10&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;身分:&lt;/th&gt; &lt;td&gt;學生&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 📝 製作表單 &lt;input&gt;元素適用於輸入資料的元素，依據 type 屬性的不同可產生不同種類的輸入欄位。 &lt;select&gt;元素可用來製作下拉式選單，選項則以 option 元素撰寫 📓 加入文字欄位 設定 type=“text” 1&lt;input type=&quot;text&quot; name=&quot;欄位名稱&quot;&gt; 實例: 12345678&lt;form id=&quot;entryform&quot; action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;table border=&#x27;1&#x27;&gt; &lt;tr&gt; &lt;th&gt;姓名:&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;欄位名稱&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 📓 加入多行文字輸入方塊 &lt;textarea&gt;是用來輸入多行文字的元素 rows、cols 屬性的值分別代表輸入方塊顯示時的橫列數與每列字數，但實際輸入資料可以超過列數限制 輸入區塊的大小，會隨著不同瀏覽器而有所不同，可以用之後介紹的 CSS 指定尺寸 1&lt;textarea name=&quot;欄位名稱&quot; rowa=&quot;顯示的橫列數&quot; cols=&quot;顯示的每列字數&quot;&gt; 實例: 12345678&lt;form id=&quot;entryform&quot; action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;table border=&#x27;1&#x27;&gt; &lt;tr&gt; &lt;th&gt;意見回饋:&lt;/th&gt; &lt;td&gt;&lt;textarea name=&quot;feedback&quot; rowa=&quot;4&quot; cols=&quot;40&quot;&gt;&lt;/textarea&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 📓 加入下拉式選單 option 元素中的 value 屬性，用來指定實際傳送到主機的值 設定預選的選項，則在 option 元素上加上 selected 即可 1234&lt;select name=&quot;欄位名稱&quot;&gt;&lt;option value=&quot;傳送資料值&quot;&gt;選項顯示文字&lt;/option&gt;...&lt;/select&gt; 實例: 123456789101112131415&lt;form id=&quot;entryform&quot; action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;table border=&#x27;1&#x27;&gt; &lt;tr&gt; &lt;th&gt;居住縣市:&lt;/th&gt; &lt;td&gt; &lt;select&gt; &lt;option value=&quot;select&quot;&gt;請選擇&lt;/option&gt; &lt;option value=&quot;台北&quot;&gt;台北&lt;/option&gt; &lt;option value=&quot;台中&quot;&gt;台中&lt;/option&gt; &lt;option value=&quot;高雄&quot;&gt;高雄&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 📓 加入單選方塊 設定 type=“radio” name 屬性必須被設定為相同名稱，讓使用者只能選擇其中一個 有要預設勾選的項目，可以在項目上加上 checked 1&lt;input type=&quot;radio&quot; name=&quot;資料群組名稱&quot; value=&quot;資料傳送值&quot;&gt; 實例: 1234567891011&lt;form id=&quot;entryform&quot; action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;table border=&#x27;1&#x27;&gt; &lt;tr&gt; &lt;th&gt;性別:&lt;/th&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 📓 加入多選方塊 設定 type=“checkbox” 每個選項的 name 屬性值不可相同 要預設勾選的項目，可以在選項加上 checked 1&lt;input type=&quot;checkbox&quot; name=&quot;資料名稱&quot; value=&quot;資料傳送值&quot;&gt; 實例: 123456789101112&lt;form id=&quot;entryform&quot; action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;table border=&#x27;1&#x27;&gt; &lt;tr&gt; &lt;th&gt;喜好:&lt;/th&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; name=&quot;like1&quot; value=&quot;滷蛋&quot;&gt;滷蛋 &lt;input type=&quot;checkbox&quot; name=&quot;like2&quot; value=&quot;荷包蛋&quot;&gt;荷包蛋 &lt;input type=&quot;checkbox&quot; name=&quot;like3&quot; value=&quot;糖心蛋&quot;&gt;糖心蛋 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 📓 加入檔案上傳按鈕 設定 type=“file” 可產生將檔案上傳到主機的按鈕 按鈕型式依照瀏覽器不同而有所差異 1&lt;input type=&quot;file&quot; name=&quot;資料名稱&quot;&gt; 實例: 12345678&lt;form id=&quot;entryform&quot; action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;table border=&#x27;1&#x27;&gt; &lt;tr&gt; &lt;th&gt;照片:&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;file&quot; name=&quot;photo&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 📓 加入清除重填、送出按鈕 設定 type=“reset” 可產生清除重填按鈕 設定 type=“submit” 可產生送出按鈕 修改 value 屬性值可以變更按鈕顯示文字 1&lt;input type=&quot;按鈕種類&quot; value=&quot;按鈕顯示文字&quot;&gt; 實例: 123456789101112&lt;form id=&quot;entryform&quot; action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;table border=&#x27;1&#x27;&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;reset&quot; value=&quot;清除重填&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 🚀 BONUS: 好用的表單屬性 autofocus 屬性: 網頁開啟時，自動將游標停在指定的表單元件上。 1&lt;input type=&quot;text&quot; name=&quot;example&quot; autofocus&gt; 每個網頁中只能設定一個 autofocus 屬性。 autocomplete 屬性: 依照以前輸入過的內容自動輸入。沒有設定時，預設 autocomplete=“on”，關閉自動輸入則設定為 off。 1&lt;input type=&quot;text&quot; name=&quot;example&quot; autocomplete=&quot;off&quot;&gt; placeholder 屬性: 在表單元件中顯示簡短的輸入提示，幫助使用者輸入。 1&lt;input type=&quot;text&quot; name=&quot;example&quot; placeholder=&quot;輸入文字&quot;&gt; required 屬性: 在表單元件上設定這個屬性，表示它是一個&quot;必填&quot;欄位。 12345678910111213141516171819&lt;form id=&quot;entryform&quot; action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;table border=&#x27;1&#x27;&gt; &lt;tr&gt; &lt;th&gt;性別:&lt;/th&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; required&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; required&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;reset&quot; value=&quot;清除重填&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"金魚也能學會寫網頁","slug":"金魚也能學會寫網頁","permalink":"https://qi-xiang.github.io/tags/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81/"}]},{"title":"金魚也能學會寫網頁-換行、強調、插入圖片與連結","slug":"金魚也能學會寫網頁-換行、強調、插入圖片與連結","date":"2021-08-03T16:30:00.000Z","updated":"2022-03-13T17:26:17.086Z","comments":true,"path":"2021/08/04/金魚也能學會寫網頁-換行、強調、插入圖片與連結/","link":"","permalink":"https://qi-xiang.github.io/2021/08/04/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81-%E6%8F%9B%E8%A1%8C%E3%80%81%E5%BC%B7%E8%AA%BF%E3%80%81%E6%8F%92%E5%85%A5%E5%9C%96%E7%89%87%E8%88%87%E9%80%A3%E7%B5%90/","excerpt":"","text":"一開始只是興趣使然，寫了一篇關於網頁框架的簡單筆記，不過幾經思考後，還是想把它寫成網頁相關的系列筆記，希望在忘了一些東西時，能有個地方可以快速找回記憶。☺️ 💡 Hint: 以下筆記內容所使用的作業系統為&quot;Windows 10&quot; 📝 換行 在 HTML 文件中有要換行的地方時，可以利用&lt;br&gt;元素來強制換行。 📓 &lt;br&gt;元素 &lt;br&gt;元素只有開始標籤而沒有結束標籤，像這樣的元素就稱為&quot;空元素&quot;或是&quot;單標籤&quot; 123&lt;p&gt;範例文字1&lt;br&gt;範例文字2&lt;br&gt;範例文字3&lt;/p&gt;&lt;p&gt;範例文字1範例文字2範例文字3&lt;/p&gt; 📝 強調重點 若有特別重要的字句，可以透過&lt;strong&gt;元素進行重點標示。 📓 &lt;strong&gt;元素 多數瀏覽器會以&quot;粗體&quot;顯示&lt;strong&gt;元素內的字句 不要為了顯示粗體字而刻意使用&lt;strong&gt;元素，這裡粗體的意義是凸顯出&quot;重點&quot;，要將文字以&quot;粗體&quot;顯示，另有其他方式 1&lt;strong&gt;強調的字句內容&lt;/strong&gt; 📝 插入圖片 在 HTML 文件中要插入圖片，可以使用&lt;img&gt;元素。 📓 &lt;img&gt;元素 src 屬性: 標記圖檔的路徑 width、height 屬性: 規範圖片的尺寸大小 alt 屬性: 在圖片無法正常顯示時，會顯示的替代文字 12&lt;img src=&quot;https://bit.ly/3CaEZKg&quot; width=&quot;320&quot; height=&quot;320&quot; alt=&quot;替代文字&quot;&gt;&lt;img src=&quot;https://bit.ly/3CaEZKgd&quot; width=&quot;320&quot; height=&quot;320&quot; alt=&quot;替代文字&quot;&gt; 📝 設定連結 在 HTML 文件中要插入超連結，可以使用&lt;a&gt;元素。 📓 &lt;a&gt;元素 1. 網頁內部連結 透過不同區塊上設定的 id 屬性名稱進行同一頁面上的跳轉 以 #id名稱 的形式撰寫連結 12345&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#content1&quot;&gt;項目一&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#content2&quot;&gt;項目二&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#content3&quot;&gt;項目三&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 2. 外部網站連結 直接使用外部網站連結即可 若想在新分頁開啟網頁，可設定target=&quot;_blank&quot; 12&lt;a href=&quot;https://www.google.com.tw/&quot;&gt;https://www.google.com.tw/&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;a href=&quot;https://www.google.com.tw/&quot; target=&quot;_blank&quot;&gt;https://www.google.com.tw/&lt;/a&gt;&lt;br&gt;&lt;br&gt; 📝 版權宣告 網頁中的免責條款、法律規範、版權宣告等注意事項，通常會以較小的文字顯示，可以使用&lt;small&gt;元素進行標示。 📓 &lt;small&gt;元素 若僅是要讓文字看起來比較小，而不是為了賦予文字特殊意義，則不建議使用&lt;small&gt;元素 1&lt;small&gt;Copyright &amp;copy; Xiang All Rights Reserved.&lt;/small&gt; 🚀 BONUS: 絕對路徑與相對路徑 📓 絕對路徑 絕對路徑是指從 http 或 https 開始的完整網址(URL)，例如: https://www.google.com.tw/ 📓 相對路徑 相對路徑是指&quot;現在所在位置&quot;與&quot;目的檔案&quot;之間的相對位置關係 路徑表示法 代表意義 ../ 上一層 ./ 同一層 / 下一層 假設檔案結構如下: 從 folder1 出發到 C.html 的路徑是 folder2/folder3/C.html 從 C.html 出發到 folder1 的路徑是 ../../../ 從 C.html 出發到 B.html 的路徑是 ../../B.html 根目錄相對路徑: 固定從根目錄出發","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"金魚也能學會寫網頁","slug":"金魚也能學會寫網頁","permalink":"https://qi-xiang.github.io/tags/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81/"}]},{"title":"金魚也能學會寫網頁-開始編寫HTML","slug":"金魚也能學會寫網頁-開始編寫HTML","date":"2021-08-02T17:10:00.000Z","updated":"2022-03-09T11:31:56.379Z","comments":true,"path":"2021/08/03/金魚也能學會寫網頁-開始編寫HTML/","link":"","permalink":"https://qi-xiang.github.io/2021/08/03/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81-%E9%96%8B%E5%A7%8B%E7%B7%A8%E5%AF%ABHTML/","excerpt":"","text":"一開始只是興趣使然，寫了一篇關於網頁框架的簡單筆記，不過幾經思考後，還是想把它寫成網頁相關的系列筆記，希望在忘了一些東西時，能有個地方可以快速找回記憶。☺️ 💡 Hint: 以下筆記內容所使用的作業系統為&quot;Windows 10&quot; 📝 網頁中常出現的元素 元素 用途 分類 &lt;h1&gt;~&lt;/h1&gt;…&lt;h6&gt;~&lt;/h6&gt; 標題 block 類型元素 &lt;p&gt;~&lt;/p&gt; 段落 block 類型元素 &lt;ul&gt;~&lt;/ul&gt; 條列式列表(無序) block 類型元素 &lt;ol&gt;~&lt;/ol&gt; 條列式列表(有序) block 類型元素 &lt;dl&gt;~&lt;/dl&gt; 定義用列表 block 類型元素 &lt;table&gt;~&lt;/table&gt; 表格 block 類型元素 &lt;address&gt;~&lt;/address&gt; 聯絡方式 block 類型元素 &lt;div&gt;~&lt;/div&gt; 任意範圍、群組化 block 類型元素 &lt;a&gt;~&lt;/a&gt; 超連結 inline 類型元素 &lt;em&gt;~&lt;/em&gt; 強調 inline 類型元素 &lt;strong&gt;~&lt;/strong&gt; 重點標示 inline 類型元素 &lt;img&gt;~&lt;/img&gt; 圖片 inline 類型元素 &lt;span&gt;~&lt;/span&gt; 任意範圍 inline 類型元素 📓 inline元素 VS. block元素 HTML 文件主要是由元素的巢狀關係所構成，而在進行巢狀配置時，必須遵守 “文件內容模型 (Content Model)” 的規範，也就是哪一些元素可以被放在另一些元素之內。 HTML5 的文件內容模型有點複雜，所以可以依照舊版 HTML block元素/inline元素 的分類方式就好。 簡單來說，inline元素可以被放在block元素之內，但block元素不能被放在inline元素之內。 分類元素的方法很簡單，在瀏覽器上顯示時，會自動換行的就是block元素，反之則是inline元素。 📝 實際使用元素 📓 &lt;hx&gt;元素 作用: 設定標題 共有 h1~h6 六大階層，原則上不可以有階層亂跳的情況 同一頁面中，只能有一個&lt;h1&gt;&lt;/h1&gt;標籤 123456&lt;h1&gt;h1 h1 h1&lt;/h1&gt;&lt;h2&gt;h2 h2 h2&lt;/h2&gt;&lt;h3&gt;h3 h3 h3&lt;/h3&gt;&lt;h4&gt;h4 h4 h4&lt;/h4&gt;&lt;h5&gt;h5 h5 h5&lt;/h5&gt;&lt;h6&gt;h6 h6 h6&lt;/h6&gt; 📓 &lt;p&gt;元素 作用: 標記段落 1&lt;p&gt;段落&lt;/p&gt; 📓 &lt;ul&gt;、&lt;ol&gt;元素 作用: 製作條列式列表 不可單獨使用，要搭配&lt;li&gt;元素使用 ul: 無編號、無順序 ol: 有編號、有順序 12345&lt;ul&gt; &lt;li&gt;項目內容&lt;/li&gt; &lt;li&gt;項目內容&lt;/li&gt; &lt;li&gt;項目內容&lt;/li&gt;&lt;/ul&gt; 12345&lt;ol&gt; &lt;li&gt;項目內容&lt;/li&gt; &lt;li&gt;項目內容&lt;/li&gt; &lt;li&gt;項目內容&lt;/li&gt;&lt;/ol&gt; 📓 &lt;dl&gt;元素 作用: 製作定義用列表 將標題項目和項目說明合成一組 不可單獨使用，要搭配&lt;dt&gt;&lt;/dt&gt;標記標題、&lt;dd&gt;&lt;/dd&gt;進行項目說明，兩元素亦無法被單獨使用，需搭配成一組 123456&lt;dl&gt; &lt;dt&gt;項目標題&lt;/dt&gt; &lt;dd&gt;項目說明&lt;/dd&gt; &lt;dt&gt;項目標題&lt;/dt&gt; &lt;dd&gt;項目說明&lt;/dd&gt;&lt;/dl&gt; 📓 &lt;div&gt;元素 作用: 將資料群組化 內容群組化後，之後在CSS樣式設計上會比較方便 透過 id 屬性，可以為群組命名 可用 &lt;section&gt;元素取代 123&lt;div id=&#x27;content&#x27;&gt; &lt;p&gt;段落&lt;/p&gt;&lt;/div&gt; 123&lt;section id=&#x27;content&#x27;&gt; &lt;p&gt;段落&lt;/p&gt;&lt;/section&gt; 📝 巢狀元素與親子關係 整個 HTML 文件以 html 為最上層的父元素，由巢狀的親子關係所組成。外層元素稱為&quot;父&quot;元素，內層元素稱為&quot;子元素&quot;，更內層的稱為&quot;孫&quot;元素，而同一層的元素則互為&quot;兄弟元素&quot;。 原始碼 12345678910&lt;html&gt; &lt;body&gt; &lt;div&gt; &lt;h1&gt;&lt;h1&gt; &lt;p&gt; &lt;a&gt;&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 巢狀元素 親子關係","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"金魚也能學會寫網頁","slug":"金魚也能學會寫網頁","permalink":"https://qi-xiang.github.io/tags/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81/"}]},{"title":"Python 學習日記 EP 5 - 字典與結構化資料","slug":"字典與結構化資料","date":"2021-08-01T10:45:00.000Z","updated":"2022-03-13T17:26:55.313Z","comments":true,"path":"2021/08/01/字典與結構化資料/","link":"","permalink":"https://qi-xiang.github.io/2021/08/01/%E5%AD%97%E5%85%B8%E8%88%87%E7%B5%90%E6%A7%8B%E5%8C%96%E8%B3%87%E6%96%99/","excerpt":"","text":"參考書目: Python自動化的樂趣: 搞定重複瑣碎&amp;單調無聊的工作 📝 字典與資料型別 字典(Dictionary) : 利用&quot;鍵(key)&quot;與&quot;值(value)“關聯在一起，這種關係稱為&quot;鍵值對(key-value pair)” 📓 字典與串列 字典中的項目沒有順序之分 當鍵值不存在字典中，拋出 KeyError 📓 keys() 將字典中的鍵(key)以類似串列的方式回傳(不是真的串列) 要得到串列資料型態的話，可以透過 list() 📓 values() 將字典中的值(value)以類似串列的方式回傳(不是真的串列) 要得到串列資料型態的話，可以透過 list() 📓 items() 將字典中的鍵-值(key-value)以多元組的方式回傳 📓 檢查字典中的某個鍵或值是否存在 📓 get() get(要存取的鍵,鍵不存在時的返回值) 📓 setdefault() 為不存在的鍵值設定預設值並回傳預設值 若鍵值本身已存在則不改變現有鍵值並回傳現在的鍵值 📓 印出美觀的結果 利用 pprint 模組的 pprint() 和 pformat()，將字典以較美觀的方式印出 📓 巢狀嵌套的字典和串列","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Python 學習日記","slug":"Python-學習日記","permalink":"https://qi-xiang.github.io/tags/Python-%E5%AD%B8%E7%BF%92%E6%97%A5%E8%A8%98/"}]},{"title":"Python 學習日記 EP 4 - 串列","slug":"串列","date":"2021-07-31T18:00:00.000Z","updated":"2022-03-13T17:26:50.923Z","comments":true,"path":"2021/08/01/串列/","link":"","permalink":"https://qi-xiang.github.io/2021/08/01/%E4%B8%B2%E5%88%97/","excerpt":"","text":"參考書目: Python自動化的樂趣: 搞定重複瑣碎&amp;單調無聊的工作 tags: Python 學習日記 📝 串列資料型別 📓 以索引取得串列值 📓 負數索引取值 📓 切片取得子串列 example: spam[起始索引 : 結束索引]，不包含&quot;結束索引&quot; 📓 len() 取得串列長度 📓 用索引改變串列中的值 📓 串列的連接與複製 📓 del 刪除串列中的值 📝 運用串列 📝 在迴圈中使用串列 📓 in、not in 運算子 📓 多重指定值 📝 增強型指定運算子 增強型運算子 相同的表達式 spam += 1 spam = spam + 1 spam -= 1 spam = spam - 1 spam *= 1 spam = spam * 1 spam /= 1 spam = spam / 1 spam %= 1 spam = spam % 1 📝 串列方法 📓 index() 回傳欲搜尋值所在的索引(有相同的重複值則回傳第一個)，若值不存在串列中則回報 ValueError 📓 append() 新增值到串列的最後方 📓 insert() 插入值到特定的串列位置 📓 remove() 將特定值從串列中刪除(有相同的重複值則刪除出現的第一個)，若值原本就不存在於串列中，則回報 ValueError 📓 sort() 排序串列 (預設由小到大) 關鍵字引數: reverse = True，反向做串列排序 關鍵字引數: key = str.lower，將字母都視為小寫後排序 📝 類似串列 (List-like) 的型別: 字串、元組 📓 可變、不可變資料型別 可變 (mutable): 例如: 串列的值可以新增、刪除、修改 不可變 (immutable): 例如: 字串的值不能新增、刪除、修改 📓 多元組資料型別 多元組和串列幾乎相同除了: 使用小括弧 () 多元組是不可變的 💡 Hint: 當多元組內只有一個值時，要在值後加上逗號(,)，說明它是一個&quot;多元組&quot;而&quot;不是字串&quot;，例如: spam = (1,)。 📓 轉換型別 list() tuple() 📝 參照 參照(reference)可以想成是存放變數的位置，假設有兩個變數指向同一個位置，更改其中一個變數值，也會動到另一個變數值。 📓 傳入參照 將串列指定給變數時，實際上是將參照指定給變數 📓 copy 模組 若不想影響到串列原有值，可以考慮使用 copy 模組 copy(): 一維串列適用 deepcopy(): 多維串列適用 (但直接用 copy() 似乎也可以)","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Python 學習日記","slug":"Python-學習日記","permalink":"https://qi-xiang.github.io/tags/Python-%E5%AD%B8%E7%BF%92%E6%97%A5%E8%A8%98/"}]},{"title":"Python 學習日記 EP 3 - 函式","slug":"函式","date":"2021-07-30T15:30:00.000Z","updated":"2022-03-13T17:26:48.886Z","comments":true,"path":"2021/07/30/函式/","link":"","permalink":"https://qi-xiang.github.io/2021/07/30/%E5%87%BD%E5%BC%8F/","excerpt":"","text":"參考書目: Python自動化的樂趣: 搞定重複瑣碎&amp;單調無聊的工作 📝 def 編寫函式、傳入引數 📝 return 返回值 📝 None 值 print() 本身沒有回傳值 📝 關鍵字引數與 print() 📝 變數作用範疇 區域變數 (local variable) 全域變數 (global variable) 全域作用範疇中的程式碼不能使用區域變數 區域作用範疇中的程式碼可以使用全域變數 📓 global 📝 例外處理","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Python 學習日記","slug":"Python-學習日記","permalink":"https://qi-xiang.github.io/tags/Python-%E5%AD%B8%E7%BF%92%E6%97%A5%E8%A8%98/"}]},{"title":"Python 學習日記 EP 2 - 流程控制","slug":"流程控制","date":"2021-07-30T14:10:00.000Z","updated":"2022-03-13T17:25:54.911Z","comments":true,"path":"2021/07/30/流程控制/","link":"","permalink":"https://qi-xiang.github.io/2021/07/30/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"","text":"參考書目: Python自動化的樂趣: 搞定重複瑣碎&amp;單調無聊的工作 📝 布林值 True False 📝 比較運算子 運算子 意思 == 等於 != 不等於 &lt; 小於 &gt; 大於 &lt;= 小於等於 &gt;= 大於等於 📝 布林運算子 📓 二元布林運算子 and : 所有條件成立才為 True or : 只要有一條件成立則為 True not : 得到相反的布林值 📓 混和運用布林、比較運算子 📝 if 判斷句 只能有其中一個條件成立並被執行 (例如: 第一個為True的條件判斷) 📓 if-else 📓 if-elif-else 📝 while 迴圈判斷句 透過條件限制，持續執行某一程式區塊 📝 break 符合特定條件時，跳出迴圈 💡 Hint: 若迴圈不只一層，則跳出內迴圈 📝 continue 跳回迴圈開始處，重新檢查迴圈條件 📝 for 迴圈和 range() 函式 range(起始值,終止值,遞移植)，但 “不包含” 終止值 📝 匯入模組 💡 Hint: 用 sys.exit() 取代 break 跳出迴圈。","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Python 學習日記","slug":"Python-學習日記","permalink":"https://qi-xiang.github.io/tags/Python-%E5%AD%B8%E7%BF%92%E6%97%A5%E8%A8%98/"}]},{"title":"Python 學習日記 EP 1 - Python基礎","slug":"Python基礎","date":"2021-07-30T05:20:00.000Z","updated":"2022-03-13T17:24:41.688Z","comments":true,"path":"2021/07/30/Python基礎/","link":"","permalink":"https://qi-xiang.github.io/2021/07/30/Python%E5%9F%BA%E7%A4%8E/","excerpt":"","text":"參考書目: Python自動化的樂趣: 搞定重複瑣碎&amp;單調無聊的工作 📝 數學運算子 運算優先等級由高到低 運算子 功能 ** 指數 % 模數/餘數 // 整除/商數取整 / 除法 * 乘法 - 減法 * 加法 📝 整數、浮點數、字串 資料型別 舉例 整數 1、-1、3 浮點數 -1.33、0.0、1.45 字串 ‘b’、‘bb’、‘bbb’ 📝 字串連接、複製 📝 將值存放到變數 📝 變數名稱命名規範 只能是1個字詞(中間不能有空格) 只能用英文字母、數字和底線(不能使用其他特殊符號) 不能以數字作為開頭 舉例: [O] variable [X] variable-1 [O] variable_1 [X] 1variable [O] _variable [X] 54 [O] VAR [X] var_$iable [O] variable1 [X] ‘variable’ [O] variAble [X] var iable 📝 註解 單行註解 1# 單行註解 多行註解 1234&#x27;&#x27;&#x27;多行註解多行註解&#x27;&#x27;&#x27; 📝 print() 函式 印出括號內字串 📝 type() 函式 回傳變數資料型態 📝 input() 函式 取得使用者輸入 ( 預設資料型別為 “str” ) 📝 len() 函式 取得字串字元的個數 📝 資料轉型函式 str()，將傳入值變成字串 int()，將傳入值變成整數 float()，將傳入值變成浮點數","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Python 學習日記","slug":"Python-學習日記","permalink":"https://qi-xiang.github.io/tags/Python-%E5%AD%B8%E7%BF%92%E6%97%A5%E8%A8%98/"}]},{"title":"金魚也能學會寫網頁-編輯器","slug":"金魚也能學會寫網頁-編輯器","date":"2021-07-29T09:20:00.000Z","updated":"2022-03-13T17:26:08.555Z","comments":true,"path":"2021/07/29/金魚也能學會寫網頁-編輯器/","link":"","permalink":"https://qi-xiang.github.io/2021/07/29/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81-%E7%B7%A8%E8%BC%AF%E5%99%A8/","excerpt":"","text":"“工欲善其事，必先利其器”。好的編輯器讓你事半功倍，壞的編輯器讓你事倍功半。 💡 Hint: 以下筆記內容所使用的作業系統為&quot;Windows 10&quot; 📝 編輯器的選擇 1: 記事本 好處是不用安裝每台電腦都有，但接著看下去的話，相信你不會想要選這個做為編輯器。 2: Notepad++ 跟上面的記事本很像，但它本身支援多種語言的撰寫，會自動為關鍵字標上各種不同的顏色，在排版上也較記事本容易許多(在視窗左方有行號可以對照)。 3: Adobe Brackets 由 Adobe Systems 開發的一個以 HTML、CSS 及 JavaScript 編寫的 HTML 編輯器。除了 Notepad++ 有的功能以外，在編寫 HTML 元素的屬性時，會自動出現一些相關的關鍵字供選擇，同時也提供即時預覽網頁功能，最後也可透過安裝擴充元件的方式，讓編輯器功能更加強大! 4: Microsoft Visual Studio 上面有的功能，Visual Studio 通通都有，它有各式各樣酷炫的快捷鍵，保證在編寫時的高效率。同時，可以安裝的擴充元件極多，你可以將編輯器調教成自己最舒服的環境~ 私心排名: Visual Studio &gt; Brackets &gt; Notepad++ &gt; 記事本 💡 Hint: 除了上面介紹的四種編輯器，其他還有許多沒有被提到。上述的都是我用過的編輯器，個人私心推薦使用 Visual Studio 作為主要編輯器。 🚀 BONUS: 安裝 Visual Studio 如果你已經有用習慣的網頁編寫工具，可以選擇略過此部分，下面以VS Code為例 💡 Step 1: 下載並安裝 VS Code Download VS Code 👉基本上按照預設一直點下一步就行 💡 Step 2: 設定 VS Code 環境 設定Ctrl+滑鼠滾輪的程式碼縮放功能、自動儲存 安裝Live Server套件 💡 Step 3: 使用快捷鍵建立基本架構 開啟欲存放檔案的資料夾 右鍵新增.html檔案 在檔案內輸入 !+Enter 或 !+Tab 自動生成基本架構(如下方程式碼區塊) 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 💡 Step 4: 使用 Live Server 檢視網頁 點擊右下角 Go Live，此時瀏覽器應自動開啟並顯示網頁 :::info 💡 Hint: 1.若在右下角沒看到 Live Server，請在程式碼區塊內按滑鼠右鍵，點擊 Open with Live Server。 2.網頁預設路徑: 127.0.0.1:5500。 ::: 👇 檢視你的網頁! 成功完成基本環境設定! 😆","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"金魚也能學會寫網頁","slug":"金魚也能學會寫網頁","permalink":"https://qi-xiang.github.io/tags/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81/"}]},{"title":"金魚也能學會寫網頁-HTML超入門","slug":"金魚也能學會寫網頁-HTML超入門","date":"2021-07-29T08:55:00.000Z","updated":"2022-03-13T17:25:57.423Z","comments":true,"path":"2021/07/29/金魚也能學會寫網頁-HTML超入門/","link":"","permalink":"https://qi-xiang.github.io/2021/07/29/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81-HTML%E8%B6%85%E5%85%A5%E9%96%80/","excerpt":"","text":"一開始只是興趣使然，寫了一篇關於網頁框架的簡單筆記，不過幾經思考後，還是想把它寫成網頁相關的系列筆記，希望在忘了一些東西時，能有個地方可以快速找回記憶。☺️ 💡 Hint: 以下筆記內容所使用的作業系統為&quot;Windows 10&quot; 📝 簡單介紹 HTML HTML (Hyper Text Markup Language，超文字標記語言) 是用來製作網頁的 “標記式” 語言。標記(Markup)，指在某內容的開頭及結尾加上 “標籤(Tag)”，用以定義該段內容的意義。 例如: 1&lt;p&gt;Hello HTML&lt;/p&gt; 以上面的例子來說，&lt;p&gt;(開始標籤)與&lt;/p&gt;(結束標籤)之間的內容，就被定義為段落。 💡 Hint: 但不一定都是雙標籤，也有單標籤存在，例如:&lt;br/&gt;就是一個單標籤。 ✏️ HTML 的組成要件 元素(Element): 開始標籤與結束標籤之間所框住的範圍稱為元素，而元素是構成 HTML 的最小單位。 1&lt;p&gt;Hello 元素&lt;/p&gt; 屬性(Attribute): 屬性是用來對元素進行各種設定。如下面設定了 a 元素的 href 屬性。a 元素主要是用來定義超連結(Hyperlink)，href 屬性則指明了要連結的位置。 1&lt;a href=&quot;https://www.google.com.tw/&quot;&gt;Google&lt;/a&gt; ✏️ HTML 的文件結構 最基本的架構 DOCTYPE 宣告: 用來宣告使用的 HTML 版本 html 元素: HTML 文件的最上層元素，以下分成 head 和 body，通常在 html 標籤上會設定 “lang” 屬性，作語言識別之用，例如: zh-TW (繁體中文) 1&lt;html lang=&quot;zh-TW&quot;&gt; head 元素: 記載頁面的標題、文字編碼、關鍵字、內容概要或其他連結檔案等…，不會在瀏覽器中顯示出來 body 元素: 記載頁面內容並顯示在瀏覽器上 🚀 BONUS: head 內的常見元素 除了 title 元素外，其他都不會顯示在網頁上 元素 說明 &lt;title&gt;頁面標題&lt;/title&gt; 設定 HTML 文件的標題 &lt;meta charset=&quot;utf-8&quot;&gt; 記載文字編碼 &lt;meta name=&quot;description&quot; content=&quot;網頁概述&quot;&gt; 網頁內容的大致說明 &lt;meta name=&quot;keywors&quot; content=&quot;關鍵字&quot;&gt; 設定網頁的關鍵字 網頁原始碼 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-TW&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"金魚也能學會寫網頁","slug":"金魚也能學會寫網頁","permalink":"https://qi-xiang.github.io/tags/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81/"}]},{"title":"金魚也能學會寫網頁-框架篇","slug":"金魚也能學會寫網頁-框架篇","date":"2021-07-27T04:43:00.000Z","updated":"2022-03-13T17:26:32.511Z","comments":true,"path":"2021/07/27/金魚也能學會寫網頁-框架篇/","link":"","permalink":"https://qi-xiang.github.io/2021/07/27/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81-%E6%A1%86%E6%9E%B6%E7%AF%87/","excerpt":"","text":"據說金魚只有七秒的記憶力，那有沒有辦法讓金魚也能快速建置個人網頁呢? 答案是有的!! Bootstrap是一個前端的網頁框架，框架內有各種已寫好的網頁元件，你只要做3件事，複製、貼上、拼拼圖(Component)，就能做出一個基本的前端網頁。👍 💡Hint: 文章內所使用的版本是 Bootstrap v4.6.x ⏳ Setting Environment 如果你已經有用習慣的網頁編寫工具，可以選擇略過此部分，下面以VS Code為例 💡 Step 1: 下載並安裝 VS Code Download VS Code 👉基本上按照預設一直點下一步就行 💡 Step 2: 設定 VS Code 環境 設定Ctrl+滑鼠滾輪的程式碼縮放功能、自動儲存 安裝Live Server套件 💡 Step 3: 使用快捷鍵建立基本架構 開啟欲存放檔案的資料夾 右鍵新增.html檔案 在檔案內輸入 !+Enter 或 !+Tab 自動生成基本架構(如下方程式碼區塊) 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 💡 Step 4: 使用 Live Server 檢視網頁 點擊右下角 Go Live，此時瀏覽器應自動開啟並顯示網頁 💡 Hint: 1.若在右下角沒看到 Live Server，請在程式碼區塊內按滑鼠右鍵，點擊 Open with Live Server。 2.網頁預設路徑: 127.0.0.1:5500。 👇 檢視你的網頁! 成功完成基本環境設定! 😆 📝 Getting Started 💡 Step 1: 複製Bootstrap Template到你的編輯器中 Starter template 1234567891011121314151617181920212223242526272829&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-B0vP5xmATw1+K9KRQjQERJvTumQW0nPEzvF6L/Z6nronJ3oUOFUFpCjEUQouq2+l&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;title&gt;Hello, world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;!-- Optional JavaScript; choose one of the two! --&gt; &lt;!-- Option 1: jQuery and Bootstrap Bundle (includes Popper) --&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot; integrity=&quot;sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js&quot; integrity=&quot;sha384-Piv4xVNRyMGpqkS2by6br4gNJ7DXjqk09RmUpJ8jgGtD7zP9yug3goQfGII0yAns&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;!-- Option 2: Separate Popper and Bootstrap JS --&gt; &lt;!-- &lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot; integrity=&quot;sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js&quot; integrity=&quot;sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js&quot; integrity=&quot;sha384-+YQ4JLhjyBLPDQt//I+STsc9iw4uQqACwlvpslubQzn4u2UU2UFM80nGisd026JF&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; --&gt; &lt;/body&gt;&lt;/html&gt; 👇複製貼上模板程式碼後，網頁畫面如下: 接下來就是發揮拼圖的實力啦~XD ((ps.純白地獄真D可怕😨 💡 Step 2: 將適合的Bootstrap Component原始碼放入你的網頁中 👉 你的拼圖底加(Bootstrap Components) 👇 1. 以網頁導覽列 (nav bar) 為例 1234567891011121314&lt;nav class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Navbar&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarNavAltMarkup&quot; aria-controls=&quot;navbarNavAltMarkup&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarNavAltMarkup&quot;&gt; &lt;div class=&quot;navbar-nav&quot;&gt; &lt;a class=&quot;nav-link active&quot; href=&quot;#&quot;&gt;Home &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt; &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;Features&lt;/a&gt; &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;Pricing&lt;/a&gt; &lt;a class=&quot;nav-link disabled&quot; href=&quot;#&quot; tabindex=&quot;-1&quot; aria-disabled=&quot;true&quot;&gt;Disabled&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; 💡Hint: Bootstrap 已經預先定義元件的屬性，所以我們可以不用list-based的形式建立導覽列。 Because we use classes for our navs, you can avoid the list-based approach entirely if you like. —Bootstrap 👇 2. 複製到template 👇 3. Component在瀏覽器的外觀 相信做到這邊，你已經迫不及待的想開始拼出一個網頁了吧!接下來我將介紹Bootstrap的Layout配置。😄 📝 Layout Components and options for laying out your Bootstrap project, including wrapping containers, a powerful grid system, a flexible media object, and responsive utility classes. — Bootstrap 💡Hint: 在Bootstrap裡，Container是用來放置Components的容器，同時它也關係到網頁在不同尺寸裝置上的外觀。 ⭐ 主要有3種不同的Container (CSS Class) : .container 根據螢幕寬度利用媒體查詢 (Media Query) ，設定變化的斷點，階段性的改變寬度，當改變瀏覽器的大小，頁面將一個階段一個階段變化。 123&lt;div class=&quot;container&quot;&gt; &lt;!-- Content here --&gt;&lt;/div&gt; .container-fluid 不考慮螢幕寬度，始終將寬度設定為auto，當縮放瀏覽器時，保持全屏大小(100%的寬度)。 123&lt;div class=&quot;container-fluid&quot;&gt; ...&lt;/div&gt; .container-{breakpoint} 透過Bootstrap寫好的 Media Query 調整頁面 如: .container-sm 1234&lt;div class=&quot;container-sm&quot;&gt;100% wide until small breakpoint&lt;/div&gt;&lt;div class=&quot;container-md&quot;&gt;100% wide until medium breakpoint&lt;/div&gt;&lt;div class=&quot;container-lg&quot;&gt;100% wide until large breakpoint&lt;/div&gt;&lt;div class=&quot;container-xl&quot;&gt;100% wide until extra large breakpoint&lt;/div&gt; 👇 .container-{breakpoint} 細節 介紹完Container後，緊接著介紹Bootstrap的欄位配置 — Grid System 😉 📝 Grid System Use our powerful mobile-first flexbox grid to build layouts of all shapes and sizes thanks to a twelve column system, five default responsive tiers, Sass variables and mixins, and dozens of predefined classes. — Bootstrap 💡Hint: Bootstrap 以 Grid System 規範網頁的版面配置 (列 - 欄) ，而1列在Bootstrap中被預設劃分為12欄。 ⭐ Setting Row &amp; Column 👇 不設定的col-size情況下，3欄均分12個欄位大小 (3 X 4) 12345678910111213&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col&quot;&gt; One of three columns &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; One of three columns &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; One of three columns &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; ⭐More Details ⬇️ 兩種主要col設定方式 (full size: 12): col-size 主動配置欄位大小 12345678910111213&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col&quot;&gt;col&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;col&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;col&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;col&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-8&quot;&gt;col-8&lt;/div&gt; &lt;div class=&quot;col-4&quot;&gt;col-4&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- 只寫.col時，會根據.col的數量均分12欄 --&gt; col-{breakpoint}-size 根據螢幕大小調整欄位配置 1234567891011&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-8&quot;&gt;col-sm-8&lt;/div&gt; &lt;div class=&quot;col-sm-4&quot;&gt;col-sm-4&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm&quot;&gt;col-sm&lt;/div&gt; &lt;div class=&quot;col-sm&quot;&gt;col-sm&lt;/div&gt; &lt;div class=&quot;col-sm&quot;&gt;col-sm&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 💡Hint: 關於breakpoint的設定，請參照上方的 .container-{breakpoint} 細節。 最後，讓我們動手拼出一個網頁吧! GOGOGO~ 👊 📝 Web Page Implementation 💡 Step 1: 尋找要用到的Component放到Starter Template 我的規劃: Nav Bar 123456789101112131415161718192021222324&lt;nav class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Navbar&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarTogglerDemo02&quot; aria-controls=&quot;navbarTogglerDemo02&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarTogglerDemo02&quot;&gt; &lt;ul class=&quot;navbar-nav mr-auto mt-2 mt-lg-0&quot;&gt; &lt;li class=&quot;nav-item active&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;Home &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link disabled&quot; href=&quot;#&quot; tabindex=&quot;-1&quot; aria-disabled=&quot;true&quot;&gt;Disabled&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;form-inline my-2 my-lg-0&quot;&gt; &lt;input class=&quot;form-control mr-sm-2&quot; type=&quot;search&quot; placeholder=&quot;Search&quot;&gt; &lt;button class=&quot;btn btn-outline-success my-2 my-sm-0&quot; type=&quot;submit&quot;&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/nav&gt; Carousel (原版沒有圖片，可以自行設定) 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;carouselExampleCaptions&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; &lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-target=&quot;#carouselExampleCaptions&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carouselExampleCaptions&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carouselExampleCaptions&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt; &lt;/ol&gt; &lt;div class=&quot;carousel-inner&quot;&gt; &lt;div class=&quot;carousel-item active&quot;&gt; &lt;img src=&quot;https://picsum.photos/1200/300?random=18https://picsum.photos/1200/300?random=18&quot; class=&quot;d-block w-100&quot; alt=&quot;...&quot;&gt; &lt;div class=&quot;carousel-caption d-none d-md-block&quot;&gt; &lt;h5&gt;First slide label&lt;/h5&gt; &lt;p&gt;Some representative placeholder content for the first slide.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;carousel-item&quot;&gt; &lt;img src=&quot;https://picsum.photos/1200/300?random=19&quot; class=&quot;d-block w-100&quot; alt=&quot;...&quot;&gt; &lt;div class=&quot;carousel-caption d-none d-md-block&quot;&gt; &lt;h5&gt;Second slide label&lt;/h5&gt; &lt;p&gt;Some representative placeholder content for the second slide.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;carousel-item&quot;&gt; &lt;img src=&quot;https://picsum.photos/1200/300?random=20&quot; class=&quot;d-block w-100&quot; alt=&quot;...&quot;&gt; &lt;div class=&quot;carousel-caption d-none d-md-block&quot;&gt; &lt;h5&gt;Third slide label&lt;/h5&gt; &lt;p&gt;Some representative placeholder content for the third slide.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;a class=&quot;carousel-control-prev&quot; href=&quot;#carouselExampleCaptions&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt; &lt;span class=&quot;carousel-control-prev-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;carousel-control-next&quot; href=&quot;#carouselExampleCaptions&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt; &lt;span class=&quot;carousel-control-next-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; Breadcrumb 1234567&lt;nav aria-label=&quot;breadcrumb&quot;&gt; &lt;ol class=&quot;breadcrumb&quot;&gt; &lt;li class=&quot;breadcrumb-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;breadcrumb-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;Library&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;breadcrumb-item active&quot; aria-current=&quot;page&quot;&gt;Data&lt;/li&gt; &lt;/ol&gt;&lt;/nav&gt; List Group 1234567&lt;ul class=&quot;list-group&quot;&gt; &lt;li class=&quot;list-group-item active&quot; aria-current=&quot;true&quot;&gt;An active item&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;A second item&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;A third item&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;A fourth item&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;And a fifth one&lt;/li&gt;&lt;/ul&gt; Image Gallery (自行設計的Component) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div class=&quot;col-12 col-md-9&quot;&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying a series of content. Modify and extend them to support just about any content within.&lt;/p&gt; &lt;div class=&quot;row item-group&quot;&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;https://picsum.photos/300/200?random=8&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;https://picsum.photos/300/200?random=2&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;https://picsum.photos/300/200?random=4&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;https://picsum.photos/300/200?random=5&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;https://picsum.photos/300/200?random=38&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;https://picsum.photos/300/200?random=32&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;https://picsum.photos/300/200?random=34&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;https://picsum.photos/300/200?random=35&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Pagination 1234567891011121314151617&lt;nav aria-label=&quot;Page navigation example&quot;&gt; &lt;ul class=&quot;pagination justify-content-center&quot;&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; Footer (自行設計的Component) 123&lt;div class=&quot;container-fluid main-footer text-center&quot;&gt; &amp;copy; copyright by QI-XIANG 2021&lt;/div&gt; 💡 Step 2: 將 Component 依序放進 Starter Template 👇 結果如下: 看起來還不錯，但還可以再做些調整，讓網頁更加美觀。😏 💡 Step 3 (Optional): 網頁細部調整 👇 請將下方程式碼複製到新檔案中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-B0vP5xmATw1+K9KRQjQERJvTumQW0nPEzvF6L/Z6nronJ3oUOFUFpCjEUQouq2+l&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;title&gt;Hello, world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Navbar&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarTogglerDemo02&quot; aria-controls=&quot;navbarTogglerDemo02&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarTogglerDemo02&quot;&gt; &lt;ul class=&quot;navbar-nav mr-auto mt-2 mt-lg-0&quot;&gt; &lt;li class=&quot;nav-item active&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;Home &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link disabled&quot; href=&quot;#&quot; tabindex=&quot;-1&quot; aria-disabled=&quot;true&quot;&gt;Disabled&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;form-inline my-2 my-lg-0&quot;&gt; &lt;input class=&quot;form-control mr-sm-2&quot; type=&quot;search&quot; placeholder=&quot;Search&quot;&gt; &lt;button class=&quot;btn btn-outline-success my-2 my-sm-0&quot; type=&quot;submit&quot;&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div id=&quot;carouselExampleCaptions&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; &lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-target=&quot;#carouselExampleCaptions&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carouselExampleCaptions&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carouselExampleCaptions&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt; &lt;/ol&gt; &lt;div class=&quot;carousel-inner&quot;&gt; &lt;div class=&quot;carousel-item active&quot;&gt; &lt;img src=&quot;https://picsum.photos/1200/300?random=18&quot; class=&quot;d-block w-100&quot; alt=&quot;...&quot;&gt; &lt;div class=&quot;carousel-caption d-none d-md-block&quot;&gt; &lt;h5&gt;First slide label&lt;/h5&gt; &lt;p&gt;Some representative placeholder content for the first slide.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;carousel-item&quot;&gt; &lt;img src=&quot;https://picsum.photos/1200/300?random=19&quot; class=&quot;d-block w-100&quot; alt=&quot;...&quot;&gt; &lt;div class=&quot;carousel-caption d-none d-md-block&quot;&gt; &lt;h5&gt;Second slide label&lt;/h5&gt; &lt;p&gt;Some representative placeholder content for the second slide.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;carousel-item&quot;&gt; &lt;img src=&quot;https://picsum.photos/1200/300?random=20&quot; class=&quot;d-block w-100&quot; alt=&quot;...&quot;&gt; &lt;div class=&quot;carousel-caption d-none d-md-block&quot;&gt; &lt;h5&gt;Third slide label&lt;/h5&gt; &lt;p&gt;Some representative placeholder content for the third slide.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;a class=&quot;carousel-control-prev&quot; href=&quot;#carouselExampleCaptions&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt; &lt;span class=&quot;carousel-control-prev-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;carousel-control-next&quot; href=&quot;#carouselExampleCaptions&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt; &lt;span class=&quot;carousel-control-next-icon&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;nav aria-label=&quot;breadcrumb&quot;&gt; &lt;ol class=&quot;breadcrumb&quot;&gt; &lt;li class=&quot;breadcrumb-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;breadcrumb-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;Library&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;breadcrumb-item active&quot; aria-current=&quot;page&quot;&gt;Data&lt;/li&gt; &lt;/ol&gt; &lt;/nav&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;list-group&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item list-group-item-action active&quot; aria-current=&quot;true&quot;&gt;The current link item&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item list-group-item-action&quot;&gt;A second link item&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item list-group-item-action&quot;&gt;A third link item&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item list-group-item-action&quot;&gt;A fourth link item&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item list-group-item-action disabled&quot; tabindex=&quot;-1&quot; aria-disabled=&quot;true&quot;&gt;A disabled link item&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-12 col-md-9&quot;&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying a series of content. Modify and extend them to support just about any content within.&lt;/p&gt; &lt;div class=&quot;row item-group&quot;&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;https://picsum.photos/300/200?random=8&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;https://picsum.photos/300/200?random=2&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;https://picsum.photos/300/200?random=4&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;https://picsum.photos/300/200?random=5&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;https://picsum.photos/300/200?random=38&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;https://picsum.photos/300/200?random=32&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;https://picsum.photos/300/200?random=34&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-12 col-md-3&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;img class=&quot;img-fluid&quot; src=&quot;https://picsum.photos/300/200?random=35&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;List groups are a flexible and powerful component for displaying&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;nav aria-label=&quot;Page navigation example&quot;&gt; &lt;ul class=&quot;pagination justify-content-center&quot;&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt;&lt;a class=&quot;page-link&quot; href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-item&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;#&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;div class=&quot;container-fluid main-footer text-center&quot;&gt; &amp;copy; copyright by QI-XIANG 2021 &lt;/div&gt; &lt;!-- Optional JavaScript; choose one of the two! --&gt; &lt;!-- Option 1: jQuery and Bootstrap Bundle (includes Popper) --&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot; integrity=&quot;sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js&quot; integrity=&quot;sha384-Piv4xVNRyMGpqkS2by6br4gNJ7DXjqk09RmUpJ8jgGtD7zP9yug3goQfGII0yAns&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;!-- Option 2: Separate Popper and Bootstrap JS --&gt; &lt;!-- &lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot; integrity=&quot;sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js&quot; integrity=&quot;sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js&quot; integrity=&quot;sha384-+YQ4JLhjyBLPDQt//I+STsc9iw4uQqACwlvpslubQzn4u2UU2UFM80nGisd026JF&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; --&gt; &lt;/body&gt; &lt;style type=&quot;text/css&quot;&gt; .main-footer&#123; padding: 20px 0; background-color: #000; color: white; &#125; .item-group .item img&#123; width: 100%; /* 在螢幕小的裝置上讓圖片滿版 */ &#125; .item-group .item&#123; text-align: center; &#125; &lt;/style&gt; &lt;/html&gt; 👇 結果如下: 調整後是不是變得有點專業呢? 😃 📝 Conclusion 💡 小結論 Bootstrap可以節省設計每個網頁區塊的時間，藉由Bootstrap預先定義的 .class，我們可以很快的調整區塊的一些屬性。但如果想要更客製化網頁的話，還是要套用到自己寫的CSS，此時要注意不要過度使用 !important 強制更改Bootstrap預先定義的CSS。 在學完 框架 (Framework) 的基礎知識後，相信你對寫網頁開始有那麼一點感興趣吧?😂在網頁的世界裡充斥著非常豐富的技術知識，例如: SEO、AJAX、Web Security等…，網頁這片無盡的大海，正在前方等著各位去探索! 🚀 BONUS 1: Lorem Picsum ( 產生假圖 ) 說明: 寫網頁有時會遇到需要測試圖片的狀況，這時候假圖/隨機圖產生器就很重要了。Lorem Picsum 這個網站提供各式測試用圖片，你可以透過修改網址的方式，產生不同大小、外觀的圖片。 💡 Lorem Picsum 🚀 BONUS 2: CSS Box Model ( 盒子模型 ) 定義: The CSS box model describes the rectangular boxes that are generated for elements in the document tree and laid out according to the visual formatting model. 簡單來說平常寫的&lt;p&gt;lorem...&lt;/p&gt;，就可以看做是一個Box，而Box Model則規範Box在瀏覽器上的長相。 在Chrome裡滑鼠右鍵 檢查 (F12)，可以在右方(Styles)看到如下畫面 Margin: box 的外部距離區域 Border: box 的邊界 Padding: box content 外的填充區域 Content: Content實際的寬 X 高 💡Hint: Chrome提供的檢查功能可以提升我們在網頁設計上的效率，比如:你寫出的網頁在不同尺寸的裝置上顯示的版面差異，方便我們做進一步的RWD (Responsive Web Design) 規劃。","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"金魚也能學會寫網頁","slug":"金魚也能學會寫網頁","permalink":"https://qi-xiang.github.io/tags/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81/"}]},{"title":"財報狗教你挖好股 [3.價值評估-股價淨值比]","slug":"frdog3-2","date":"2021-07-01T17:06:11.000Z","updated":"2022-03-13T17:25:00.270Z","comments":true,"path":"2021/07/02/frdog3-2/","link":"","permalink":"https://qi-xiang.github.io/2021/07/02/frdog3-2/","excerpt":"","text":"產業獲利若不穩定，要看股價淨值比 本益比只適合用來判斷穩定獲利、甚至愈賺愈多的公司股價；當獲利不穩定，就不太適合用本益比當作指標，此時可考慮使用&quot;股價淨值比(Price-Book Ratio，PBR)&quot; 計算方式: 每股股價 / 每股淨值，愈高代表股價愈貴，愈低則代表股價愈便宜。 淨值: 資產(企業擁有的所有資源) - 負債(企業對外的借款) = 企業實際自有資金(股東權益) 每股淨值: 淨值 / 發行的股數 當股價淨值比遠低於1時，就代表股價可能被低估，可能會有一波反彈的行情。 科技股 - 設備折舊快，股價淨值比常遠低於1 一般而言，公司就算獲利不穩定，股價淨值比多半還是可以維持在1以上。但很多獲利不穩定的科技公司，股價淨值比卻常遠低於1。主因在於它們的價值被高估，科技公司常常需要面臨設備更新，舊設備的價值就會快速滑落，也因此科技公司的帳面價值是遠低於市場價值的，所以科技公司的淨值要打個折扣才符合真實狀況，這也是很多科技公司股價淨值比異常低的原因。 資產股 - 就算年年賠，股價淨值比仍居高不下 &quot;士紙&quot;就是一般人說的資產股，而資產股是指公司資產的實際價值遠高於帳面價值。相對常見的情況是公司在很久以前，以低價取得某些土地放到現在，近年土地價格不斷上漲，但公司沒對這些土地重新估價，所以才會導致公司的淨值被低估，股價淨值比也因此有偏高的狀況。 或許公司只要把某塊地賣掉就可以多賺幾十塊EPS，但公司真的會賣地嗎? 所以投資資產股還是謹慎點好。 景氣循環股 - 適用股價淨值比來回操作 所謂景氣循環股，意思是公司獲利與景氣連動性很強。追根究柢，就是公司所屬產業的供給、需求都很不穩定。 景氣循環股由於獲利不穩定，不適合用本益比操作，但可用股價淨值來估算合理股價。 操作景氣循環股時，可同時參考產品的報價，當產品的報價開始上揚時，股價反轉的機會更高。 股價淨值比愈墊愈低，暗示產業衰退 當判斷某家公司為景氣循環股，並試著使用股價淨值比來操作時，卻發現這家公司的股價淨值比竟然愈來愈低，就要有所警覺，這間公司不屬於景氣循緩產業，而是屬於衰退產業。 當公司的股價淨值比持續衰退時，其實就代表整個產業是持續衰退的，所以不建議使用股價淨值比操作正在衰退中的股票，因為股價的低點永遠無法被得知。 Written By Qi-Xiang 2021/07/03","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"財報狗挖好股精華","slug":"財報狗挖好股精華","permalink":"https://qi-xiang.github.io/tags/%E8%B2%A1%E5%A0%B1%E7%8B%97%E6%8C%96%E5%A5%BD%E8%82%A1%E7%B2%BE%E8%8F%AF/"}]},{"title":"財報狗教你挖好股 [3.價值評估-本益比判斷股價]","slug":"frdog3-1","date":"2021-06-30T16:20:11.000Z","updated":"2022-03-13T17:25:02.902Z","comments":true,"path":"2021/07/01/frdog3-1/","link":"","permalink":"https://qi-xiang.github.io/2021/07/01/frdog3-1/","excerpt":"","text":"獲利成長性可預測-採本益比判斷股價高低 若公司通過&quot;獲利性佳&quot;、&quot;安全性高&quot;的檢驗，就可以放入選股的觀察名單。接下來進入非常重要的一步，“評估合理的股價”，畢竟買到好股票，但買貴了，還是會面臨套牢。 “本益比”(Price Earnings Ratio，PE)。&quot;本&quot;是股價，&quot;益&quot;是稅後盈餘(稅後淨利)，本益比是每股股價相當於每股盈餘(Earnings Per Share，EPS)的倍數。 本益比愈高，外部股東報酬率愈低 把本益比倒過來，則變成&quot;EPS / 每股股價&quot;，又稱為&quot;外部股東報酬率&quot; (公司為股東賺到的報酬率)。 若是採用台灣證券交易所的本益比公式，EPS是用過去4季EPS總和，而非採用未來4季的預估值，所以當EPS呈現衰退走勢時，會使得公司的本益比看起來很低。(ps. 無法及時反應現在的EPS走勢) EPS呈成長走勢，本益比容易被高估(ps. 理由同上)。 不同產業成長階段，會有不同本益比 公司合理的本益比，與EPS成長性有關。若公司每年EPS變動不大，合理本益比約為10倍。若EPS呈成長趨勢，則本益比可以更高；相反，若EPS呈衰退趨勢，則本益比就應低於10倍。 高成長產業 -&gt; 低成長產業 -&gt; 衰退性產業 (本益比: 高 -&gt; 低) 同產業的公司，本益比未必相同。公司股價的合理本益比，與EPS成長性有關，並不是相同產業的公司就可以一概而論；同一產業中，各家公司的成長性可能大不相同。 用EPS年複合成長率，算出個股&quot;目標價&quot; 公司合理的本益比，只與公司的EPS成長性有關。因此，在決定公司合理本益比前，要先問自己有辦法判斷公司的EPS成長性嗎? 一家公司的EPS若持續衰退，合理的本益比就該是0，不適合長期投資。 夢想未來EPS大成長，換來本夢比崩潰 “本夢比&quot;取代&quot;本益比”，造成股價漲勢驚人，主因是市場認為該產業未來的EPS成長率很高。一段時間後，若公司的EPS仍舊沒有什麼成長，而市場還在持續作夢的話，股價與本益比遲早會向下修正，投資人一定要特別留意。 Written By Qi-Xiang 2021/07/01","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"財報狗挖好股精華","slug":"財報狗挖好股精華","permalink":"https://qi-xiang.github.io/tags/%E8%B2%A1%E5%A0%B1%E7%8B%97%E6%8C%96%E5%A5%BD%E8%82%A1%E7%B2%BE%E8%8F%AF/"}]},{"title":"BDC CH5: Network Layer","slug":"CH5","date":"2021-05-12T08:33:09.000Z","updated":"2022-03-13T17:25:25.599Z","comments":true,"path":"2021/05/12/CH5/","link":"","permalink":"https://qi-xiang.github.io/2021/05/12/CH5/","excerpt":"","text":"CH5: Network Layer Network Transmission 路由器要事先進行路由設定/持續與其他路由器交換學習，根據收到的封包查表轉送至nexthop(下一跳) 終端使用者不須擔心routing問題，對外路由委由路由器處理，僅須設定好default gateway將離開區域網路的封包往gateway介面送 原則上來回的路由要一致，滿足此條件時稱為Symmetric Route(對稱路由) 實際上則會因其他因素(ex. transit service)，而出現Asymmetric Route(不對稱路由)，來回路由不同 持續傳送的packet如水流一般，可用packet flow/flow(封包流)作為代稱 Transmission Bottleneck layer3的傳輸速率理論最大值會受到更下層的Physical Layer和Data Link Layer所限制 封包流(Flow)路徑的最大傳輸速率會受限於速率最小的那一段 Layer3環境中也可以使用Layer3 header中的特徵值搭配政策進行流量控制 Performance Criteria Delay Processing delay (Layer3) Queueing Delay (Layer3+) 路由器的處理器和緩衝區記憶體大小都會造成效能上的影響 Throughput Bandwidth(bps/Kbps/Mbps/Gbps…) Packet Per Second (PPS) PPS差，Bandwidth大也沒有用 Packet Loss / Jitter (掉包/抖動) Congestion(壅塞)/Flow Control Quality of Service (QoS) -&gt;劃分packet傳送的優先權，吃到飽網路QoS優先度低 Bandwidth limitation (traffic shape) 限流速 -&gt; bit Amount limitation 限總流量 -&gt; byte Best effort delivery The policy will try its best to provide service without any gurantee that meets any quality of service request in real, best effort means “no effort”","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"BDC","slug":"BDC","permalink":"https://qi-xiang.github.io/tags/BDC/"}]},{"title":"BDC CH4e: Link Layer 補充資料","slug":"CH4e","date":"2021-05-11T11:42:09.000Z","updated":"2022-03-13T17:25:27.823Z","comments":true,"path":"2021/05/11/CH4e/","link":"","permalink":"https://qi-xiang.github.io/2021/05/11/CH4e/","excerpt":"","text":"CH4e: Link Layer 補充資料 Virtual Local Area Network (VLAN) 實際上共用同一實體設施 Advantage of VLAN: Creating multiple logical LANs on physical device for saving time and cost 運用邏輯切割 Managing grouped hosts in corresponding VLANs Improving the security (per VLAN are kept in different logical VLANs) 防止大規模ARP，或節點過多難以追蹤 透過 VLAN id 追蹤 Cross-VLAN traffic should be delivering by gateway interfaces on router (Layer3) 要跨VLAN傳輸時，要透過layer3 Router Access Port VLAN-enabled switch, “push” corresponding VLAN tag to incoming packets Each interface on switch belongs to a specific VLAN For “Native VLAN” (without-tag), tag value = 1 (保留值) For other VLAN, the tag value would be its corresponding to its VLAN ID (2~4095) VLAN tag 放進 layer2 header (VLAN id) 一開始的packet並無VLAN tag / id，到達Switch才被賦予 For outgoing traffic (傳輸到destination前的最後一個switch) “Pop” the VLAN tag and forward the packet to corresponding host Trunk Port Carry multiple VLAN tag (可傳送有不同VLAN tag的封包) Switch之間的骨幹網路 The VLAN tag could be selected, not all accepted During the transmission, the overall operation still satisfies required actions in layer2 transmission (ex. ARP) Access Port -&gt; 加/減 tag (VLAN)，Trunk Port -&gt; forwarding different VLAN tags MAC Address Flapping Switch有學習MAC address功能，會將之記錄在MAC address table上 可能因使用者改變port，而出現MAC Address Flapping問題 在MAC address table上的同一MAC address同時記錄兩個Port Number Switch會不知道該往哪一個port傳送packet Solution 經過一段時間，MAC address table上的紀錄會消失，flapping亦隨之消失 可在Switch的port上設定僅讓特定MAC address通過 Security Problem Hacker可修改MAC address，塞滿switch MAC address table，造成所有packet無法傳送(刻意製造flapping) Network Loop A network loop usually occurs when a network has multiple available active paths for carrying information from one source to aother destination 盡量避免在底層出現loop 有可能不知道傳輸方向 大檔案被切割為多封包傳送，但在有loop下，難以確認傳送路徑 -&gt; high latency Loop Problem slow speed、irregular connection、network failure 有機會在destination收到相同的兩個packet Broadcast Storm Accumulation of broadcast and multicast traffic on a computer network that causes massive transmission No “Time-To-Live (TTL)” value in layer 2 header, it can keep looping forever 發生時機 網路拓樸中有迴圈、網路設備故障、網卡損壞、資安攻擊等… 透過VLAN只能讓VLAN彼此間不互相影響，但不能防止單一VLAN內出現Broadcast Storm How to prevent ? Enable detection method Setup per-port threshold value (broadcast control policy) -&gt; 在port上設定封包量的門檻值 Deploy security device (ex. firewall) to filter abnormal broadcasts Approach Denial of Service (DoS) Serious Problem Smurf attack (對目標網路廣播大量的ICMP封包，並將來源IP address更換為受害者) Fraggle attack (類似Smurf attack，但使用假造來源的UDP broadcast封包) Spanning Tree Protocol (STP) 生成樹協定 Protocol use to build a non-looping topology for Ethernet 初期不支援VLAN Originally standardized as IEEE 802.1d, while it also has improved standards 802.1w -&gt; Rapid Spanning Tree Protocol (RSTP) -&gt; 在網路發生變化時，能快速產生新拓樸(加快速度會造成資源浪費) 802.1s -&gt; Multiple Spanning Tree Protocol 進一步支援實體設備的&quot;VLAN&quot;生成樹 -&gt; 在每個VLAN下傳送STP packet 關閉redundant links作為備援線路 When enabling STP, all switches will constantly communicate with each other (under same LAN) with BPDUs (Bridge Protocol Data Units) -&gt; STP送出的資訊 By BPDUs, switch would be able to select the best connection towards the root bridge for forwarding traffic (block the redundant link at the same time) The information makes network to create a logical topology over physical topology Every bridge has a “build-id” Making one port if each bridges as the “root port” 啟用STP根據BPDU可以得知細部資訊 Enabling STP, finding the shortest path and the spanning tree for the switch no-loop 拓樸收斂 Forwarding and blocking ports by using information from the spanning tree 根據權重(path cost)決定要關閉的redundant links How to calculate the “Path Cost” ? Default STP 1 Gbits / bandwidth Default RSTP 20 Gbits / bandwidth 5 types of Port Status during STP calculation Blocking BPDU data will be received for letting spanning tree algorithm determine if this port shuld be active again 資訊不傳，但BPDU data仍會持續傳 Listening 狀態不明，不forwarding資料 no further transmission actions would be processed 資訊不傳，但BPDU data仍會持續傳 Learning Source MAC address would be learned and put into MAC address table by switch Forwarding monitors BPDUs for preventing the loop Disabled manually disabled on this port Link Aggregation 鏈路聚合 Link aggregation use aggregating methods to combine multiple network links in parallel as an EtherChannel between two devices also called as bundling, bonding, channeling or teaming larger bandwidth and better redundancy Physical links which are joined the same group will be seen as a part of logical link, and it won’t triggerthe looping issue 在邏輯上把兩條線當作一條線使用 Static On Mode A simple way to build EtherChannel is using Static On Mode, putting all related ports to the same group port兩端沒有溝通機制，會有loop出現的風險 Port Aggregation Protocol (PAgP) Cisco’s port aggregation method used to build EtherChannel Two modes in PAgP, one is Desirable, another is Auto Desirable mode makes switch to send PAgP message for negotiation Auto mode is just waiting passively 最少要有一端為Desirable才能啟用 Note: PAgP aggregation, the configuration of each port must be the same Link Aggregation Control Protocol (LACP) LACP is IEEE standard, aggregate ports to build EtherChannel 最少要有一端是Active才能夠啟用 Two modes in LACP, Active and Passive Active mode makes switch to send LACP message for negotiation Passive mode is just waiting passively Note: LACP aggregation, the configuration of each port also must be the same","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"BDC","slug":"BDC","permalink":"https://qi-xiang.github.io/tags/BDC/"}]},{"title":"BDC CH4: Data Link Layer","slug":"CH4","date":"2021-05-10T02:11:09.000Z","updated":"2022-03-13T17:25:30.178Z","comments":true,"path":"2021/05/10/CH4/","link":"","permalink":"https://qi-xiang.github.io/2021/05/10/CH4/","excerpt":"","text":"CH4: Data Link Layer Introduction Data-link layer of a broadcast link Data Link Control Sublayer + Media Access Control Sublayer Pass through Router MAC address change IP address do not change Pass through Switch MAC address do not change IP address do not change Media Access Control (MAC) Address Unicast (One to One, Individual) Universally administered (廠商設定) x0/4/8/C-xx-xx-xx-xx-xx Locally adminstered (本地設定) x2/6/A/E-xx-xx-xx-xx-xx Multicast (One to Many or Many to Many, Group) -&gt; 可以到subnet (same group) Universally administered x1/5/9/D-xx-xx-xx-xx-xx Locally adminstered x3/7/B/F-xx-xx-xx-xx-xx Broadcast address would be FF-FF-FF-FF-FF-FF A broadcast frame will be flooded &amp; forwared to the other nodes in the network OUI (Organizationally Unique Identifier) A 24-bit number that uniquely identifies its vendor or manufactuer (ex. Prefix) MAC可經由手動更改，故不可完全相信 Adress Resolution Protocol (ARP) ARP request is broadcast ARP reply is unicast Linux / wired network Source hardware address (Source MAC address) Source protocol address (Who ask -&gt; IP address) Destination hardware address Empty in request (要先經由ARP得知) Destination protocol address (Answer to whom -&gt; IP address) Ethernet Layer 2 data-link Unit used in network communicating over Ethernet is called ‘‘Frame’’ Data link protocol, containing Ethernet header and payload Transmission Medium (legacy) Coaxial Cable (common) Twisted pair cable (common) Fiber optic cable 補充資料 Fast Ethernet IEEE 802.3u standard When working in half-duplex mode Requires Carrier Sense Multiple Access with Collision Detection (CDMA/CD) Gigabit Ethernet IEEE 802.3z standard When working in full-duplex mode CSMA/CD is not necessary Ethernet Frame Header Common used (Ethernet Type2 Frame): MAC header Destination MAC address (6 bytes) Source MAC address (6 bytes) Ether Type (2 bytes) Data Payload (46-1500 bytes) FCS (Frame Check Sequence) CRC checksum (4 bytes) Structure Preamble SFD Destination MAC Address Source MAC Address Ether Type Payload FCS Inter-packet gap Ether Type 0x0800 -&gt; IPv4 0x0806 -&gt; ARP 0x8100 -&gt; VLAN-tagged 0x86DD -&gt; IPv6 0x9100 -&gt; VLAN-tagged (double tagging) Ethernet Frame Header Maximum Transmission Unit (MTU) Size of the largest Protocol Data Unit (PDU) 1518 bytes by default 18 bytes for layer2 header, 1500 bytes for layer2 payload Jumbo Frames 1500+ bytes of payload Most Ethernet equipment supports to 9000+ bytes for jumbo frames IEEE 802.1Q Referred as dot1q Support VLANs (Virtual LANs) hint: Native VLAN -&gt; id = 1 IEEE 802.1ad Referred as Q-in-Q (double tagging) Allow to use another VLAN internally for carrying traffic that is already tagged 補充資料 Checksum Checksum is able to use a small-sized block of data to help datect the corrupted data during the transmission (or storage) Cyclic Redundancy Check (CRC) CRC檢查碼編碼","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"BDC","slug":"BDC","permalink":"https://qi-xiang.github.io/tags/BDC/"}]},{"title":"BDC CH3: Physical Layer","slug":"CH3","date":"2021-04-11T14:33:09.000Z","updated":"2022-03-13T17:25:32.576Z","comments":true,"path":"2021/04/11/CH3/","link":"","permalink":"https://qi-xiang.github.io/2021/04/11/CH3/","excerpt":"","text":"CH3: Physical Layer Digital-to-Digital Conversion Non-return to Zero Level (NRZ-L) 1: negative voltage 0: positive voltage synchronization problem: transmitting a long sequence of 1s or 0s Non-return to Zero Invert (NRZ-I) 1: voltage change 0: no change synchronization problem: transmitting a long sequence of 0s Manchester 1: low to high 0: high to low (Z-shape) ex. 10BaseT Differential Manchester 1: no change at the begining 0: change at the begining ex. Token RingAmplitude Analog-to-Digital Conversion Pulse Code Modulation (PCM，脈衝編碼調變) A scheme for converting analog singnal to digital data(類比訊號編碼為數位訊號) Pulse Amplitude Modulation (PAM，脈衝振幅調變) 將原本的波型轉變為脈衝訊號(類比訊號取樣) Measuring the amplitude of the signal at equal intervals Using PAM (Pulse Amplitude Modulation) to digitalize PAM(取樣)-&gt;PCM(編碼) Nyquist Theorem(奈奎斯特取樣定理) To ensure the accurate reproduction of an original analog signal using PAM, the sampling rate must be “at least twice” the highest frequency of the original signal 為避免訊號失真，信號在取樣時所使用的頻率，必須要為原訊號頻率的二倍以上 When we want to digitize the human voice (0 to 4000 Hz), what is the bit rate, assuming 8 bits per sample? Answer: Simple rate = 4,000 * 2 (nyquist theorem) = 8,000 Bit rate = 8,000 * 8 = 6,4000 bps = 64 Kbps [補充] Ethernet Physical Layer Transfer speed = lanes * bits per hertz * spectral bandwidth 1Gbps = 4 X 4 X 62.5","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"BDC","slug":"BDC","permalink":"https://qi-xiang.github.io/tags/BDC/"}]},{"title":"財報狗教你挖好股 [2.安全性分析-自由現金流]","slug":"frdog2-3","date":"2021-04-07T12:18:11.000Z","updated":"2022-03-13T17:25:05.534Z","comments":true,"path":"2021/04/07/frdog2-3/","link":"","permalink":"https://qi-xiang.github.io/2021/04/07/frdog2-3/","excerpt":"","text":"是賺錢還是燒錢?自由現金流告訴你 一家公司獲利很高，且賺回來的現金充沛，是否就可以構成買進的理由呢? 還不夠! 得看看這家公司留下多少錢給股東 首選能存現金的公司，避開高資本支出&quot;慘&quot;業 公司賺的現金多，但如果燒錢(資本支出高)更兇，那最終留給股東的現金終究是少得可憐。如果長期入不敷出、吃光老本，將促使企業長期向外舉債，讓企業財務風險上升，或是股本膨脹稀釋獲利，對於投資人來說不是好事。 面版、DRAM、LED、太陽能，為何被稱為四大&quot;慘&quot;業? 因為他們都是相當燒錢的產業，這些產業的擴廠、擴增產線等相關資本支出極高，往往在資金尚未回收時，就被迫投資下一代技術。如此年復一年，資金缺口越來越大，體質越來越差，公司就有倒閉可能。 容易留下現金的公司，在遇到需求暴增的大好機會，就能利用自有資金大舉擴廠，不須對外大幅舉債增資，使得體質保守穩健；在沒有更好的投資機會時，也能有多餘現金配出高現金股利給股東。 燒錢不兇、能存下現金的公司，通常會是投資首選。 3條件檢視自由現金流，判斷燒錢兇不兇 自由現金流(紀錄在現金流量表上) = 營業現金流入(公司本身營運帶回的現金) - 投資現金流出(擴廠、購併等…)。這些剩餘現金可以用來還債、再投資、或轉成股利發還股東等…，全憑公司&quot;自由&quot;運用。 觀察自由現金流的方法、條件 1.避開短期季節性資金應用差異，應以&quot;年度數據&quot;作為主要觀察。 2.近8年自由現金流量，其中至少4~5年以上為正值 3.近8年現金流量，總和為正值 DRAM獲利趕不上擴廠，自由現金長期不足 以DRAM大廠南亞科為例，觀察2005年到2012年的自由現金流量，可以發現: 8年自由現金流量中，其中6年為負值。 8年自由現金流量，總和約-1,307億元，為負值。 DRAM產業的高資本支出特性，使得南亞科資金需求極大，但其在全球供應市佔率低，造成獲利不足以支應不斷的擴廠需求。由於自由現金流長期不足，南亞科只能向外舉債增資。 現金就像企業的&quot;血液&quot;，自由現金流長期流出公司，就像血液不斷流失般，只能靠&quot;輸血維生&quot;，這種企業體質相當地不健康。 台股獲利王發了股利少了現金，也是燒錢公司 以面版大廠宸鴻光電TPK-KY為例，公司在2008年上市，觀察2008年到2012年這5年的自由現金流量狀況，可以發現: 5年自由現金流量，其中3年為負值。 5年自由現金流量，總和約為-197億元，為負值。 自由現金流的流出持續擴大，代表公司賺來的錢根本不夠燒。但宸鴻光電在2011年仍然配出每股20元的高現金股利(總計51億元現金股利)，公司在2011年靠自身營運，只賺回179億7,800萬元營業現金流入，扣除資本支出後，自由現金流出為負值。 到底宸鴻光電發放的現金從何而來? 觀察公司借貸狀況，發現2012年短期借款多了近59億元，長期借款新增近11億元。(借錢發高額現金股利) 在公司急需現金的狀況下，若不配發高現金股利，宸鴻光電的借款或許可以降低，使財務結構更穩健，但公司賺這麼多錢，若不發放現金股利，股東可能會抱怨，最終公司選擇發放現金股利。 看完宸鴻光電的例子，可以了解到&quot;不只獲利有虛實之分，連現金股利也有虛實差異&quot;，倘若投資人重視公司發放現金股利的能力，就應該重視自由現金流量，因為充沛的現金流入，才是高現金股利的源頭。 資本支出有成效，就能帶回正向現金流 以亞洲最大烘焙設備製造商新麥為例，觀察公司2004年到2011年的自由現金流量狀況，可以發現: 8年自由現金流量，僅3年為負值。 8年自由現金流量，總和5億4,300萬元，為正值。 從新麥的例子可以得知，公司有資本支出是必然的，只要在未來的3~4年皆能帶回更多現金，就是成功的投資。 在觀察現金流量時，宜注意長期表現，而非注重短期(1~3年)就下定論! Written By Qi-Xiang 2021/04/07","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"財報狗挖好股精華","slug":"財報狗挖好股精華","permalink":"https://qi-xiang.github.io/tags/%E8%B2%A1%E5%A0%B1%E7%8B%97%E6%8C%96%E5%A5%BD%E8%82%A1%E7%B2%BE%E8%8F%AF/"}]},{"title":"財報狗教你挖好股 [2.安全性分析-營業現金流]","slug":"frdog2-2","date":"2021-04-06T15:29:11.000Z","updated":"2022-03-13T17:25:07.774Z","comments":true,"path":"2021/04/06/frdog2-2/","link":"","permalink":"https://qi-xiang.github.io/2021/04/06/frdog2-2/","excerpt":"","text":"營業現金流-赤裸呈現獲利含金量 獲利只是報表上的數字，公司必須能真正收回&quot;現金&quot;，把鈔票放進口袋才能算數。 營業現金流佔淨利比重，衡量公司獲利品質 “現金流量表&quot;上的&quot;營業現金流入”，紀錄的是企業藉由&quot;自身營運&quot;所帶進來的現金流，並不包含向外借錢或跟股東要錢的部分。 公司獲利含金量 = 營業現金流入 / 稅後淨利 * 100% (得出的數字為90%，代表100元的獲利，可以拿到90元的營業現金) 獲利含金量標準 1.長期獲利含金量80%~100%以上才是名副其實 2.長期獲利含金量低於50%，應探究其營業現金流短缺原因 營業現金流持續流出、融資現金流上升 應收帳款和其他應收款大幅增加，現金沒有回收 資金壓力高 獲利含金量不足，股市過熱就該注意 以美嘉電為例，公司長年虧損，2009年卻突然出現轉虧為盈。配合金融海嘯後，台股的反彈熱潮，股價從9元，一路漲到148.5元，大約半年時間漲幅超過15倍。但仔細觀察美嘉電的獲利含金量，卻發現轉虧為盈的2009年期間，營業現金流入對淨利比長期低於50%或呈現負值，也就是現金流入遠低於帳面獲利，甚至流出。在獲利含金量不足的疑慮下，股價沒有實質盈餘支撐，有過熱高估的嫌疑。隔年2010年7月後，美嘉電從111.27元快速崩跌回14元。2011年，這家公司傳出假帳案，最終於2012年4月30日停止交易。 想要穩健創造長期獲利的投資人，都應該避開像美嘉電這樣的投資標的；沒有大戶老手的本事，就不要以僥倖心態加入投機遊戲。 Written By Qi-Xiang 2021/04/06","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"財報狗挖好股精華","slug":"財報狗挖好股精華","permalink":"https://qi-xiang.github.io/tags/%E8%B2%A1%E5%A0%B1%E7%8B%97%E6%8C%96%E5%A5%BD%E8%82%A1%E7%B2%BE%E8%8F%AF/"}]},{"title":"財報狗教你挖好股 [2.安全性分析-分辨負債品質]","slug":"frdog2-1","date":"2021-04-03T10:41:11.000Z","updated":"2022-03-13T17:25:10.066Z","comments":true,"path":"2021/04/03/frdog2-1/","link":"","permalink":"https://qi-xiang.github.io/2021/04/03/frdog2-1/","excerpt":"","text":"分辨負債品質，看出企業真實債務壓力 重點回顧: 公司營運資金來源主要有兩種，股東權益(自有資金，如普通股、保留盈餘等)和負債(對外借款，如銀行借款、供應商賒帳等) 從經營與資本效率的考量，企業可以適當地舉債。 聰明舉債 借力使力，賺取更多報酬 若堅持不借錢，使資金不足而無法投資，雖然省下了利息成本，卻可能喪失數十倍的獲利可能性。 提高營運資金的利用效率 企業間交易金額龐大，如果全部用現金交易，整個生產流程，為了等待現金入帳而被耽擱，整體效率反而會降低。因此適當的賒欠帳款，在商業營運過程是必須的。適當的負債可讓公司資金運轉順利。 單以負債比衡量財務結構，容易冤枉好公司 傳統的指標採用&quot;負債比&quot;，計算方式為&quot;負債 / 總資產 * 100%&quot;，通常以50%作為分界，超過則負債偏高 實際上，負債比容易以偏概全，因為負債項目中，有些是沒有利息或利息極少的好債 好債 向上游供應商進貨，晚點再付錢 會計上稱為&quot;應付帳款&quot;，記錄在資產負債表的&quot;流動負債&quot; 公司規模龐大時，越能和上游談條件，以降低短期資金壓力 這些拖欠的帳款不須付利息，就像是供應商提供的短期借款 在流動負債中，應付帳款金額高，代表公司對上游廠商具有不錯的議價能力 先跟下游客戶拿錢晚點再出貨 在會計上稱為&quot;預收款項&quot;，記錄在資產負債表的&quot;流動負債&quot; 預收款項雖然在財務上屬於負債，但對企業幾乎不構成現金壓力 先收進來的款項，不僅減少短期資金壓力，也增加資金運用的彈性 能跟客戶預先收款的公司，通常代表著對下游客戶有無與倫比的吸引力 從&quot;長短期金融負債比&quot;，才能看出企業負債壓力 透過長短期金融負債比，可以觀察公司有哪些債務需要實際支付利息。 這些債務包括4個項目 短期借款 應付短期票據 一年內到期的長期負債 長期負債 長短期金融負債比 = 長短期金融負債 / 總資產 * 100%，以不超過40%為理想，30%以下為穩健 總結 1.應付帳款是向供應商賒欠的好債 2.預收帳款是向客戶賒欠的好債 3.以長短期金融負債比衡量財務結構更為恰當 Written By Qi-Xiang 2021/04/03","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"財報狗挖好股精華","slug":"財報狗挖好股精華","permalink":"https://qi-xiang.github.io/tags/%E8%B2%A1%E5%A0%B1%E7%8B%97%E6%8C%96%E5%A5%BD%E8%82%A1%E7%B2%BE%E8%8F%AF/"}]},{"title":"BDC CH2: Network Model","slug":"CH2","date":"2021-03-29T15:33:09.000Z","updated":"2022-03-13T17:25:35.013Z","comments":true,"path":"2021/03/29/CH2/","link":"","permalink":"https://qi-xiang.github.io/2021/03/29/CH2/","excerpt":"","text":"CH2: Network Model Protocol Layering 定義通訊上的規則 A protocol defines the rules that both the sender and receiver and all intermediate devices need to follow to be able to comunicate effectively Same layers do the same thing (同一層做相同/相似的事) Difference between TCP/IP Model and OSI Model TCP/IP model has four different layers: (對照到OSI Model) Application(Application+Presentation+Session) HTTP、FTP、TELNET、NTP、DHCP、PING Transport(Transport) TCP、UDP Network(Network) IR、ARP、ICMP Network Interface(Data Link + Physical) Ethernet、Fiber、Routers、Switches How to make communication approach? Cross layer en-capsulation and de-capsulation 把上層送來的內容當成自己這層的payload再加上自己這層的header後包在一起往下層送 收到下層送來的整包內容後先拆解掉屬於自己這層的header再把payload往上層送 因此header會在過程中不斷被修改 TCP/IP Protocol Suite(僅列重點，詳細看講義) Physical Layer Data format: bit Major duties: topology simplex、 half-duplex、full-duplex direction of data flow…etc Data Link Layer Data format: frame Major duties: Framing and tagging 可以僅讓擁有特定tag的通過 增加tag到frame header中，可將第二層各內容進行分割 MAC Address(header) 決定送給哪一個實體層裝置 理論上唯一 Switching 根據MAC位置決定轉發給誰 Address Resolution Protocol(ARP) Find the link layer (physical) address of the device(找MAC位置) 一開始以廣播方式尋找目的地之MAC位置 switch有紀錄功能，所以可依特定路徑傳送frame Network Layer Data format: datagram (packet，封包) Major duties: IP address Routing (連接不同的子網路/網段) Find the next hop Internet Protocol(IP位置) 路由器可透過路由協定去學習封包如何前往其他網域的路徑，並在自身維護一個路由表紀錄Next-hop資訊供IP routing所使用 封包IP位置不在路由表內則被丟棄 和自己不同子網域的IP電腦溝通需要依靠Layer IP routing Transport Layer Data format: TCP segment / UDP datagram Major duties: Service port mapping Connection (TCP) or connectionless (UDP) TCP會檢查是否有漏payload Flow control Error control Retransmission Some Important Number FTP: 20、21 SMTP: 25 DNS: 53 HTTP: 80 SSH: 22 TELNET: 23 DHCP: 67 Details of each transmission protocol Transmission Control Protocol (TCP) Reliable-connection Btye-oriented Retransmission User Datagram Protocol (UDP) Unreliable-transmission Message-oriented Stream Control Transmission Protocol (SCTP) Reliable-connection Message-oriented Combine the best features of TCP and UDP Application Layer Data format: Message Common protocols: HTTP、FTP、SMTP…etc Multiplexing and De-multiplexing Message to Packet -&gt; Multiplexing Packet to Message -&gt; De-multiplexing (還原訊息) 依照目的地傳送封包 大訊息可能被拆成數個封包進行傳送 OSI Reference Model PDU (Protocol Data Unit) ex. Data、Segement/Datagram、Packet、Frame、Bit/Symbol SDU (Service Data Unit) payload PDU = SDU (payload) + Protocol Header At the layer N, the SDU will be added “layer N header” to produce a layer N PDU. After that, it will be passed to layer N-1. This process continues util reaching the layer 1.","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"BDC","slug":"BDC","permalink":"https://qi-xiang.github.io/tags/BDC/"}]},{"title":"財報狗教你挖好股 [1.獲利性分析-股東權益報酬率]","slug":"frdog1-3","date":"2021-03-22T17:49:36.000Z","updated":"2022-03-13T17:25:12.078Z","comments":true,"path":"2021/03/23/frdog1-3/","link":"","permalink":"https://qi-xiang.github.io/2021/03/23/frdog1-3/","excerpt":"","text":"股東權益報酬率 股東權益報酬率 = 淨利 / 股東權益(自有資金) * 100% 股東拿錢出來投資一家公司，這筆錢稱為股東權益 4種ROE型態，顯示公司以自有資金賺錢的能力 觀察ROE的高低與走勢，可以看出公司所處產業的特性，有利判斷投資方向 觀察ROE的時間越長越好，最好超過兩個景氣循環的時間，也就是6~8年的時間 1.平穩型-&gt; 受景氣波動影響小，多為民生必需產業 2.大幅波動型(不宜長期投資) -&gt; 受景氣影響大，多為景氣循環股 3.趨勢向下型 -&gt; 夕陽產業或公司競爭力衰退 4.趨勢向上型 -&gt; 火紅產業或公司具有競爭實力 利用&quot;杜邦分析&quot;看出公司ROE變化玄機 杜邦分析法將ROE拆成3項財務數字: 1.淨利率 2.總資產周轉率 3.權益乘數 淨利率: 代表公司獲利能力 = 淨利 / 營收 總資產周轉率: 公司利用資產創造營收的效率 = 營收 / 總資產 權益乘數: 公司使用的財務槓桿大小 = 總資產 / 股東權益 (負債越多就越大) ROE = 淨利率 X 總資產周轉率 X 權益乘數 淨利率推動ROE上升，才是名副其實績優股 若公司的ROE成長單純來自&quot;總資產周轉率&quot;的提升，代表好業績來自短期營收的衝刺，甚至可能有削價競爭的情況 ROE提高但淨利率下滑，營收反轉時股價恐跌 若ROE提高淨利反而下滑，則須注意是來自總資產周轉率或權益乘數的成長 總資產周轉率提高可能來自削價競爭 權益乘數提高可能來自公司的債務 月營收開始下跌時，此類公司股價可能大幅向下修正 淨利率衰退連累ROE下滑，應避免長期投資 ROE下滑的主因為淨利率的公司，不宜作為長期投資標的 經營者資金操作轉趨保守，亦會拉低ROE 在資金操作方面降低負債，代表經營者心態趨向保守，公司ROE要重上軌道，經營心態是關鍵 在眾多獲利指標中，ROE絕對是最重要的一個。投資者在研究一家新公司時，請謹記先看公司長期的ROE走勢；走勢平穩是最好的，若出現轉折，可通過杜邦分析了解其中原因，說不定能發現不錯的投資機會! Written By QI-XIANG 2021/03/30","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"財報狗挖好股精華","slug":"財報狗挖好股精華","permalink":"https://qi-xiang.github.io/tags/%E8%B2%A1%E5%A0%B1%E7%8B%97%E6%8C%96%E5%A5%BD%E8%82%A1%E7%B2%BE%E8%8F%AF/"}]},{"title":"財報狗教你挖好股 [1.獲利性分析-營運周轉天數]","slug":"frdog1-2","date":"2021-03-18T17:48:11.000Z","updated":"2022-03-13T17:25:14.569Z","comments":true,"path":"2021/03/19/frdog1-2/","link":"","permalink":"https://qi-xiang.github.io/2021/03/19/frdog1-2/","excerpt":"","text":"營運周轉天數-產品賣得快，收錢也要快 經營公司最大的風險有2個，1個是&quot;貨賣不出去&quot;，另1個則是&quot;帳收不回來&quot;。貨賣不出去，會造成公司存貨的跌價損失；帳收不回來，公司的獲利會縮水，嚴重時甚至會進入虧損。 公司賺取利潤的過程，稱為&quot;商業循環&quot;，一般可分為4個步驟，依序為進貨、製造、銷貨、收款，同時又可分為前後兩部分(存貨循環、應收帳款循環) 存貨循環 存貨進到公司，經過製造後並銷售出去的過程，所花費的時間稱為&quot;存貨周轉天數&quot; 存貨周轉率 = 營業成本 / 平均存貨 * 100% -&gt; 1年內可以賣幾次平均存貨量 存貨周轉率反映公司經營效率 存貨周轉天數 = 365天 / 存貨周轉率 -&gt; 需要幾天賣完平均存貨量 存貨周轉的天數要低於多少才算好?要看產品的生命週期而定。 比較不同公司時，要注意是不是屬於同一產業 存貨週轉天數搭配營收走勢觀察，可看出產業供需狀況 總共有四種不同的狀況 1.公司處於擴張期(存貨週轉天數上升、營收上升) 注意: 月營收開始下滑，則為營運衰退的警訊 2.產品供不應求(存貨週轉天數下降、營收上升) 注意: 存貨周轉天數反轉向上，營收將有下滑風險 3.產品供過於求(存貨週轉天數上升、營收下降) 注意: 存貨周轉天數反轉向下，則營收有望重回成長 4.公司處於收縮期(存貨週轉天數下降、營收下降) 注意: 存貨週轉天數反轉上升，營收可能有所回升 應收帳款循環 產品銷售給顧客直到收款，所花費的時間稱為&quot;應收帳款周轉天數&quot; 應收帳款周轉率 = 年營收 / 平均應收帳款 * 100% -&gt; 1年內可以收回幾次應收帳款 應收帳款周轉天數 = 365天 / 應收帳款周轉率 -&gt; 平均幾天能收回帳款 應收帳款周轉天數反映公司帳務管理能力 應收帳款周轉天數的大小與&quot;公司相對客戶的規模大小&quot;有關，同產業進行比較，則可看出企業在產業中的地位 應收帳款周轉天數持續上升，盈餘品質恐惡化(淪於&quot;紙上富貴&quot;，公司認列的營收，並沒有真正進入公司)，但需長期觀察判斷 存貨周轉天數+應收帳款周轉天數 = 營運周轉天數 Written By QI-XIANG 2021/03/23","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"財報狗挖好股精華","slug":"財報狗挖好股精華","permalink":"https://qi-xiang.github.io/tags/%E8%B2%A1%E5%A0%B1%E7%8B%97%E6%8C%96%E5%A5%BD%E8%82%A1%E7%B2%BE%E8%8F%AF/"}]},{"title":"財報狗教你挖好股 [1.獲利性分析-利潤比率]","slug":"frdog1-1","date":"2021-03-17T17:35:54.000Z","updated":"2022-03-13T17:25:17.036Z","comments":true,"path":"2021/03/18/frdog1-1/","link":"","permalink":"https://qi-xiang.github.io/2021/03/18/frdog1-1/","excerpt":"","text":"利潤比率-高營收不代表賺得多 利潤才是做生意賺不賺錢的關鍵。衡量利潤時，我們會利用&quot;利潤比率&quot;，也就是&quot;毛利率&quot;、“營業利益率”、&quot;淨利率&quot;這3個數字 毛利率-&gt;可看出公司產品本身的競爭力 “毛利&quot;是營業收入(營收)減去營業成本後的金額；毛利佔公司營收的比重就是&quot;毛利率” 營業成本是與產品直接相關的支出，像是原料成本、設備折舊成本、工廠員工薪資成本等。 製造業有高毛利率，代表產品越有競爭優勢!! 降低成本提高毛利率，最好能具持續性 舉台灣電子產業為例，透過提高售價來拉高毛利率是不可行的，唯有採用降低成本的方式。 降低成本的方法很多，主要可從以下兩種角度觀察 1.改善產品製程可讓產品競爭力與股價雙升 2.原料價格波動造成毛利率提升，不代表產品競爭力提高 營業利益率-&gt;可看出公司本業的經營狀況 營收扣除營業成本後是毛利，毛利再扣除&quot;營業費用&quot;就是&quot;營業利益&quot; 營業費用是與產品間接相關的支出，主要可分為以下三類 管理費用 銷售費用 研發費用 評估腦力密集型產業，先從營利率下手。對於軟體公司、IC設計這些主要以營業費用為主的產業，從營利率走勢下手，比較能掌握公司營運狀況。 有些不肖公司會將部分成本轉移到營業費用上，造成高毛利率，故實際在評估公司本業獲利狀況時，最好仍以公司的營利率為準。 淨利率-&gt;呈現公司最終的獲利情形 公司除了本業經營外，還有一些業外損益與稅額。(ex.所得稅、投資) 一家公司最終淨賺的獲利，必須將營業利益減去&quot;業外損失&quot;(或加上&quot;業外獲利&quot;)與&quot;稅額&quot;，最後算出來的就是&quot;淨利&quot;，&quot;淨利率&quot;就是淨利佔營收的比重，數值越高表示公司獲利能力越強。 業外帶來的淨利飆升，需判斷是否是曇花一現 業外損益項目眾多，需判斷其屬於一次性或具有長期性 例如: 保險理賠、匯兌損益、處分資產損益、短期投資損益都是屬於一次性業外損益 觀察到一間公司營利率小於淨利率時，我們可以知道公司主要獲利來源為業外收入，此時應小心評估這個業外收益的本質是什麼? 一次性或長期性? 長期投資標的，淨利率不宜低於10% 淨利率反映出公司最終獲利狀況，最好不要低於10%，低於10%不但代表公司獲利能力差，也代表獲利變動風險很大，股價容易隨之崩跌。當觀察到媒體報導哪間公司營收再創新高時，宜留意淨利率是否也有亮眼表現。 Written By QI-XIANG 2021/03/19","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"財報狗挖好股精華","slug":"財報狗挖好股精華","permalink":"https://qi-xiang.github.io/tags/%E8%B2%A1%E5%A0%B1%E7%8B%97%E6%8C%96%E5%A5%BD%E8%82%A1%E7%B2%BE%E8%8F%AF/"}]},{"title":"BDC CH1: Introduction","slug":"CH1","date":"2021-03-08T06:58:09.000Z","updated":"2022-03-13T17:25:37.790Z","comments":true,"path":"2021/03/08/CH1/","link":"","permalink":"https://qi-xiang.github.io/2021/03/08/CH1/","excerpt":"","text":"CH1: Introduction Data Communication Exchange of data between two devices via some form of transmission medium Kinds of data communication Simplex(單工) Only one of the two stations on a link can transmit(只有一方接收，另一方傳送) Half-duplex(半雙工) Each station can both transmit and receive, but not at the same time(兩方都可以進行傳送，只是不可&quot;同時&quot;進行傳送或接收) Full-duplex(全雙工) Both stations can transmit and receive simultaneously(兩方可同時進行傳送、接收) Physical network Interconnection of a set of devices capable of communication(連接不同裝置，使其彼此間可以互相溝通) Type of connection Point-to-Point Provide a dedicated link between two devices(在兩裝置間，直接用一條線連接) ex. ISDN(直接電纜連線) Multi-Point More than two specific devices share a single link(提供一條線，多部裝置共用) ex. Ethernet(乙太網路) 傳送的手法、媒介可以不同，但Message的protocol、format必須保持一樣 Topology Mesh Topology(網狀拓樸) Every node has a dedicated point-to-point link to each other(每一節點都有自己專用的點對點連線) Require N*(N-1)/2 links to onnect N devices Strong Robustness(強堅固性、生存性高) If one line fails, only that line is affected, and all other links remain active(1條link不通，可走其他路徑) 路徑的各種組合，可以讓整體傳輸量上升 若link有閒置，可同時走不同link到相同的終點，進而提升傳輸量 可以直接溝通、低延遲 Required more cable and line costs(需要多條cable，造成花費過高) Star Topology(星狀拓樸) Every node has a dedicated point-to-point link to the networking device(有一中心化節點替其他節點傳送) Ease of adding/removing nodes and managing network(容易修正) Highly depend on switch hub(生存性不佳，ex. 中心節點fail) Bus Topology(匯流排拓樸) Every node share the same limk to stitch to the networking device Easy to install and re-configure Diffiuult to isolate a fault, a fault or break in the bus cable stops all the transmission(低生存性，沒有備援線路可以傳輸) Ring Topology(環狀拓樸) Nodes are connected as a ring(has two directions for reaching the target node) Singnal flows in one direction until reach destination Need N cable links to connect N devices Easy to install and re-configure Difficult to isolate a fault(但優於Bus Topology) 困難點: 確認傳送路徑(方向)，生存性優於Bus Topology，當1條link出錯，可走另一邊 Looping issue 假設有一不確定目的地的無義訊息進入，則會在ring結構中不斷移動，形成風暴(stormy) -&gt; 占用band-width Hybrid Topology(混合式拓樸) Physical Network Transmission Parallel Transmission(並行傳輸) ex. one 8 bits signal are sent together by 8 different lines 同時改變多條線電位 -&gt; 產生不同訊號，有可能造成訊息傳送不穩或漏 Serial Transmission(序列傳輸) ex. one 8 bits signal are sent one after another(follow order) by only one line 只有一條線，依序傳送各個bit的訊號給receiver 同樣以8條線以序列傳輸，可得到比較好的效率 Two types for Serial Transmission Asynchronous Serial Transmission ex. telephone communication Data is sent one character at a time start bit + data + parity bit + 1, 1.5 or 2 stop bits(不像同步傳輸有精確的控管) Synchronization is reestablised for each other(同步與非同步間的差異在於是否在訊號中加上’‘註解’) Synchronous Serial Transmission ex. Token Ring, SONET, Ethernet-common used in computer network Data is sent as a “block” of uninterrupted chars, using “frame” to encapsulate payload data(比非同步在外面多了一層信封) More cost-efficiency Frame裡面可以放細部資訊(可檢查是否漏包)，每一段序號可套用&quot;檢查碼&quot; Network Criteria Latency Elapse time between an inquiry(詢問) and a response Throughput number of bits per second - bps, Kbps,… Reliability Mean Time Between Failures(MTBF，平均故障時間) Mean Time To Recovery(MTTR，平均復原時間) Security(維護資料&quot;正確性&quot;) Cyclic Redundancy Check(CRC, 循環冗餘校驗) Error Correction/ Correcting Code(ECC，錯誤修正碼，不用重傳，可在傳輸過程修正，缺點是資料肥大) Network Type(僅列出常用) Local Area Network (LAN,區域網路) Wireless Local Area Network (WLAN, 無線區域網路) Storage Area Network (SAN, 儲存區域網路) Wide Area Network (WAN, 廣域網路) LAN與WAN的分界視參照物而定 OSI Model OSI has seven layers 7.Application Layer Human-computer interaction layer, where application can access the network services 處理應用程式，進而提供使用者網路應用服務 ex. DHCP、FTP、HTTP、POP3 6.Presentation Layer Ensures that data is in a usable format and is where data encryption occures 透過應用層收到資料後，透過展示層可轉換表達方式 ex. JPEG,MIDI 5.Session Layer Maintain connection and is responsible for controlling ports and sessions 這個層級負責建立網路連線，等到資料傳輸結束時，再將連線中斷 ex. NetBIOS names 4.Transport Layer Transmits data using transmission protocal 傳輸層主要負責電腦整體的資料傳輸及控制 ex. TCP, UDP 3.Network Layer Decides which physcial path the data will take 網路層定義網路路由及定址功能，讓資料能夠在網路間傳遞 ex. IP, 路由器(Router)及Layer 3交換器(Switch) 2.Data Link Layer Defines the format of data on the network 主要是在網路之間建立邏輯連結，並且在傳輸過程中處理流量控制及錯誤偵測，讓資料傳送與接收更穩定。資料連結層將實體層的數位訊號封裝成一組符合邏輯傳輸資料，這組訊號稱為資料訊框（Data Frame）。訊框內包含媒體存取控制（Media Access Control，MAC）位址-&gt;讓對方主機辨認資料來源。 ex. 網路卡、網路交換器（Switch） 1.Physical Layer Transmits the raw bit stream over the medium 定義網路裝置之間的位元資料傳輸，也就是在電線或其他物理線材上，傳遞0與1電子訊號，形成網路 ex. 網路線、網路卡與集線器（Hub） Basic Notions of Networking Component Repeater(訊號放大/延伸器) Hub(集線器) 以廣播方式傳遞封包，A電腦透過Hub傳封包給B時，其他連在Hub上電腦也會收到封包，但只有B會把封包接起來，其餘則會丟掉 半雙工(Half-duplex) Bridage(橋接器) 可不接電，單純結合網路線使其變長 Converter(轉換器) Gateway(通訊閘) Network Interface Card (NIC, 網路卡)/Network Adapter(網路配接器) Switch Hub/Switch(交換器) Switch並不一直廣播，Switch會記錄封包中的MAC位址所以當電腦A傳送資料給電腦B時，其他電腦並不會也收到資料，而且這個時候別的電腦也可以同時互相傳送資料。 全雙工 Router(路由器) 子網路送封包到另一子網路(ex.中央-&gt;台大) Transceiver(收發器/光電轉換器) 光訊號-&gt;電訊號 Fiber-optic Cable(光纖線/光纖跳線) Unshielded/Shielded Twisted Pair Cable (UTP/STP Cable, 無遮蔽/有遮蔽雙絞線) 有遮蔽-&gt;接頭有特殊設計 Common Networking Component Hub - broadcasting everything to other ports Switch Hub (Switch) - be capable of learning -&gt;有記憶功能(透過MAC位置) By function Unmanaged Switch(無網管交換器) Managed Switch(網管型交換器) -&gt; 有管理介面控制 By expandability Fixed Switch(固定式交換器) Stackable Switch(堆疊式交換器) -&gt; 可串多台 Chassis Switch(機箱式交換器)/Modular Switch(模組式交換器) Others Power over Ethernet(PoE,乙太供電交換器) -&gt; 一條網路線同時供電和傳送封包 Power Line Communication (PLC, 電力線通信橋接器,又稱電力線網路) -&gt; 讓電源線可以傳送封包(具網路線功能)，缺點:無法通過保險絲，故僅能用在內部 Bypass Switch (旁路交換器) -&gt; 可以偵測網路系統狀態 Router(路由器) By type Wired Router (路由器) Wireless Router (無線路由器) By location Core/Spine Router(核心路由器) Edge/Leaf Router(邊緣路由器) Software/Virtual Router(軟體/虛擬路由器) By performance Small Office Home Office Router(SOHO Router, 小型辦公室家用型路由器,俗稱IP分享器) Telecommunication-level Router(電信等級路由器) Networking Cable With auto MDI/MDIX function in Gigabit Ethernet, it is not necessary to use Crossover Cable (跳線/跳接線) for device to device connection 現在的交換器技術讓使用者或網路管理員不必太在意直連線和交叉線，因為交換器擁有端口自動翻轉(線序自適應)特性，即 Auto MDI/MDIX 特性。 Ageing issue of UTP/STP Slow speed Degraded (full-duplex -&gt; half-duplex) Link Status Flapping (error -&gt; disable) Cyclic Redundancy Check Error (循環冗餘校驗錯誤) Packet Loss (掉包) Re-transmission No signal Fiber-optic Cable(光纖線/光纖跳線) Type Signal Mode (SM, 單模光纖) -&gt; 長距離、單一波長、成本高 Multi Mode (MM, 多模光纖) -&gt; 短距離、多種波長、成本低 Connector (僅列出常見) Subscriber Connector / Square Connector / Standard Connector (SC) Lucent Connector / Little Connector / Local Connector (LC) Ageing issue of Fiber-optic Cable Connector Problem Increasing CRC value Packet Loss In-completed transmission (ex. ok for small packet, failed on large one) Broken (ex.斷芯) Outdoor fiber Indoor fiber Skin damaged Transceiver(收發器,光電轉換器) GigaBit Interface Converter (GBIC) Small Form-factor Pluggable transceiver (SFP) Enhanced Small Form-factor Pluggable transceiver (SFP+) XENAPK XFP X2…","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"BDC","slug":"BDC","permalink":"https://qi-xiang.github.io/tags/BDC/"}]},{"title":"男子性與陽剛氣質、男子氣概的養成","slug":"性別社會學-男子陽剛特質","date":"2021-01-06T03:49:00.000Z","updated":"2022-03-13T17:26:43.085Z","comments":true,"path":"2021/01/06/性別社會學-男子陽剛特質/","link":"","permalink":"https://qi-xiang.github.io/2021/01/06/%E6%80%A7%E5%88%A5%E7%A4%BE%E6%9C%83%E5%AD%B8-%E7%94%B7%E5%AD%90%E9%99%BD%E5%89%9B%E7%89%B9%E8%B3%AA/","excerpt":"","text":"一、發展趨勢 過去性別常被利用二分法或生物決定論，歸類成男或女。時至今日，當代性別學者，指出性別是經由’‘社會互動’'而逐漸形塑出的產物。故而對於性別的認同並非一成不變，而是在一連串的自我辯證中，不斷的改變自身對於性別的認同。 男性陽剛特質的實踐，實際上是一種建構性別認同的方式，此一性別認同亦是男性的普遍性別認同。前述性別是由’‘社會互動’'產生，故所謂的陽剛、陰柔特質並非由男或女所獨有，而是經由人與人互動，在社會中實踐所形成。社會上存有性別秩序的概念，因此陽剛特質被視為是男性在性別秩序下所要遵循的一種社會實踐模式。但社會中將男性預先擺放的位置，卻未必是男性實際是、想要的樣子。 近代Connell整理眾多陽剛特質的民族誌資料，歸結出了六大重點: 1.多元陽剛特質:不同的年代、文化，會建構出不同的陽剛特質，不存在特定標準。2.階序與霸權:不同的陽剛特質有彼此間序列關係，有些較受讚揚，有些則遭人貶抑。3.集團性:個別的陽剛特質會受到特定團體的認同或支持。4.主動建構:陽剛特質並非早於社會行為或性格存在，而是在日常行為中完成與實踐。5.內部複雜性:陽剛特質並非只有單一形式，有時多樣且充滿矛盾的陽剛特質會存於同一人身上。6.動態性:陽剛特質並非靜止不變，會隨著年代不同、日常生活中的實踐，有所改變。 學校是除家庭外，形塑一個人性別特質最重要的場所，Swain回顧學校教育於陽剛特質研究，歸納兩大類:一從正式學校文化，二從非正式學校文化，瞭解學校的教育對男性陽剛特質的建構上的影響。就整體而言Swain提出學校形塑學生陽剛特質的五大面向:1.學校的管理:如嚴格的制服規定、訓練。2.課程:透過考試、評量進行能力分組，是製造同儕間陽剛特質位階的有效方式。3.師生關係:教師依照性別刻板印象來對待男女。4.運動與遊戲:許多學者認為，運動是使’‘男孩變成男人’'的象徵，反映社會對於男性的期望，如: 力量、競爭等…。5.學生間的關係:許多研究指出，男孩與同儕團體的互動，是影響其陽剛特質建構的主要關鍵。 二、社會現象觀察 近期，台灣發生多起情殺案件，根據衛生福利部截至2017年的統計，家庭暴力防治法實施20年後，家庭暴力通報案件卻是呈逐年上升的態勢，1998年約9,000多件、2005年6萬6,080件、2017年13萬7,148件。保護令的核發數亦有逐年上升的趨勢，不過這也顯示家暴觀念已經深植人心，民眾在面對家暴問題，會主動尋求公權力的協助。勵馨基金會的執行長紀惠容指出，應該讓男性從陽剛特質解放，男性也可以溫柔、可以傾聽，並試著接納自己的不完美，方能有效減少暴力事件。紀惠容亦認為台灣在情感教育這一方面的努力仍然不足。 現代社會女性在選擇伴侶時，往往看重對方是否很man或很有power，抑或對自己提供無微不至的照顧，但這種權威特質可能會帶出恐怖情人或伴侶。因伴侶選擇偏好，社會普遍要求男性具備陽剛特質，但在感情不順遂時，男性可能無法接納自己、接受結果，最終導致毀滅性的暴力。衛福部政務次長呂寶靜表示，防治性別暴力不單是國家、婦女團體或社工的事，也和法官的性別意識有所關連，更是整體社會都應關心的公共事務。 2018年鬧得沸沸揚揚的乙武洋匡事件，帶出陽剛階序競逐、仇女現象。乙武洋匡的婚姻過去被視為’‘即便是身障者也能找到真愛’‘的勵志典範，婚外情則直接衝擊了該項典範。成為乙武洋匡對象的女人們，被敘述成’‘不知道在圖什麼的女人’‘，字裡行間充滿濃濃的仇女氣息。妻子乙武仁美在事件後出面道歉，如同在類似事件中，不斷彎腰鞠躬的那些妻子一般，在父權體制下，女性往往成為’‘擁有’‘她的男人進行形象公關的工具，出現’‘婚姻 = 單偶制’'的社會型態，逼迫女性違背社會期待主動低頭道歉。 男性普遍嘲諷此事件，朱學恆提出評論’‘沒有腿也能劈腿，沒有手也能把妹，讓人重新思考男人到底需要什麼才能讓女人愛上，這我真的不懂’'。這段話完美揭露社會上男性群起嘲諷的原因:“典型的陽剛階序競逐”。父權社會中，男性必須透過展現自身陽剛特質，向著更高的階層攀爬，進而獲取更多的權力，並試著規避向下摔落的懲罰。藉由找出比自己更低的對象，襯托出自己陽剛的特質，乙武洋匡會被廣大男性嘲諷的其中一個因素，是先天上身體的不完美，因而被醜化為次等，但卻是最佳的比較對象。直至現在仍有許多男性陷於父權迷障中，女性被物化為陽剛競逐的獎品，若女性也認同這項規則，則問題恐怕會如雪球般愈滾愈大。 三、面臨的爭論 台灣傳統農村時代，強調一家之主與重男輕女的價值觀，要求男人要有強烈的尊嚴感。進入工業時代後，個人自主意識提高，父權具有彈性，不婚或晚婚增加，家庭中的權力結構出現改變。但在長官權力階層下，忍耐成為常見的男子性特質。在現代社會風氣下要讓陽剛特質不再是構成成熟男性的必要條件，仍需付出相當大的努力。傳統上，'‘男主內、女主外’'是相當普遍的觀念，根據調查至今仍有近半數的人同意此觀點。在家務勞動的時間上，1990年女性4小時，男性則為1小時47分，2004年女性3小時，男性為1小時30分。隨著時間的腳步，兩性花在家務勞動上的時間均有減少，但時數上仍有不小的差距。 根據行政院主計總處2020年11月的兩性勞動參與率統計資料，男性為67.21%，女性則為51.48%，兩者相差15.73%，顯示有大量的女性，因為有些特殊原因沒有進入到勞力市場。女性未進入勞動市場的最大原因有二個 : 一、做家事(51%)，二、照顧負擔(34.71%)，以上為行政院主計總處2020年5月的資料。這些數據都顯現出，在台灣傳統社會價值觀下，所產生的家庭家務分工不均的事實，男子為避免損及男子氣概，所以甚少主動從事家務勞動。近年來台灣的’‘新好男人’'逐漸增加，但距離和女性平等承擔家庭義務的日子依然遙遠。制度不完善是其中的一大原因，台灣的產假僅有8周，比起鄰近日本的14周、新加坡的16周，台灣制度相對較不友善。 有害的男子氣概(toxic masculinity)，這個詞彙近年在美國成為流行語，只要對某個男性的行為感到不滿，就將其貼上這一標籤，但這個詞彙在學術上並沒有明確的定義。簡單言之，它指出男子氣概中的部分成分，不只對女性，同時對男性也有害，例如各種暴力行為、抽菸、酗酒等危害健康的行為。有人認為這些有害的男子氣概特質，只存於某些邊緣的男性，將之個人化，近一步使得位於優勢階級的男性可以置身事外，而不做出改變。男子氣概在整個社會中，彼此間存有階層的上、下關係，有的站在制高點 ; 有的位在邊緣，更有的受到壓抑。男子氣概是在特定的歷史、文化、性別結構下進行的社會實踐，既然如此就存有改變的可能。 最後再回過頭來看台灣，因為陽剛特質被視為是男性的必備構成要素，普遍看來男性都會被認為要養家，加以&quot;嫁出去的女兒，如潑出去的水&quot;在其中加以催化，在家庭繼承權上，往往女兒們都會被要求拋棄繼承，根據2018年財政部的資料，女性的拋棄繼承者有56.2%，在遺產繼承申報方面，女性僅占比39.6%，凸顯台灣兩性平權路漫漫。 四、總結 在目前的社會架構下，看似男性是其中最大的受益者，但其實也蒙受了不少害處，男人有著要負責養家活口的社會期許，同時也不能自由率性的表達情緒，如&quot;男兒有淚不輕彈&quot;的傳統價值觀。從現有的社會制度來看，它是在幫助男性減輕養家活口的壓力，例如男女在職場上的同工不同酬、女兒有較高的機率放棄財產繼承，且社會認為女性較為情緒化，故舉凡重要決策，都是交給男性做決定居多。台灣在2016選出第一位女性總統，算是讓長期男尊女卑的社會現狀稍有改善，但內閣的性別比仍舊呈現男性占絕對多數的狀況，這點就遠遠不如世界上的其他國家。 行政院性別平等處在2021年1月5日發布’‘2021年性別圖像’'，其依照聯合國開發計畫署的2019年性別不平等指數，將台灣資料代入計算，整體性別表現為全球第6名，更是亞洲之冠。該項指標比較的是包含生殖健康、賦權及勞動市場等3領域的5項指標，儘管表面數據很漂亮，但納入考量的指標，台灣相比其他國家都來得有利，若是把中央政府的內閣或地方政府官員性別比或也納入考量的話，恐怕台灣在世界排名上會居於末座。 2019年5月17日台灣寫下歷史新篇章，成為亞洲第一個同婚合法國家，顯示社會漸漸可以接受「多元性別」的概念。美國臉書給使用者的性別選項有50多種，但有學者主張與其不斷增加更多元、豐富的選項，不如根本反省性別上類別本身的存在。希望未來社會能包容多樣男子氣概的存在，更期許有一天，我們能說這個人很勇猛、很內斂、很搞笑，或很愛哭，而不會再說出「像男人」或「像女人」這樣帶有性別印象、意涵的字眼。 五、參考資料 經典閱讀-男子性與陽剛氣質2-國外論述與台灣經驗 男男自語-男子性與陽剛氣質 風傳媒-台灣多起情殺案 紀惠容：應該讓男性從陽剛特質中解放 勵馨基金會-【新聞稿】台灣家暴/性侵防治20年歷程–終止暴力新挑戰 關鍵評論網-陽剛階序競逐，正是男性對乙武洋匡婚外情群起嘲諷的原因 畢恆達-男子氣概：一種社會學的概念 《現代保險》雜誌-嫁出去的女兒潑出去的水 女性拋棄繼承逾56% 中央社- 2021性別圖像 台灣性平表現居全球第6亞洲之冠 中華民國統計資訊網-主計總處人力資源調查","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"性別社會學","slug":"性別社會學","permalink":"https://qi-xiang.github.io/tags/%E6%80%A7%E5%88%A5%E7%A4%BE%E6%9C%83%E5%AD%B8/"}]},{"title":"歷史思辨問題","slug":"歷史思辨問題","date":"2021-01-04T04:43:35.000Z","updated":"2022-03-13T17:25:50.004Z","comments":true,"path":"2021/01/04/歷史思辨問題/","link":"","permalink":"https://qi-xiang.github.io/2021/01/04/%E6%AD%B7%E5%8F%B2%E6%80%9D%E8%BE%A8%E5%95%8F%E9%A1%8C/","excerpt":"","text":"簡述漢武帝罷黜百家獨尊儒術(外儒內法) 小結: 論及漢武帝罷黜百家獨尊儒術的這一段歷史，就不得不提及董仲舒。武帝曾征問三則問題，董仲舒以三篇策論作答，也就是著名的’‘天人三策’‘，董仲舒以儒家學說做為基礎、陰陽五行為框架，兼採諸子百家的思想精華，建立起一個新儒學思想系統。天人三策中提及’‘天人感應，君權神授’'，成功樹立統治者的絕對權威，不直接否定君主的政策，改以天象示警，與儒家提倡的民貴君輕有所背離，彰顯出法家思想被有意地在外頭包上儒家的外衣。司馬遷史記中的酷吏列傳記錄了漢代二十一名酷吏，其中僅武帝一朝便有十八名，反映出武帝雖以儒家思想為本，但與當時酷吏之盛、執法深苛的情形，前後充滿矛盾， 亦反映出武帝仍效仿先秦採法家之術治國。 滿漢八旗兵入關最成功政策 1.祭孔尊儒 2.延續科舉制度 小結: 自秦漢以來，儒家成為社會的價值觀主流，明代朱元璋最初參與明教起事，後聽取劉伯溫之建議，和明教劃清界線，因為宗教形式的起義，是為儒家所謂的異端邪說，而後朱元璋採取祭孔和拜訪各地大儒的方式，獲取儒家認 同，將其塑造為一位賦有天命的真龍天子，滿清的多爾袞，正是複製了明太祖成功的經驗，滿人進而得以 15 萬八旗兵便成功入主中原。除此之外，'‘入中國則中國之’'的政策也是很重要的一環，不在乎血統，而在乎文化。 馬克思主義入主中國的原因 知識份子救亡圖存的危機意識 知識份子經世致用的儒家傳統 五四運動的影響(新文化運動，1915 陳獨秀辦新青年-&gt;批判儒家) 馬克思主義建立在批判西方資本主義之上(反對階級社會) 加拉罕宣言的影響(廢除中俄間不平等條約、歸還領土、魏金斯基來中宣揚共產主義、從西方式革命走向東方式革命-&gt;從城市革命走向農村革命) 比較毛澤東和洪秀全(四個相同處) 1.兩人皆是出身農村的平民 2.兩人都是失意落魄的知識份子 3.兩人均動員農民從事一場社會革命 4.兩人堅持的意識形態、信仰，與中國傳統文化沒有淵源 小結: 毛澤東和洪秀全的起事，一個成功，另一個則失敗，歸咎其原因在於起事方法不同。毛澤東利用了馬克思主義，成功獲取一部份傳統儒家知識份子的認同，進而減少來自社會中的反抗力度，最終得以推翻中國國民黨在中國的統治。洪秀全則利用宗教起事，一開始就和傳統儒家知識份子站在對立面，後來曾國藩就以傳統儒家價值為號召，動員地方鄉勇組成湘軍，成功撲滅了洪秀全的勢力。","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"歷史","slug":"歷史","permalink":"https://qi-xiang.github.io/tags/%E6%AD%B7%E5%8F%B2/"}]},{"title":"日本動畫公司簡介-京都動畫公司","slug":"Kyoani","date":"2019-12-27T07:12:33.000Z","updated":"2022-03-13T17:24:24.897Z","comments":true,"path":"2019/12/27/Kyoani/","link":"","permalink":"https://qi-xiang.github.io/2019/12/27/Kyoani/","excerpt":"","text":"資料來源 : • Wikipedia • udn聯合新聞網 • PTT新聞: • 4GAMERS •朝日新聞中文網","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Animation","slug":"Animation","permalink":"https://qi-xiang.github.io/tags/Animation/"}]}],"categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"},{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://qi-xiang.github.io/tags/Hexo/"},{"name":"填坑系列","slug":"填坑系列","permalink":"https://qi-xiang.github.io/tags/%E5%A1%AB%E5%9D%91%E7%B3%BB%E5%88%97/"},{"name":"LineBot超入門","slug":"LineBot超入門","permalink":"https://qi-xiang.github.io/tags/LineBot%E8%B6%85%E5%85%A5%E9%96%80/"},{"name":"生活經驗分享","slug":"生活經驗分享","permalink":"https://qi-xiang.github.io/tags/%E7%94%9F%E6%B4%BB%E7%B6%93%E9%A9%97%E5%88%86%E4%BA%AB/"},{"name":"網頁基礎","slug":"網頁基礎","permalink":"https://qi-xiang.github.io/tags/%E7%B6%B2%E9%A0%81%E5%9F%BA%E7%A4%8E/"},{"name":"原子習慣","slug":"原子習慣","permalink":"https://qi-xiang.github.io/tags/%E5%8E%9F%E5%AD%90%E7%BF%92%E6%85%A3/"},{"name":"NLP自然語言處理","slug":"NLP自然語言處理","permalink":"https://qi-xiang.github.io/tags/NLP%E8%87%AA%E7%84%B6%E8%AA%9E%E8%A8%80%E8%99%95%E7%90%86/"},{"name":"區塊鏈","slug":"區塊鏈","permalink":"https://qi-xiang.github.io/tags/%E5%8D%80%E5%A1%8A%E9%8F%88/"},{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"},{"name":"金魚也能學會寫網頁","slug":"金魚也能學會寫網頁","permalink":"https://qi-xiang.github.io/tags/%E9%87%91%E9%AD%9A%E4%B9%9F%E8%83%BD%E5%AD%B8%E6%9C%83%E5%AF%AB%E7%B6%B2%E9%A0%81/"},{"name":"Python 學習日記","slug":"Python-學習日記","permalink":"https://qi-xiang.github.io/tags/Python-%E5%AD%B8%E7%BF%92%E6%97%A5%E8%A8%98/"},{"name":"財報狗挖好股精華","slug":"財報狗挖好股精華","permalink":"https://qi-xiang.github.io/tags/%E8%B2%A1%E5%A0%B1%E7%8B%97%E6%8C%96%E5%A5%BD%E8%82%A1%E7%B2%BE%E8%8F%AF/"},{"name":"BDC","slug":"BDC","permalink":"https://qi-xiang.github.io/tags/BDC/"},{"name":"性別社會學","slug":"性別社會學","permalink":"https://qi-xiang.github.io/tags/%E6%80%A7%E5%88%A5%E7%A4%BE%E6%9C%83%E5%AD%B8/"},{"name":"歷史","slug":"歷史","permalink":"https://qi-xiang.github.io/tags/%E6%AD%B7%E5%8F%B2/"},{"name":"Animation","slug":"Animation","permalink":"https://qi-xiang.github.io/tags/Animation/"}]}