{"meta":{"title":"Xiang's Blog","subtitle":"記錄生活中發生的大小事","description":"在這裡我將與你共享我的知識庫!","author":"Qi Xiang,Zhang","url":"https://qi-xiang.github.io","root":"/"},"pages":[{"title":"","date":"2021-05-06T09:48:14.284Z","updated":"2021-05-06T09:48:14.284Z","comments":true,"path":"about/CSS_homepage/rwd.css","permalink":"https://qi-xiang.github.io/about/CSS_homepage/rwd.css","excerpt":"","text":"/*完美支援320、375、425、768、1440、1536、1920px*/ /**********************************Design for Phone*************************************/ @media screen and (min-width: 320px){ #inner-experience{ margin:0px 0px !important; } #mail_jumbo{ padding-top: 0px; } #mail pre{ margin-left: 0px !important; } #inner-education{ margin: 0px 0px !important; } } @media screen and (min-width: 375px){ #inner-experience{ margin:0px 0px !important; } #mail_jumbo{ padding-top: 0px; } #mail pre{ margin-left: 0px !important; } #inner-education{ margin: 0px 0px !important; } } @media screen and (min-width: 425px) { /*Done*/ #inner-experience{ margin:0px 0px !important; } #mail_jumbo{ padding-top: 0px; } #mail pre{ margin-left: 0px !important; } #inner-education{ margin: 0px 0px !important; } } /***************************************************************************************/ @media screen and (min-width: 768px) { /*Done*/ #inner-education{ margin:0px 24px !important; margin-left: 8%; } #inner-experience{ margin:0px 24px !important; } #mail pre{ margin: 0px !important; } #mail_jumbo{ padding-top: 0px !important; } #icon{ padding-bottom: 0px; } } @media screen and (min-width: 1440px) { /*Done*/ #inner-education{ padding:0px 141px !important; } #contact{ padding-left: 150px; } #inner-experience{ padding:0px 141px !important; } #mail{ padding-left: 165px; padding-top: 64px; } #icon{ padding: 0px 150px; } } @media screen and (min-width: 1536px) { /*Done*/ #inner-education{ padding:0px 0px 0px 189px !important; } #inner-experience{ padding: 0px 189px !important; margin-right:0px !important; } #contact{ padding-left: 198px; } #icon{ padding-left: 198px; } #mail{ padding-top: 64px; padding-left: 213px; } } @media screen and (min-width: 1920px) { /*Done*/ #inner-education{ padding:0px 0px 0px 381px !important; } #inner-experience{ padding-left: 381px !important; margin-right:0px !important; } #contact{ padding-left: 390px; } #icon{ padding-left: 390px; } #mail{ padding-top: 64px; padding-left: 405px; } }"},{"title":"","date":"2020-12-22T13:28:52.860Z","updated":"2020-12-22T13:28:52.860Z","comments":true,"path":"about/README.html","permalink":"https://qi-xiang.github.io/about/README.html","excerpt":"","text":"qi-xiang.github.io"},{"title":"","date":"2021-05-13T04:00:18.992Z","updated":"2021-05-13T04:00:18.992Z","comments":true,"path":"about/CSS_homepage/rwd2.css","permalink":"https://qi-xiang.github.io/about/CSS_homepage/rwd2.css","excerpt":"","text":"div .row{ background-color: #E9ECEF; } #foot{ background-color: #5569DC; } .marquee { width: 300px; /* the plugin works for responsive layouts so width is not necessary */ overflow: hidden; border:1px solid #ccc; }"},{"title":"","date":"2021-04-22T15:24:39.596Z","updated":"2021-04-22T15:24:39.596Z","comments":true,"path":"about/CSS_homepage/style.css","permalink":"https://qi-xiang.github.io/about/CSS_homepage/style.css","excerpt":"","text":"#myBtn { display: none; position: fixed; bottom: 10px; right: 10px; z-index: 99; font-size: 18px; border: none; outline: none; background-color: red; color: white; cursor: pointer; padding: 15px; border-radius: 4px; opacity: 0.5; } #myBtn:hover { background-color: #555; } a{ text-decoration: none; } /* Style all font awesome icons */ .fa { padding: 0px 25px 0px 0px; font-size: 20px; width: 20px; text-align: center; text-decoration: none; margin: 5px 2px; } /* Add a hover effect if you want */ .fa:hover { opacity: 0.7; } /* Set a specific color for each brand */ /* Facebook */ .fa-facebook { color: black; } /* LinkedIn */ .fa-linkedin { color: black; } /*Instagram*/ .fa-instagram { color: black; } /*Style for a:hover*/ .about a:hover{ color: aqua !important; } .education a:hover{ color: aqua !important; } .skills a:hover{ color: aqua !important; }.awards a:hover{ color: aqua !important; }"},{"title":"","date":"2021-05-13T04:02:27.460Z","updated":"2021-05-13T04:02:27.460Z","comments":true,"path":"about/JS_homepage/FadeIn_Animation.js","permalink":"https://qi-xiang.github.io/about/JS_homepage/FadeIn_Animation.js","excerpt":"","text":"$(document).ready(function(){ $(\"#fadeArea1 p\").hide() $(\"#fadeArea2 pre\").hide() $(\"#fadeArea2 p\").hide() $(\"#fadeArea3 pre\").hide() $(\"#fadeArea3 p\").hide() $(\"#fadeArea4 pre\").hide() $(\"#fadeArea4 p\").hide() $(\"#fadeArea5 pre\").hide() $(\"#fadeArea5 p\").hide() for(var i = 1;i=$('#about').offset().top){ $(\"#fadeArea1 p\").fadeIn(1000); } if($(window).scrollTop()+330>=$('#education').offset().top){ $(\"#fadeArea2 p\").fadeIn(1000); $(\"#fadeArea2 pre\").fadeIn(1000); } if($(window).scrollTop()+420>=$('#experience').offset().top){ $(\"#fadeArea3 p\").fadeIn(1000); $(\"#fadeArea3 pre\").fadeIn(1000); } if($(window).scrollTop()+440>=$('#skills').offset().top){ for(var i = 1;i=$('#awards').offset().top){ $(\"#fadeArea4 p\").fadeIn(1200); $(\"#fadeArea4 pre\").fadeIn(1200); } if($(window).scrollTop()+600>=$('#interests').offset().top){ $(\"#fadeArea5 p\").fadeIn(1300); $(\"#fadeArea5 pre\").fadeIn(1300); } }) $('.marquee').marquee({ //duration in milliseconds of the marquee duration: 8000, //gap in pixels between the tickers gap: 50, //time in milliseconds before the marquee will start animating delayBeforeStart: 0, //'left' or 'right' direction: 'left', //true or false - should the marquee be duplicated to show an effect of continues flow duplicated: true }); })"},{"title":"","date":"2021-04-22T14:37:21.604Z","updated":"2021-04-22T14:37:21.603Z","comments":true,"path":"about/animation/animation.css","permalink":"https://qi-xiang.github.io/about/animation/animation.css","excerpt":"","text":"@charset \"utf-8\"; h1{ text-align: center; color: darkorchid; padding-bottom: 15px; margin-top: 25px; margin-bottom: 25px; } body{ background-image: url(img/2.png); background-repeat: repeat-x; background-color: wheat; } a{ text-decoration: none; } a:hover{ color: red; } a:active{ color: blue; } .more{ text-align: right; padding: 20px 24px 20px 20px; background-image: url(img/icon.png); background-repeat: no-repeat; background-position: right center; clear: left; } h2{ border: black 1px solid; border-left: gray 15px solid; width: 180px; } table{ width: 50%; border: violet 1px solid; } th,td{ padding: 5px 10px; border: violet 1px solid; border-collapse: collapse; } #wrap{ width: 798px; margin: 40px auto; padding: 40px 80px; border: white 1px solid; background-color: white; } #a,#b,#c{ background-color: wheat; background-image: url(img/30.jpg); background-repeat: repeat-x; margin: 20px 0; padding: 35px 30px 30px 30px; } .ph{ float: left; margin-right: 30px; } .data{ width: 300px; float: left; } dt{ clear: left; float: left; font-weight: bold; } @keyframes marquee{ 0%{ left: 0%; } 100%{ left:-100%; } } div.marquee{ overflow: hidden; width: 420px; position: relative;margin: auto; height: 25px; } .marquee div{ display: block; overflow: hidden; width:200%; height: 25px; position: absolute; animation: marquee 10s linear infinite; } .marquee div span{ width: 50%; float: left; font-weight: bold; }"},{"title":"","date":"2021-04-22T14:37:30.908Z","updated":"2021-04-22T14:37:30.907Z","comments":true,"path":"about/animation/feedback.html","permalink":"https://qi-xiang.github.io/about/animation/feedback.html","excerpt":"","text":"feedback for animation 回饋表單 性別: 男生 女生 年齡: 請選擇 喜歡的角色: 最喜歡的女主角: 雪之下雪乃 由比濱結衣 川崎沙希 一色伊呂波 網站改善意見: 最後確認:"},{"title":"","date":"2021-04-22T14:40:14.530Z","updated":"2021-04-22T14:40:14.530Z","comments":true,"path":"about/animation/animation.html","permalink":"https://qi-xiang.github.io/about/animation/animation.html","excerpt":"","text":"animation 果然我的青春戀愛喜劇搞錯了! 果然我的青春戀愛喜劇搞錯了!完~2020年7月放送開始! 果然我的青春戀愛喜劇搞錯了!完~2020年7月放送開始! 來介紹一下我喜歡的作品! 作品概要 劇情大綱 登場人物 網站作者資訊 回饋表單 作品概要 《果然我的青春戀愛喜劇搞錯了。》（日語：やはり俺の青春ラブコメはまちがっている。 是日本輕小說作家渡航所創作的輕小說，插畫由ぽんかん⑧負責，簡體簡稱《春物》(我的青春戀愛物語果然有問題)，繁體簡稱《果青》(果然我的青春戀愛喜劇搞錯了)（日語：俺ガイル）。由GAGAGA文庫（小學館）於2011年3月至2019年11月間發行全14卷（本篇），日本地區累計發行量已突破900萬本。於2013年4月至6月播放第1季動畫，2015年4月至6月播放第2季動畫。原定於2020年4月9日首播第3期完結動畫，後因嚴重特殊傳染性肺炎疫情影響延期至同年7月。 劇情大綱 高中生比企谷八幡生性彆扭，不屈服於孤獨，沒有半個朋友，更不用提女朋友。對那些享受著青春的同班同學，他詛咒：「他們都是現充，通通給我爆炸吧！」——這樣一個傢伙，被導師帶去全校第一美少女雪之下雪乃加入的「侍奉社」。平凡無奇的八幡與美少女的奇妙邂逅，然而，雪乃和八幡個性上的缺陷讓他們無法擦出愛情的火花。這是一則充滿錯誤的青春故事。 登場人物(主要) 比企谷 八幡 年齡:17歲。 生日:8月8日，獅子座。 血型:A型。 喜歡的食物:蜂蜜炒花生及Max咖啡。 興趣:閱讀、玩遊戲、看動畫。 座右銘:「強求不來就放棄。」。 更多介紹 雪之下雪乃 年齡:17歲。 生日:1月3日，摩羯座。 血型:B型。 喜歡的食物:龍蝦和紅茶。 更多介紹 由比濱結衣 年齡:17歲。 生日:6月18日，雙子座。 血型:O型。 喜歡的食物:甜食。 更多介紹 網頁作者介紹 暱稱:翔翔 職業:中央大學資訊管理學系學生 E-mail:a0905716188@gmail.com WEB:建置中 敬請期待!! 回饋表單 回饋表單連結... Copyright &copy; GAGAGA文庫 All Rights Reserved. alert(\"該網站還處於測試階段!!\");"},{"title":"","date":"2021-10-21T16:12:18.300Z","updated":"2021-10-21T16:12:18.300Z","comments":true,"path":"about/index.html","permalink":"https://qi-xiang.github.io/about/index.html","excerpt":"","text":"My Homepage document.addEventListener('click', musicPlay); function musicPlay() { document.getElementById('music').play(); document.removeEventListener('click', musicPlay); } Top Welcome to my website! About Education & Experience Skills & Languages Awards & Interests QI-XIANG, ZHANG MIS in International Information & System Taoyuan, Taiwan qixiang1009@gmail.com https://github.com/QI-XIANG About MY BACKGROUND With a passion for computer science, web design, and all things programming, I have both the skill set and professional background necessary to dive deep into the programming world. As an upbeat, self-motivated team player with excellent communication, I envision an exciting future in the industry. Browse my site to see all that I have to offer. Education WHAT I’VE LEARNED 2019 - Present National Central University, TaiwanManagement in Information System 2016 - 2019 Taichung First Senior High School Experience WHERE I’VE WORKED Mar. 2021 - Present NCU Coding Club, Member Jan. 2020 - Present NCU Traditional Chinese Music Club, Erhu Group Leader Oct. 2019 - Dec. 2019 NCU MIS Carnival, Curation Group Member Sep. 2019 - Jan. 2020 NCU Traditional Chinese Music Club, Member Skills & Languages WHAT I BRING TO THE TABLE Java 20% Complete80% HTML & CSS 20% Complete70% JavaScript & JQuery 20% Complete50% Python 20% Complete45% Bootstrap 4 20% Complete40% Stock Analysis 20% Complete35% Git 20% Complete25% Chinese 20% Complete100% Taiwanese 20% Complete90% English 20% Complete80% Japanese 20% Complete35% Awards WHERE I SHINE Mayor Prize, Taichung City NCU College of Management,United Classes of Calculus 2019 Exam3 [21th place] JLPT N5 Certificate Interests OUT OF OFFICE Animation Reading Coding Web Design Stock Computer Science I'd love to hearfrom you qixiang1009@gmail.comhttps://github.com/QI-XIANG &copy; 2021 By Qi-Xiang Zhang.Proudly created with Bootstrap 4. //Get the button var mybutton = document.getElementById(\"myBtn\"); // When the user scrolls down 20px from the top of the document, show the button window.onscroll = function() {scrollFunction()}; function scrollFunction() { if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) { mybutton.style.display = \"block\"; } else { mybutton.style.display = \"none\"; } } // When the user clicks on the button, scroll to the top of the document function topFunction() { document.body.scrollTop = 0; document.documentElement.scrollTop = 0; } if (top.location !== self.location) { top.location.href = \"https://www.google.com\"; // 很不負責的轉給Google... XD } //audio play var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor); if (!isChrome){ $('#iframeAudio').remove() } else { $('#playAudio').remove() // just to make sure that it will not have 2x audio in the background }"}],"posts":[{"title":"IP位址計算 (IPv4 適用)","slug":"IP位址計算-IPv4-適用","date":"2022-03-05T18:00:00.000Z","updated":"2022-03-09T09:38:16.582Z","comments":true,"path":"2022/03/06/IP位址計算-IPv4-適用/","link":"","permalink":"https://qi-xiang.github.io/2022/03/06/IP%E4%BD%8D%E5%9D%80%E8%A8%88%E7%AE%97-IPv4-%E9%81%A9%E7%94%A8/","excerpt":"","text":"大二修企業資料通訊(BDC)時，對於IP位址的計算一竅不通，上網看教學影片、文章仍然無法學會，後來到圖書館借書時，偶然翻到網路概論的書，才讓我學會如何計算XD。 IP 位址是用來幹嘛的? 在網路上的所有裝置都要有一個獨一無二的IP位址，作為傳送和接收資料的地址。在現實生活中，IP位址的功用就像是郵件上都會有的收件人地址和寄件人地址，收件人地址讓信件可以被正確送達，寄件人地址則讓收到信的人可以回信。 (圖片來源: https://www.homenethowto.com/basics/ip-addresses/) IP 位址的表示方式 IP 位址是由 32 bits的二進位數字表示，也就是由32個0或1組成 : 101111111000000000000000000000001 上面那一串數字真的讓人霧煞煞，所以我們可以透過下列方式做轉換 : 將 32 bits 的 IP 位址每 8 bits 切成一段 101111111 00000000 00000000 00000001 將每一段的二進位數字轉回十進位，再以.隔開每一段 : 1127.0.0.1 這樣就能比較容易看懂。 IP 位址的結構 IP 位址可以劃分為兩個部分 : 網路位址、主機位址 網路位址 識別所屬的網路 主機位址 識別所屬網路的裝置 舉例來說，某天拿到192.168.117.x的網段，前面的192.168.117就是用來辨別所屬網路的網路位址(24 bits)，後面的x則對應到可以分配的主機位址，x的長度總共有8 bits，所以可能的排列組合有256種(2的8次方)，換句話說總共有256個主機位址可以分配給256個裝置使用。 將這個概念做延伸，不難發現前面的網路位址越短，可以分配的主機位址就會越多，為了滿足不同規模的網路需求，又依據網路位址的長度區分出不同的 IP 位址等級。 (實際上的長度劃分不一定是這樣，這邊僅是舉例) IP 位址的等級 當初設計 IP 時，將 IP 位址分成五個等級(Class A、B、C、D、E) 一般常用的是 Class A、B、C 這三種等級的 IP 位址，分別適用在大、中、小型網路，負責管理IP位址的機構，可以依照申請者所需要的網路規模，賦予不同等級的IP位址。 Class A 網路位址為 8 bits，第1個 bit(前導位元)必須是0。 網路位址從00000000~01111111，總共有128(2的7次方)個可以運用的網路位址(2的7次方)。主機位址為 24 bits，可以運用的位址總數為16777216個(2的24次方)。目前大部分的 Class A 都已經分配給過去有參與 ARPAnet(Internet的前身) 實驗的政府機關、學術單位等等，所以現在無法取得 Class A 的IP位址。 Class B 網路位址為 16 bits，前2個 bits(前導位元)必須是 10。Class B的 IP 位址必定介於128.0.0.0~191.255.255.255。主機位址為 16 bits，可以運用的位址總數為65536個(2的16次方)。大部分的 Class B 都被分配給大企業或ISP使用。 Class C 網路位址為 24 bits，前3個 bits(前導位元)必須是 110。Class C 的 IP 位址必定介於192.0.0.0~223.255.255.255。主機位址為 8 bits，可以運用的位址總數為256個(2的8次方)。Class C 通常都被分配給小企業使用。 特殊的IP位址 主機位址全為0 用來代表這個網路，以 Class C為例，196.67.208.0用來代表該 ClassC 網路。 主機位址全為1 代表網路中的所有位址，主要是用在廣播上面。假設有電腦送出目的地為196.67.208.255的封包，則代表對196.67.208.0這個網路的所有裝置進行廣播(所有裝置都會收到封包)。 段落重點整理 從 IP 位址的第一段我們就能看出它所屬的 IP 位址等級。例如: 168.0.0.1可以從 168 判斷它是一個 Class B 的 IP 位址，IP 位址的前 16 bits 為網路位址，後 16 bits 為主機位址。 Class A : 0.0.0.0~127.255.255.255 Class B : 128.0.0.0~191.255.255.255 Class C : 192.0.0.0~223.255.255.255 子網路 IP 位址等級的切割固然方便，但彈性卻略顯不足。假設有人拿到 Class B 的 IP 位址，實際上只連接數十台電腦，那這樣不是會有很多位址被浪費掉嗎? 要解決這個問題可以透過將網路切割成更小的子網路來避免 IP 位址浪費的同時，增加原本3種 IP 位址等級的彈性。而在切割子網路前，務必要先思考需要多少個子網路，以及每個子網路需要連結多少台主機。 切割子網路的原理 簡單來說切割子網路就是向 IP位址 中的主機位址借前幾個位元作為子網路位址。 假設拿到的 Class B IP 位址是這樣 : 借主機位址的前 3 bits 作為子網路位址: 子網路位址與原有的網路位址合計共佔 19 bits，可以被視為是一個新的網路位址，用來識別該子網路。原先 16 bits 的網路位址是不可更動的，但子網路位址是可以自由分配的，在範例中從主機位址借用 3 bits，產生了8(2的3次方)個子網路。 範例中，原先 Class B 總共有 65536(2的16次方) 個可分配的主機位址，經過切割後每個子網路(共8個)則有 8192(2的13次方) 個可分配的主機位址，理論上從主機位址借到 15 bits 可以形成 32768 (2的15次方) 個子網路，而每個子網路有2個可分配的主機位址，但不幸的是主機位址不能全為0或1，所以上述的主機位址通通都要扣2，也就是說最多只能從主機位址身上借到前 14 bits。 子網路遮罩 在切割完子網路後，可以發現不論原先是哪一等級的 IP 位址，網路位址都不會再是原來的長度(8、16、24 bits)，那要怎麼確認切割後，現在網路位址的長度呢? 答案是我們可以用子網路遮罩來確認借用幾 bit 的主機位址。 子網路遮罩的結構 長度為 32 bits 與 IP 位址對應 必須由連續一串的1再和連續一串的0組合而成 可以用十進位表示(和 IP 位址相同) 轉成十進位表示 : 111111111 11111111 11111111 00000000 =&gt; 255.255.255.0 子網路遮罩一定要與 IP 位址搭配使用，單獨存在沒有意義。把 IP 位址和子網路遮罩擺在一起看時，子網路遮罩 1 的長度範圍對應到的是這組 IP 位址的網路位址，0 的長度範圍則對應到這組 IP 位址的主機位址。 以下用圖來說明會比較清楚 : 子網路遮罩由21個連續的1和11個連續的0組成，對應到 IP 位址(Class B)代表最前面的 21 bits 是網路位址，剩下的 11 bits 則是主機位址。 另外，也可以將範例的168.95.192.1套用子網路遮罩後簡寫成168.95.192.1/21，/21代表網路位址有 21 bits，同時也是子網路遮罩有21個連續的1的意思。 不進行子網路切割則各等級 IP 位址的子網路遮罩如下 : 以上就大致交代完 IP 位址的基礎了，當然還有蠻多東西沒有講，不過就讓我用一些應用題目結束這回合吧! 應用問題 以下都是蒐集來的題目 : 某主機的 IP 位址為 192.168.1.134，子網路遮罩為 255.255.255.248，則該主機的&quot;網路位址&quot;為何? 從第一段的數字192可以看出是 Class C 的 IP 位址，然後將 IP 位址中的最後一個數字134轉成二進制並和子網路遮罩比對 : 可以發現這組 IP 位址落在 10000 這個子網路裡面，轉成十進位後，此子網路的網路位址為 192.168.1.128。 在 Class C 等級網路中若要分出至少13個子網路，則子網路遮罩為何? 向主機位址借 4 bits 就可以切出 16(2的四次方) 個子網路，故子網路遮罩為 11111111 11111111 11111111 11110000 (255.255.255.240)。 255.255.252.0 這個子網路遮罩最多可以將 132.114.0.0 這個網路分成幾個有效的子網路? 每個子網路最多可以有幾台主機? 由 IP 位址第一個數字132，可以確認它是 Class B 的 IP 位址，經比對之後發現向主機位址借用 6 bits 作為子網路位址，所以最多可分出 64 (2的6次方) 個子網路，每個子網路可以容納 1024-2 = 1022 (2的10次方減去主機位址全為0或1) 台主機。 之後有空應該會再寫其他填坑的文章~~~","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"填坑系列","slug":"填坑系列","permalink":"https://qi-xiang.github.io/tags/%E5%A1%AB%E5%9D%91%E7%B3%BB%E5%88%97/"}]},{"title":"建置簡單 Line 聊天機器人","slug":"聊天機器人","date":"2022-02-24T16:25:00.000Z","updated":"2022-03-08T14:58:14.481Z","comments":true,"path":"2022/02/25/聊天機器人/","link":"","permalink":"https://qi-xiang.github.io/2022/02/25/%E8%81%8A%E5%A4%A9%E6%A9%9F%E5%99%A8%E4%BA%BA/","excerpt":"","text":"Hint: 筆記內容主要來自: iT邦幫忙 - LINE BOT 新手村30日攻略系列 的部分重點節錄。 ¶Our Goal &amp; Ability You Need ¶1. 目的: 實做出一個可以回應使用者的天氣預報 line 機器人 :muscle: ¶2. 需要具備的能力: Line 帳號 Python 環境 Python 基礎語法 分析JSON資料 學習熱誠 接下來進入實作環節 ! ¶Setting Environment LINE Messenging API LINE BOT設定 Hint: 將我們希望回覆的訊息格式和內容以特定的JSON格式回覆給Messenging API，指定的 JSON格式檔案就可以在我們的 BOT Server 及 LINE Platform 之間以HTTPS的方式，傳遞這則訊息給用戶。 ¶Step1. LINE BOT設定 ¶新增LINE BOT 前往 https://developers.line.biz/ 並 登入/創建LINE帳號 新增Providers 登入 LINE 帳號後看到介面如下 :point_down: 接下來點擊 Create 輸入Providers name，可以隨意填寫，只要下面都是綠色勾勾就可以~ 新增 Messenger API channel 點選 Create a Messenging API channel 接下來修改以下內容: Channel name Channel description Category Subcategory Email address 其餘選填 填完後下方選項打勾並點選 Create ¶產生Access token 到 Messaging API 在最下面找到 Channel access token 並點擊 issue 務必將此token記下來!之後會用到喔! ¶Channel Secret 請到 Basic settings 往下找到Channel secret 務必將此secret記下來!之後會用到喔! ¶啟用webhook 前往 LINE manager 選擇剛剛新增的BOT 按右上角設定 選擇左側的回應設定 ， 將進階設定中的 Webhook勾選啟用、自動回覆訊息改為停用 到這邊關於LINE BOT的設定就告一段落 :smile: ¶Step2. 下載Python套件 LINE官方關於python部分有提供 line-bot-sdk 此外，我們也會用到 flask 套件 win+R 開啟cmd 輸入以下指令 1pip3 install line-bot-sdk flask Python的部分完成囉! ¶Step3. 開發用資料夾 上面的套件都下載&amp;安裝完後就新增一個資料夾吧~ 之後所有的資料都會放在這個資料夾裡面 ¶Step4. 下載ngrok 做本機測試會用到ngrok，這邊就先下載 建議放在剛剛新增的資料夾裡面，之後會比較方便使用 前往 https://ngrok.com/download 下載windows版ngrok 如果你是使用WSL或是Linux系統可以下載Linux版ngrok 前置作業終於完成 ! :+1: ¶實作 - 鸚鵡式機器人 Hint: 所謂鸚鵡式機器人就是 你說甚麼，它就說甚麼 Coding 使用webhook建立連線 接收使用者訊息 回覆使用者訊息 ¶Coding 先到建立的開發用資料夾中開啟新檔案，建議使用VScode開啟。 名稱就叫main.py 將模板放入main.py中 12345678910111213141516171819202122232425262728293031323334353637383940from flask import Flask, request, abortfrom linebot import ( LineBotApi, WebhookHandler)from linebot.exceptions import ( InvalidSignatureError)from linebot.models import *app = Flask(__name__)# LINE BOT infoline_bot_api = LineBotApi(&#x27;Channel Access token&#x27;)handler = WebhookHandler(&#x27;Channel Secret&#x27;)@app.route(&quot;/callback&quot;, methods=[&#x27;POST&#x27;])def callback(): signature = request.headers[&#x27;X-Line-Signature&#x27;] body = request.get_data(as_text=True) app.logger.info(&quot;Request body: &quot; + body) print(body) try: handler.handle(body, signature) except InvalidSignatureError: abort(400) return &#x27;OK&#x27;# Message event@handler.add(MessageEvent)def handle_message(event): message_type = event.message.type user_id = event.source.user_id reply_token = event.reply_token message = event.message.text line_bot_api.reply_message(reply_token, TextSendMessage(text = message))import osif __name__ == &quot;__main__&quot;: port = int(os.environ.get(&#x27;PORT&#x27;, 8888)) app.run(host=&#x27;0.0.0.0&#x27;, port=port) Channel Access token 以及 Channel Secret 改成上面提到要記的兩個值放入 1234app = Flask(__name__)# LINE BOT infoline_bot_api = LineBotApi(&#x27;Channel Access token&#x27;)handler = WebhookHandler(&#x27;Channel Secret&#x27;) 指定在 /callback 通道上接收訊息，且方法是 POST 而 callback() 是為了要檢查連線是否正常 其中 signature 是LINE官方提供用來檢查該訊息是否透過LINE官方APP傳送 而 body 就是用戶傳送的訊息，並且是以 JSON 的格式傳送 1234567891011@app.route(&quot;/callback&quot;, methods=[&#x27;POST&#x27;])def callback(): signature = request.headers[&#x27;X-Line-Signature&#x27;] body = request.get_data(as_text=True) app.logger.info(&quot;Request body: &quot; + body) print(body) try: handler.handle(body, signature) except InvalidSignatureError: abort(400) return &#x27;OK&#x27; 這邊是用來接收訊息的地方 特別注意到 line_bot_api.reply_message() 它是回傳訊息的方法，而我們設定回傳的型態是文字(text) 12345678# Message event@handler.add(MessageEvent)def handle_message(event): message_type = event.message.type user_id = event.source.user_id reply_token = event.reply_token message = event.message.text line_bot_api.reply_message(reply_token, TextSendMessage(text = message)) 接收到的訊息會被放在event中，一樣會是JSON格式 events.message.type 這裡記錄訊息的型態 events.message.text 如果是文字訊息(text) 這裡會記錄傳送的文字 events.sourse.userId 這裡記錄使用者的ID 指定BOT執行的位置是在 0.0.0.0:8888 接上前面所說的，BOT會接收訊息的位置會是0.0.0.0:8888/callback 1234import osif __name__ == &quot;__main__&quot;: port = int(os.environ.get(&#x27;PORT&#x27;, 8888)) app.run(host=&#x27;0.0.0.0&#x27;, port=port) ¶Webhook Hint: 當LINE Platfrom接收到來自使用者的訊息後，透過API接口，webhook通道使得LINE Platform從被動方變成主動方，將訊息傳送到BOT Server ¶實作開始 實際上，這份code已經完成了鸚鵡的功能了，那接下來就讓它動起來吧 ! 執行ngrok.exe 在命令提示視窗執行以下指令 1ngrok.exe http 8888 執行cmd，移動路徑到專案的資料夾中 在cmd執行以下指令 1python main.py 目前為止，你的畫面應該會是這樣 你會發現有一個會將訊息導向 localhost:80 上的webhook 現在只需要讓LINE 知道webhook在哪裡就完成了! 前往 https://manager.line.biz/ 登入自己的LINE帳號，並進入自己的LINE BOT 點擊右上角的設定 &gt; Messaging API 將Webhook網址改成剛剛ngrok上看到的網址加上/callback並儲存 圖片中忘記加上callback，請記得補上 這樣一來，通道就建構成功啦! 先將LINE BOT加入好友後來試試看功能吧! LINE ID可以在剛剛的網頁上方找到 接下來就可以跟自己的BOT聊天","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"LineBot超入門","slug":"LineBot超入門","permalink":"https://qi-xiang.github.io/tags/LineBot%E8%B6%85%E5%85%A5%E9%96%80/"}]},{"title":"遲來的鐵人賽心得","slug":"遲來的鐵人賽心得","date":"2022-02-15T12:05:00.000Z","updated":"2022-03-08T15:03:55.754Z","comments":true,"path":"2022/02/15/遲來的鐵人賽心得/","link":"","permalink":"https://qi-xiang.github.io/2022/02/15/%E9%81%B2%E4%BE%86%E7%9A%84%E9%90%B5%E4%BA%BA%E8%B3%BD%E5%BF%83%E5%BE%97/","excerpt":"","text":"某人可能會遲到，但從不缺席 (沒x 失蹤很久了好嗎== ¶故事原點 在正式參加鐵人賽之前，我從不知道有這個活動，或者也可以說沒有真正的逛過iT邦幫忙這個網站。第一次真正意義上讓我看到鐵人賽，是因為在學校上UNIX作業系統時遇到瓶頸，然後著急地到網路上尋找其他人學習恐龍書之後所寫的心得，緣分使然讓我在無意間看到&quot;小黑馬作業系統教室統整&quot;的鐵人賽系列文(已被下架QQ)，令我在重新拾回學習信心同時，也在心中浮現下次的鐵人賽參賽計畫(2021第13屆)。 恐龍書 (圖源: 三民網路書店) 由於是初次參加鐵人賽，我選擇報名的是&quot;自我挑戰組&quot;。(或許是因為覺得相對自由的關係?) 在想這30天要寫些什麼的時候，我最原始的想法是想寫我開始接觸網頁的心得，像是網頁三本柱以及前期踩的坑之類的，但後來看到有人分享 JS30 的課程心得，又因為它剛好就是30天的課程，當下我就確定要寫&quot;JS30學習日記&quot;系列文。 ¶故事伊始 在鐵人賽正式開賽(2021-09-01)之前，我有思考過該不該寫稿起來放(後來在鐵人賽開賽後沒幾天，我就看到有人在文章中說他已經寫完30天的文章。自爆XD)，考慮到時間安排彈性的問題，我在開賽前屯了10篇左右的稿子。 當然不是說我每天晚上12:00剛過，就上來丟篇文章打卡這麼簡單，如果各位大大、前輩們有稍微看過我寫的系列文，就會發現我JS真的很菜，非常依賴在網路上查各種算是&quot;常識&quot;的資料(我自己認為是這樣)，查資料的時間甚至比我看課程影片+寫學習心得的時間還要長哈哈。 ¶故事途中 前期每天就在準時上來發心得文(確認發表前我都會再確認一次內容，盡量讓文章不要出現錯字)、寫之後的文章內容、觀看教學影片以及查大量的資料中平靜地度過。 而故事的轉折點，發生在開學之後課業(大學生ing~)與鐵人賽的事情剛好重疊在一起，我開始只能用相對零碎的時間來寫鐵人賽的系列文。 ¶故事轉折 對我這個大學生而言，開學第一週都在思考整學期的課程安排，要怎麼選到可以帶走東西的課是每學期都有的挑戰，我會非常仔細地看課程大綱還有之前的課程評價等等來參考，當然有些萬惡的必修課仍無法避免XD。 想當然耳，跟前面說的一樣只能用零碎的時間繼續維持每天發文，過程中也曾經想要放棄，但畢竟就剩幾天就可以完賽，心裡浮現的那份不甘願促使我要繼續往前進。 我也稍微能夠體會為什麼有些優質系列文會無法挑戰成功，因為真的會有很多突發狀況讓人沒有時間寫完，一篇優質的文章或許只要短短不到10分鐘就能快速閱讀完畢，但作者卻要花數倍時間來寫和整理相關資料。 ¶故事尾聲 在Stack Overflow、前人的JS30課程筆記、MDN Web Docs的大力支援下，&quot;JS30學習日記&quot;系列文就這樣順利地完成了。儘管因為開學，比較後面的文章有寫得比較隨便，但完賽的那個瞬間，真的帶給我滿滿的感動與成就感。除此之外，瀏覽次數、Like數、訂閱數的跳動，都讓我有被人認同的感覺。 最後真的非常感謝網路上的各位前輩們~ (更新於2022/02/28)","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"生活經驗分享","slug":"生活經驗分享","permalink":"https://qi-xiang.github.io/tags/%E7%94%9F%E6%B4%BB%E7%B6%93%E9%A9%97%E5%88%86%E4%BA%AB/"}]},{"title":"奇蹟似的通過日檢N4","slug":"奇蹟似的通過日檢N4","date":"2022-01-26T17:40:00.000Z","updated":"2022-03-08T15:19:16.437Z","comments":true,"path":"2022/01/27/奇蹟似的通過日檢N4/","link":"","permalink":"https://qi-xiang.github.io/2022/01/27/%E5%A5%87%E8%B9%9F%E4%BC%BC%E7%9A%84%E9%80%9A%E9%81%8E%E6%97%A5%E6%AA%A2N4/","excerpt":"","text":"在分享心得前，先附上我日檢N4的成績： 檢定通過標準： 對，你沒看錯我只比合格線高4分哈哈。在這邊我先自首，我真的沒有花很多時間在準備日檢，因為同一時間有系統設計的期末報告還有IoT的小專題，只用零碎的時間讀再配合修學校開的日文選修課，能過真的是奇蹟! (ps.學校的日文選修課只有摸到N4的一些範圍) 我自己本身並不是日文科系的學生，會開始學日文完全是因為喜歡看動畫(能不看字幕把焦點放在動畫本身是我一直以來追求的目標) 後來在大一的寒假，我買了第一本日文參考書開始自主學習，搭配著名的50音之歌，我很快就背完50音。 起初完全都是靠自己用力K書，把文法、單字通通背起來，但卻逐漸陷入瓶頸，所以我後來加購同一本參考書出的教學光碟，進入獲得系統性教學的階段。 而在大一下終於讓我選上學校超難選的日文課，我發現我寒假學的東西超出課堂蠻多的，雖然過得很輕鬆，但跟不同日文老師學習，可以聽到更多不同的說法，只能說賺爛了賺爛了~ (ps.3學分輕鬆入袋順便衝一波GPA) 接下來用 Q&amp;A 進行說明： Q1. 有特別練聽力? N5、N4的聽力說真的不難，只要平常有在看日本節目或動畫之類的，基本上可以輕鬆應付過去，就不要再浪費錢買聽力參考書啦~(ps.其實聽文法書的光碟也行) Q2. 使用的參考書? 文法: 大家學標準日本語初級、中級本 (自學用) 大家的日本語 初級Ⅰ、Ⅱ (修日文課用) 單字: 新日檢N5單字帶著背！ 新日檢N4單字帶著背！ Q3. 直接衝N4比較好? 如果是想省錢的話，當然不建議考N5，但如果只是出於興趣學習日文，那N5檢定應該能為你帶來莫大的信心。 Q4. N4的難點在哪? 聽力真的沒什麼，主要難在動詞變化，包括た型、て型、ない型還有其它各種型的變化還有相關的句型應用。另外，單字要認真背一下，日檢很喜歡把看起來很像的字都放在選項裡，像是有無長音う或促音っ。 Q5. 通過N4要準備多久? 假設你前面基本功很足，達到可以輕鬆通過N5的水準，那大概就只要再花點時間學點動詞變化的皮毛和些許單字就可以低空飛過，我是在準備的同時，手邊還有太多事，前後大概也就考試前1-2個月前開始準備吧！ 剩下有問題都可以在下面問，我會盡量回~ 祝大家都能順利考過日文檢定!","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"生活經驗分享","slug":"生活經驗分享","permalink":"https://qi-xiang.github.io/tags/%E7%94%9F%E6%B4%BB%E7%B6%93%E9%A9%97%E5%88%86%E4%BA%AB/"}]},{"title":"關於我開始寫電子筆記這檔事","slug":"關於我開始寫電子筆記這檔事","date":"2022-01-26T09:20:00.000Z","updated":"2022-03-08T15:34:18.223Z","comments":true,"path":"2022/01/26/關於我開始寫電子筆記這檔事/","link":"","permalink":"https://qi-xiang.github.io/2022/01/26/%E9%97%9C%E6%96%BC%E6%88%91%E9%96%8B%E5%A7%8B%E5%AF%AB%E9%9B%BB%E5%AD%90%E7%AD%86%E8%A8%98%E9%80%99%E6%AA%94%E4%BA%8B/","excerpt":"","text":"首先，我必須先說本篇真的不是在幫HackMD打廣告，純粹是想稍微分享我開始寫電子筆記這件事。 其實從小到大我都有做筆記的習慣，但傳統紙本筆記最大的缺點在於保存不易，以前寫的厚厚一本筆記在成長的過程中直接失蹤。 從小學到高中的求學過程中，有很大一部份的時間都在補習班度過，也就沒有機會接觸到可以快速寫出精美筆記的軟體或網站。 直到大學，作筆記變成是每個人都要會的基本功(至少在我的班上是這樣~)，又因為我是資訊科系的學生，很容易就整天都泡在網路世界(ex. youtube)。 在此不得不說YT的演算法真的挺神的，讓我在偶然間看到Papaya電腦教室介紹Obsidian這款筆記軟體的影片，直接shock到我，開始使用它來寫電子筆記。 (ps.終於有手機APP可以用啦~ 但用手機寫markdown語法真的挺哭的QQ) 就這樣我愛上寫電子筆記，那HackMD又是如何走進我的視野呢? 前面有說過我是資訊科系的學生，所以理所當然的有Github帳號，到處亂逛別人repository的過程中，我發現有些大佬的技術文件是用HackMD寫的，出於好奇我試著用它陸續寫了幾篇筆記，沒想到一試成主顧用它到現在。 從2021.5.27開始使用到現在，在HackMD上我已經有100多篇筆記和3本電子書，寫電子筆記真的有種令人沉迷其中的力量。 對我來說，寫筆記是為了形塑出在未來的某一天能夠快速找回事物印象的知識庫~","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[]},{"title":"CSS Flex Box Chapter2.","slug":"Chapter2","date":"2022-01-22T19:15:00.000Z","updated":"2022-03-08T15:32:19.144Z","comments":true,"path":"2022/01/23/Chapter2/","link":"","permalink":"https://qi-xiang.github.io/2022/01/23/Chapter2/","excerpt":"","text":"¶material from: freeCodeCamp、CSS Tools: Reset CSS ¶Use the flex-direction Property to Make a Row 透過新增display:flex;這個屬性設定到元素上，該元素就會變成一個有彈性的容器(flex container)。 接下來可以進一步設定flex-direction，調整容器內部子元素的擺放方式，是要以列(row)或欄(column)作排列， 設定flex-direction:row;則子元素會以水平方向作排列；設定flex-direction:column;則子元素會以 鉛直方向作排列。 順帶一提，若想要倒序排列子元素，則可分別設定flex-direction:row-reverse;或flex-direction:column-reverse;。 在不做任何設定的情況下，預設flex-direction:row;。 Initial 12345678910111213141516171819202122&lt;style&gt; #box-container &#123; display: flex; height: 500px; &#125; #box-1 &#123; background-color: dodgerblue; width: 50%; height: 50%; &#125; #box-2 &#123; background-color: orangered; width: 50%; height: 50%; &#125;&lt;/style&gt;&lt;div id=&quot;box-container&quot;&gt; &lt;div id=&quot;box-1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;box-2&quot;&gt;&lt;/div&gt;&lt;/div&gt; flex-direction:row; 1234567&lt;style&gt; #box-container &#123; display: flex; height: 500px; flex-direction: row; &#125; ... flex-direction:column; 1234567&lt;style&gt; #box-container &#123; display: flex; height: 500px; flex-direction: column; &#125; ... flex-direction:row-reverse; 1234567&lt;style&gt; #box-container &#123; display: flex; height: 500px; flex-direction: row-reverse; &#125; ... flex-direction:column-reverse; 1234567&lt;style&gt; #box-container &#123; display: flex; height: 500px; flex-direction: column-reverse; &#125; ...","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"網頁基礎","slug":"網頁基礎","permalink":"https://qi-xiang.github.io/tags/%E7%B6%B2%E9%A0%81%E5%9F%BA%E7%A4%8E/"}]},{"title":"CSS Flex Box Chapter1.","slug":"Chapter1","date":"2022-01-22T18:45:03.000Z","updated":"2022-03-08T15:32:14.495Z","comments":true,"path":"2022/01/23/Chapter1/","link":"","permalink":"https://qi-xiang.github.io/2022/01/23/Chapter1/","excerpt":"","text":"¶material from: freeCodeCamp、CSS Tools: Reset CSS ¶Use display: flex to Position Two Boxes 這邊算是 flex box 的初入門，display:flex 宣告父容器要用 flex box 的形式放置網頁元素。 因為下面設定2個box各佔50%寬度的關係而且沒有多寫flex: wrap;，所以在縮放視窗時，沒辦法感受到 flex box 的威力，原則上所有子元素都會被排在同一列上。 12345678910111213141516171819202122&lt;style&gt; #box-container &#123; #父容器 height: 500px; display: flex; &#125; #box-1 &#123; #子元素 background-color: dodgerblue; width: 50%; #均分寬度 height: 50%; &#125; #box-2 &#123; background-color: orangered; width: 50%; height: 50%; &#125;&lt;/style&gt;&lt;div id=&quot;box-container&quot;&gt; &lt;div id=&quot;box-1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;box-2&quot;&gt;&lt;/div&gt;&lt;/div&gt; 有display: flex; 沒有display: flex; ¶Practice: Simple Image Gallery 上面的東西只要再多個flex: wrap;就可以做個簡易的 Image Gallery，flex: wrap;在後面會提到，現在只要知道它可以讓原本&quot;被迫&quot;排在一起的元素，按實際指定的 width 依序排在不同列上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;body&gt; &lt;div class=&quot;box-container&quot;&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box5&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box6&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;style&gt; .box-container&#123; height: 100%; display: flex; flex-wrap: wrap; &#125; .box1&#123; width: 50%; height: 250px; background-color: rgb(140, 231, 231); &#125; .box2&#123; width: 50%; height: 250px; background-color: rgb(120, 243, 202); &#125; .box3&#123; width: 33.3333%; height: 250px; background-color: rgb(65, 136, 136); &#125; .box4&#123; width: 33.3333%; height: 250px; background-color: rgb(105, 126, 126); &#125; .box5&#123; width: 33.3333%; height: 250px; background-color: rgb(57, 83, 83); &#125; .box6&#123; width: 100%; height: 250px; background-color: rgb(9, 160, 160); &#125;&lt;/style&gt; 加上圖片再調整個別高度就完成啦~ ps. 現在的長寬比是照我的螢幕尺寸做規劃，其他尺寸的螢幕有可能會跑版。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;body&gt; &lt;div class=&quot;box-container&quot;&gt; &lt;div class=&quot;box1&quot;&gt;&lt;img src=&quot;image/thumb1.jpg&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;img src=&quot;image/thumb2.jpg&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;img src=&quot;image/thumb3.jpg&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt;&lt;img src=&quot;image/thumb4.jpg&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box5&quot;&gt;&lt;img src=&quot;image/thumb5.jpg&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box6&quot;&gt;&lt;img src=&quot;image/thumb6.jpg&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;style&gt; .box-container&#123; height: 100%; display: flex; flex-wrap: wrap; &#125; .box1&#123; width: 50%; height: 350px; background-color: rgb(140, 231, 231); &#125; .box2&#123; width: 50%; height: 350px; background-color: rgb(120, 243, 202); &#125; .box3&#123; width: 33.3333%; height: 250px; background-color: rgb(65, 136, 136); &#125; .box4&#123; width: 33.3333%; height: 250px; background-color: rgb(105, 126, 126); &#125; .box5&#123; width: 33.3333%; height: 250px; background-color: rgb(57, 83, 83); &#125; .box6&#123; width: 100%; height: 650px; background-color: rgb(9, 160, 160); &#125;&lt;/style&gt;","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"網頁基礎","slug":"網頁基礎","permalink":"https://qi-xiang.github.io/tags/%E7%B6%B2%E9%A0%81%E5%9F%BA%E7%A4%8E/"}]},{"title":"原子習慣 書摘(3)","slug":"atomhabit-3","date":"2021-12-06T03:33:44.000Z","updated":"2022-03-08T15:34:29.029Z","comments":true,"path":"2021/12/06/atomhabit-3/","link":"","permalink":"https://qi-xiang.github.io/2021/12/06/atomhabit-3/","excerpt":"","text":"¶四個簡單的步驟，讓你建立更好的習慣 內容待補…","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"原子習慣","slug":"原子習慣","permalink":"https://qi-xiang.github.io/tags/%E5%8E%9F%E5%AD%90%E7%BF%92%E6%85%A3/"}]},{"title":"原子習慣 書摘(2)","slug":"atomhabit-2","date":"2021-11-02T16:51:28.000Z","updated":"2022-03-08T15:34:25.495Z","comments":true,"path":"2021/11/03/atomhabit-2/","link":"","permalink":"https://qi-xiang.github.io/2021/11/03/atomhabit-2/","excerpt":"","text":"¶第二章 改變習慣的最有效方法，是改變身分認同 改變習慣之所以如此具有挑戰性，原因有二 : 試圖改變的東西不對 試圖改變習慣的方式不對 改變的發生分成三個層次 : 改變結果 : 重點放在改變成果，設定的目標多與這個層次的變化有關 改變過程 : 重點在於改變習慣與系統，建立的習慣多與此有關 改變身分認同 : 三層次中最為重要，主在改變信念、世界觀、自我形象、對自己與他人的評價，抱持的信念、假設或偏見多與此相關 結果 : 得到什麼 過程 : 做了什麼 身分認同 : 相信什麼 每一層次的改變各有其用處，問題在於改變的方向。 一般人在改變習慣的過程中，常把重點放在想要達成什麼，以結果為基礎建立習慣。而比較好的做法是以身分認同建立習慣，把重點放在想成為什麼樣的人。 許多人設立目標，然後確立要達成目標必須採取的行動，但卻不加思考驅使他們採取那些行動的信念，不去改變過去看待自己的方式，同時亦不知舊的身分認同，會破壞為了改變而打造的新計畫。 每個行動系統的背後都是一個信念系統。 以投票為例，在獨裁統治這個信念系統下，投票這個行為是不可行的。不是那個系統的身分認同，行為在某些信念之下是不可能被實現的。 信念與假設形塑出系統，習慣的背後往往存在著身分認同。 或許你現在有新的目標與計劃，但你還沒改變自己是什麼樣的人。 越是以身分認同中的某個特定面向自豪，越有動力去維持相關的習慣，但只要行為背後的信念不改變，就很難維持長期的轉變。 真正能帶來行為上改變的是身分認同的轉變。例如 : 目標不是去讀一本書，而是成為讀書的人。 行為可以反映出身分認同，一個人的所作所為暗示他相信自己是什麼樣的人。 當一個人相信他身分中的某個特定面向，就越有可能採取與之相符的行動。 為你所用時，身分認同的改變會是自我改善的一大利器；但與你為敵時，身分認同卻反倒成了一種詛咒，例如 : 附加在身分認同上的刻版印象。 我方向感很差、不擅長數學、整天遲到，不斷反覆對自己訴說同一件事，長期就容易開始抗拒某些事。思想或行為與身分認同牽扯越深，就越難去做出改變。 好習慣在理性上也許合理，但只要與身分認同相左，就很難產生實踐的念頭。若要持續的進步就不能一味依附在特定的身分認同，而是必須不斷修正、拓展自身的身分認同。 ¶改變身分認同的兩個步驟 人不是一生下來就擁有預設信念，每個信念以及對自身的看法，都由後天的經驗形塑而成。習慣恰好是個人身分認同的具體化。 越是重複某一行為，就越強化與那個行為相關的身分認同。 有越多證據支持某個信念，就越會對其深信不疑。 一次性經驗的效果容易消失，但習慣的效果卻會隨時間不斷增強。 每次採取的行動都像一張選票，投給想要成為的那一種人。沒有單一例證可以改變你的信念，但隨著票數累積，新身分的證據也聚沙成塔。 習慣就是通往身分認同轉變的道路。要改變你是什麼樣的人，最實際的方法就是改變你做的事。 每次選擇去做某個壞習慣，就相當於投一票給那個身分，但在每一次的選舉中，並不一定要拿到所有的選票才能獲勝，只要保證在多數情況下都是由好習慣獲勝就好。 型塑新身分認同的兩步驟 : 決定你想要成為什麼樣的人 透過生活中的小勝利來向自己證明 將焦點從成果轉往身分認同。 你的習慣型塑你的身分認同，你的身分認同又型塑你的習慣，這是一條雙向道。 焦點永遠都要放在成為某一種人，而非得到某一種成果。 ¶習慣會讓你變成你想要成為的人 你有能力改變對自身的信念。你的身分認同並非不可變更，每一刻你都有選擇。 根本上，習慣的精髓並非擁有，而是成為。 歸根究柢，習慣之所以重要，是因為它們能夠讓你變成你想要成為的人。","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"原子習慣","slug":"原子習慣","permalink":"https://qi-xiang.github.io/tags/%E5%8E%9F%E5%AD%90%E7%BF%92%E6%85%A3/"}]},{"title":"2021/10/25 NLP Matplotlib(範例2)","slug":"nlp20211025-2","date":"2021-10-31T16:38:35.000Z","updated":"2022-03-08T15:29:07.437Z","comments":true,"path":"2021/11/01/nlp20211025-2/","link":"","permalink":"https://qi-xiang.github.io/2021/11/01/nlp20211025-2/","excerpt":"","text":"Bar chart 長條圖 matplotlib.pyplot.bar Python 長條圖（Bar Charts） matplotlib.pyplot.xticks 123456789101112#繪製長條圖#%matplotlib inline#導入必要的模組import matplotlibimport numpy as npimport matplotlib.pyplot as plt#指定 x、y座標x = [4, 5, 6, 7, 8, 9]y = [2, 10, 3, 2, 8, 7]plt.bar(x, y) #指定長條圖中的座標plt.show() #繪製出圖表 水平長條圖 123456789101112# barh()用來畫水平方向的長條圖#%matplotlib inline#導入必要的模組import matplotlibimport numpy as npimport matplotlib.pyplot as plt#指定 x、y座標x = [&#x27;sleep&#x27;, &#x27;study&#x27;, &#x27;play&#x27;]y = [2, 10, 3]plt.barh(x, y, color=&#x27;green&#x27;) #繪製水平方向的長條圖plt.show() #繪製出圖表 Grouped Bar Charts 123456789101112131415161718192021222324#%matplotlib inline#導入必要的模組import matplotlibimport numpy as npimport matplotlib.pyplot as pltN = 5men_means = (20, 35, 30, 35, 27)women_means = (25, 32, 34, 20, 25)ind = np.arange(N) # ind = [0 1 2 3 4]width = 0.25 #bar(x, height, width=0.8, bottom=None, *, align=&#x27;center&#x27;, data=None, **kwargs)#bar() 的第一個參數是 x 軸上的座標plt.bar(ind, men_means, width, label=&#x27;Men&#x27;)plt.bar(ind + width, women_means, width, label=&#x27;Women&#x27;) #將第二個長條圖的x座標加上width，讓它落在前一個長條圖之後plt.ylabel(&#x27;Scores&#x27;) #調整坐標軸名稱plt.title(&#x27;Scores by group and gender&#x27;) #設定圖表名稱#xticks(ticks=None, labels=None, **kwargs)plt.xticks(ind + width / 2, (&#x27;G1&#x27;, &#x27;G2&#x27;, &#x27;G3&#x27;, &#x27;G4&#x27;, &#x27;G5&#x27;)) #調整刻度的 x 座標，讓它剛好落在中間plt.legend(loc=&#x27;best&#x27;) #標示出各長條圖plt.show() #繪製出長條圖 Stacked Bar Charts 12345678910111213141516171819202122232425262728#%matplotlib inline#導入必要的模組import matplotlibimport numpy as npimport matplotlib.pyplot as pltcountries = [&#x27;USA&#x27;, &#x27;GB&#x27;, &#x27;China&#x27;, &#x27;Russia&#x27;, &#x27;Germany&#x27;]bronzes = np.array([38, 17, 26, 19, 15])silvers = np.array([37, 23, 18, 18, 10])golds = np.array([46, 27, 26, 19, 17])#產生有序串列，[(0, &#x27;USA&#x27;), (1, &#x27;GB&#x27;), (2, &#x27;China&#x27;), (3, &#x27;Russia&#x27;), (4, &#x27;Germany&#x27;)]ind = [x for x,_ in enumerate(countries)] #bar(x, height, width=0.8, bottom=None, *, align=&#x27;center&#x27;, data=None, **kwargs)[source]#bottom 參數使指要從 y 軸上的哪個座標開始繪製#bottom=silvers+bronzes，表示要畫在銅牌和銀牌之上plt.bar(ind, golds, width=0.8, label=&#x27;golds&#x27;, color=&#x27;gold&#x27;, bottom=silvers+bronzes) plt.bar(ind, silvers, width=0.8, label=&#x27;silvers&#x27;, color=&#x27;silver&#x27;, bottom=bronzes)plt.bar(ind, bronzes, width=0.8, label=&#x27;bronzes&#x27;, color=&#x27;#CD853F&#x27;)plt.xticks(ind, countries) #設定x方向的刻度plt.ylabel(&quot;Medals&quot;) #設定y座標標題plt.xlabel(&quot;Countries&quot;) #設定x座標標題plt.legend(loc=&quot;upper right&quot;) #標示出圖表內容plt.title(&quot;2012 Olympics Top Scorers&quot;) #賦予圖表標題plt.show() #繪製出圖表 Scatter chart matplotlib.pyplot.scatter 在 Matplotlib 中為散點圖設定顏色 Matplotlib 標記散點 散佈圖 12345678910111213141516#繪製散射圖#%matplotlib inline#導入需要的套件import matplotlibimport numpy as npimport matplotlib.pyplot as plt#指定散佈圖上每一點的座標x = [4, 4, 7, 7 , 8 , 5]y = [2, 10, 3, 2 , 8 , 7]&#x27;&#x27;&#x27;scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None,vmin=None, vmax=None,alpha=None, linewidths=None, *, edgecolors=None, plotnonfinite=False, data=None, **kwargs)&#x27;&#x27;&#x27;plt.scatter(x, y, color=&#x27;red&#x27;)#用紅色在圖表上標出所有點plt.show()#繪製圖表 分群散射圖 1234567891011121314151617181920212223#繪製分群散射圖#%matplotlib inline#導入需要的套件import matplotlibimport numpy as npimport matplotlib.pyplot as plt # Create dataN = 60 #指定隨機生成的陣列大小#numpy.random.rand() 函式生成具有隨機值的指定形狀的陣列。g1 = (0.6 + 0.6 * np.random.rand(N), np.random.rand(N))g2 = (0.4+0.3 * np.random.rand(N), 0.5*np.random.rand(N))g3 = (0.3*np.random.rand(N),0.3*np.random.rand(N))data = (g1, g2, g3)colors = (&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;) #指定點的顏色groups = (&quot;coffee&quot;, &quot;tea&quot;, &quot;water&quot;) #指定點的類別for data, color, group in zip(data, colors, groups): #zip()可以把元素整合成tuple x, y = data #從data取出點座標 plt.scatter(x, y, alpha=0.8, c=color, edgecolors=&#x27;m&#x27;, s=50, label=group) #畫散佈圖plt.legend(loc=2)#標示圖表內容plt.title(&#x27;Matplot scatter plot&#x27;)#賦予圖表標題plt.show()#實際繪製出圖表 12345x = [1,2,3]y = [4,5,6]for i in zip(x,y): #使用 zip函數把 list 內對應元素鏈起來(tuple) print(i) Histogram 如何在 Matplotlib 中繪製資料列表的直方圖 matplotlib.pyplot.hist Numpy numpy.random.rand()函式 直方圖 12345678910111213141516#繪製直方圖#%matplotlib inline#導入需要的套件import matplotlibimport numpy as npimport matplotlib.pyplot as pltx = [1, 17, 3, 24, 44]&#x27;&#x27;&#x27;hist(x, bins=None, range=None, density=False, weights=None, cumulative=False, bottom=None, histtype=&#x27;bar&#x27;,align=&#x27;mid&#x27;,orientation=&#x27;vertical&#x27;, rwidth=None, log=False, color=None, label=None, stacked=False, *, data=None, **kwargs)&#x27;&#x27;&#x27;#plt.hist(x, bins=[0, 10, 20, 30, 40, 50])plt.hist(x, bins=[0, 10, 20, 30, 40, 50], density=True) #bin設定數值區間 #density=True，以個數百分比表示高度plt.show() #繪製圖表 用高斯常態分配生成資料 123456789101112131415#%matplotlib inline#導入需要的套件import matplotlibimport numpy as npimport matplotlib.pyplot as plt## Generate gaussian number 高斯常態分配# mean = 2.0# std = 3.0# number of points = 1000data = np.random.normal(2.0, 3.0, 1000)#用高斯常態分配生成資料plt.hist(data)#bins預設是10plt.xlabel(&#x27;Value&#x27;)#設定x座標標題plt.ylabel(&#x27;Frequency&#x27;)#設定y座標標題plt.title(&#x27;Histogram&#x27;)#設定圖表的標題plt.show()#實際繪製出圖表 Boxplot matplotlib.pyplot.boxplot Matplotlib 繪製箱線圖 箱型圖 12345678910111213#%matplotlib inlineimport matplotlib.pyplot as plt# ref: http://www.datasciencemadesimple.com/box-plot-in-python/#箱型圖的資料們value1 = [82,76,24,40,67,62,75,78,71,32,98,89,78,67,72,82,87,66,56,52]value2=[62,5,91,25,36,32,96,95,3,90,95,32,27,55,100,15,71,11,37,21]value3=[23,89,12,78,72,89,25,69,68,86,19,49,15,16,16,75,65,31,25,52]value4=[59,73,70,16,81,61,88,98,10,87,29,72,16,23,72,88,78,99,75,30] box_plot_data=[value1,value2,value3,value4] #整合資料plt.boxplot(box_plot_data) #繪製箱型圖plt.show()#實際繪製圖表 Pie char matplotlib.pyplot.pie [Day20]Matplotlib資料視覺化進階！ 如何在 Matplotlib 中繪製圓 matplotlib.patches.Circle 圓餅圖 1234567891011#繪製圓餅圖import matplotlib.pyplot as plt labels = [&#x27;Cookies&#x27;, &#x27;Jellybean&#x27;, &#x27;Milkshake&#x27;, &#x27;Cheesecake&#x27;]#用來標示圖表sizes = [38.4, 40.6, 20.7, 10.3]#指定每一塊所占比例colors = [&#x27;yellowgreen&#x27;, &#x27;gold&#x27;, &#x27;lightskyblue&#x27;, &#x27;lightcoral&#x27;]#指定每一塊的顏色patches, texts = plt.pie(sizes, colors=colors, shadow=True, startangle=90)#startangle可以指定向逆時針旋轉幾度plt.legend(patches,labels, loc=&quot;best&quot;)#標示圖表內容plt.axis(&#x27;equal&#x27;)#plt.axis除了可以設定x和y軸也可以設定其他樣式，ex： equal可以讓x和y軸的單位一樣。plt.tight_layout()#tight_layout() 方法會自動保持子圖之間的正確間距plt.show() 調整特定塊向外移動(explode) 123456789101112131415161718#繪製圓餅圖#%matplotlib inlineimport matplotlib.pyplot as plt# ref: https://matplotlib.org/examples/pie_and_polar_charts/pie_demo_features.html# Pie chart, where the slices will be ordered and plotted counter-clockwise:labels = &#x27;Frogs&#x27;, &#x27;Hogs&#x27;, &#x27;Dogs&#x27;, &#x27;Logs&#x27;#用來標示圖表sizes = [15, 30, 45, 10]#指定每一塊所占比例explode = (0, 0.1, 0, 0) # only &quot;explode&quot; the 2nd slice (i.e. &#x27;Hogs&#x27;) 向外位移指定的塊，同時指定位移的量&#x27;&#x27;&#x27;fig1, ax1 = plt.subplots()ax1.pie(sizes, explode=explode, labels=labels, autopct=&#x27;%1.1f%%&#x27;, shadow=True, startangle=90)ax1.axis(&#x27;equal&#x27;) # Equal aspect ratio ensures that pie is drawn as a circle.&#x27;&#x27;&#x27;plt.pie(sizes, explode=explode, labels=labels, autopct=&#x27;%1.1f%%&#x27;, shadow=True, startangle=90) #autopct 標示每一塊佔的比例，保留到小數點後一位plt.axis(&#x27;equal&#x27;) ##plt.axis除了可以設定x和y軸也可以設定其他樣式，ex： equal可以讓x和y軸的單位一樣。plt.show() 變化版的圓餅圖，圓環圖!? 1234567891011121314151617181920212223242526#%matplotlib inlineimport matplotlib.pyplot as plt# Pie chartlabels = [&#x27;Frogs&#x27;, &#x27;Hogs&#x27;, &#x27;Dogs&#x27;, &#x27;Logs&#x27;]#用來標示圖表sizes = [15, 30, 45, 10]#指定每一塊所占比例#colorscolors = [&#x27;#ff9999&#x27;,&#x27;#66b3ff&#x27;,&#x27;#99ff99&#x27;,&#x27;#ffcc99&#x27;]#指定每一塊的顏色#explsionexplode = (0.05,0.05,0.05,0.05)#pcdistance設定數字離圓心的距離plt.pie(sizes, colors = colors, labels=labels, autopct=&#x27;%1.1f%%&#x27;, startangle=90, pctdistance=0.85, explode = explode)#draw circlecentre_circle = plt.Circle((0,0),0.70,fc=&#x27;white&#x27;)#fc設定圓形的顏色 0.70是透明度fig = plt.gcf() #get current figure# Matplotlib.axes.Axes.add_artist() 在坐標軸上添加新的圖#使用 add_artist 方法在軸上新增 circle，因為 circle 是 Artist 的子類fig.gca().add_artist(centre_circle)#gca()方法圖形模塊用於獲取當前軸# Equal aspect ratio ensures that pie is drawn as a circleplt.axis(&#x27;equal&#x27;) plt.tight_layout()plt.show()","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"NLP自然語言處理","slug":"NLP自然語言處理","permalink":"https://qi-xiang.github.io/tags/NLP%E8%87%AA%E7%84%B6%E8%AA%9E%E8%A8%80%E8%99%95%E7%90%86/"}]},{"title":"原子習慣 書摘(1)","slug":"atomhabit-1","date":"2021-10-28T09:29:19.000Z","updated":"2022-03-08T15:34:21.291Z","comments":true,"path":"2021/10/28/atomhabit-1/","link":"","permalink":"https://qi-xiang.github.io/2021/10/28/atomhabit-1/","excerpt":"","text":"¶第一章 原子習慣的驚人力量 ¶複利效應，讓小習慣造就大不同 人們很容易高估一個決定性瞬間的重要性，卻也容易低估每天都做些小改善的價值。 短期來看，每天百分之一的改善並不值得特別注意，但從長遠來看，意義可能非常大。假設每天都進步百分之一，持續一年後，你會進步37倍之多，若每天都退步百分之一，持續一年後，你會退步到趨近於0。 複利效應的驚人威力，讓起初看似不起眼的小勝利或小失敗，經長期累積造就出巨大差異。 好的習慣在執行的過程中，如果只挑其中一天來看，效果可能不是那麼明顯，但在長期的&quot;複利效應&quot;作用下，幾年之後回頭看，好習慣的價值與壞習慣的代價變得極為明顯。 好習慣帶來的改變通常是緩慢的，也因此讓惡習有悄悄生根的機會。 假設一個人正在減肥，他打算透過規律運動和正常飲食來達成目的，但經過速食店時，心想今天吃一餐垃圾食物，體重計上的數字也不會有任何變化吧?之後，他以此為藉口合理化自己錯誤的決策。 造就成功的，是日常習慣，而不是千載難逢的轉變。 重要的不是你現在有多成功或多失敗，而是你是否處在對的軌道上。百萬富翁如果每個月都入不敷出，最後就不會有好結果。反之，即便你現在窮困潦倒，但每個月都想方設法一點錢，那你就在通往財富自由的路上。 好習慣讓時間成為你的盟友，壞習慣讓時間與你為敵。 ¶建立持久的習慣為何這麼難? 在跨越一個關鍵門檻前，習慣往往看起來沒什麼影響，在追尋目標的前期或中期，常常出現&quot;失望之谷&quot;，你期待有限性進展，但在前幾天、幾周或幾個月，效果都很不顯著，令人感到挫折。 然而，這正是複利過程中的標誌，強大的成果總是姍姍來遲。 這也是好的習慣難以維持的原因，在短時間內難以看到有形的改變，就容易產生放棄的念頭。 好的習慣習慣在短時間內會進入一段停滯期，而你每天做的工並沒有浪費，只是被儲存起來，作為突破停滯期的能量。當你突破停滯期，大家會說那是一夕成功，但只有你知道，正是因為很久以前持續做的事，讓今日的躍進成為可能。 石匠敲打石頭，可能敲打了一百下，石頭上連條裂縫都沒有，但就在第一百零一下，石頭斷裂成兩半，把石頭劈成兩半的不是最後那一下，而是先前的每一次敲擊。 ¶別管目標，專注於系統就好 主流觀點認為，若要得到人生中想要的事物，最好的方法就是設定可行的確切目標。 但成果與設定的目標著實沒有太大的關係，反倒與所遵循的系統息息相關。 系統與目標的差異在於，目標是你想要達到的成果，系統是讓你達到成果的過程。 那如果徹底無視目標，只關注在系統，還能成功嗎? 答案是肯定的。 以運動比賽為例，把分數當作是目標，所以整場盯著記分板，這未免太荒謬了，真正能帶來勝利的是每天都進步一點，分數會顧好它自己。 然而，目標真的完全沒用嗎? 當然不是，目標有助於確立方向，但系統是進步的最佳解答。 ¶贏家跟輸家擁有相同目標 目標設定受到嚴重的生存者偏差影響，我們往往都聚焦在最終獲得勝利的人身上，而自動忽略擁有相同目標卻失敗的那一群人，忘記重點不在目標而在系統。 儘管目標相同，系統卻未必，也就是追求目標過程的不同，造就截然不同的結果。 ¶目標達成不過是短暫的改變 假設你的房間很亂，你設定了清理這個目標，之後也達成目標，得到乾淨的房間。 但這個目標的達成只能暫時改變你的生活，因為導致你房間變亂的系統並沒有被改變。從結果面著手，只能暫時解決問題，想要永久改善，就必須從系統面下手。 ¶目標限制了你的快樂 目標創造了一種&quot;非A即B&quot;的衝突，若沒有成功達到目標，就是失敗而令人失望，把自己框限在狹隘的快樂裡。 系統優先的心態提供了解藥，當你愛上過程而非產物，只要系統有在運作，你隨時都能感到滿足。 ¶目標與長期進步互相矛盾 目標取向的心態可能造成&quot;溜溜球效應&quot;。跑者持續努力數月，但衝過終點線之後，就停止訓練了。比賽結束，鼓勵亦隨之消失。 當你的一切努力都聚焦在一個特定目標，達成目標後。又有什麼能推動你繼續前進? 也因為這樣，很多人會在達成目標後，重新撿起放下的壞習慣。 重點不在任何單一成就，而在持續不斷改善的循環。Progress(進步)的必要條件是對Process(過程)的投入。 ¶原子習慣的系統 決定你成功或失敗的，不是你的目標，而是你的系統。 原子習慣指的是微小的改變，但並不是任何微小的習慣都算是原子習慣。 原子習慣是一個更大系統的一部分，如同原子是分子的組成單元，原子是建構非凡成果的原件。習慣就像人生的原子，每一個習慣都是造就你整體增長的基本元件。 習慣雖小，力量無窮，這便是&quot;原子習慣&quot;一詞的真義。","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"原子習慣","slug":"原子習慣","permalink":"https://qi-xiang.github.io/tags/%E5%8E%9F%E5%AD%90%E7%BF%92%E6%85%A3/"}]},{"title":"李永樂老師講比特幣(2)-重點整理","slug":"blockchainyt2","date":"2021-10-25T17:57:39.000Z","updated":"2022-03-08T15:30:59.229Z","comments":true,"path":"2021/10/26/blockchainyt2/","link":"","permalink":"https://qi-xiang.github.io/2021/10/26/blockchainyt2/","excerpt":"","text":"比特幣是一種’‘電子記帳系統’'，所有交易紀錄皆為公開且匿名 如何保證交易紀錄的真實性 身分驗證 傳統: 人臉辨識、簽名、指紋 電子系統: 電子簽名 電子簽名(數位簽章) 比特幣用戶註冊時，系統會生成一&quot;隨機數&quot;，透過隨機數會產生&quot;私鑰&quot;(私有)字串，私鑰字串又可產生&quot;公鑰&quot;(公開)字串，公鑰又可產生&quot;地址&quot;(公開) 公鑰無法反算私鑰 自己轉出比特幣: 公鑰+地址 他人轉入比特幣: 地址 私鑰可以對字串進行加密 公鑰可以解密私鑰加密的字串 以上稱為非對稱加密(ex.RSA是非對稱加密的一種) 例子: 假設A給B 10個比特幣 1.A先寫一條紀錄(A給10比特幣到B)，之後進行Hash運算，再用私鑰進行加密，產生一組密碼 2.將交易訊息、公鑰、密碼對每一節點進行&quot;廣播&quot;，節點會去運用紀錄去做Hash運算，與運用公鑰解密後的密碼進行比對，驗證其交易的真偽 3.現假設A只有10個比特幣，卻同時給兩人10比特幣(double spending problem) 如何進行帳戶餘額檢查 A廣播出交易訊息後，區塊鏈中的節點會往前檢查每一區塊中A的交易紀錄(追溯)，確認A的餘額 防止雙重支付 A同時廣播兩條消息 給B 10比特幣 給C 10比特幣 每一個節點會去算A的餘額是否還夠，如果剛好有10比特幣的話，一些節點收到第一條消息就會拒絕第二條(因為餘額不足)，反之亦然。 第1(或2)的消息會被放到區塊中(未被確認)，當有一個節點解出隨機數，新的區塊會被鏈結到區塊鏈中，其餘節點則會放棄打包區塊的機會，自動承認第一個產生的區塊，此時第1(或2)個消息被確認，另一消息則不會被確認(此時A餘額已經確定是0) 只有當區塊鏈接到區塊鏈上，交易才真正完成 防止竄改 最長鏈原則 當有兩個礦工同時找到一個新區塊(產生分支，上、下)，當上面區塊的下一個區塊先被找到，此時上面的鏈結就比下面的長，所有人會跟著往上面走，下方區塊則打包失敗 若有人想要修改自己的交易紀錄，就要從該筆交易紀錄區塊開啟新分支(往另一方向走)，但根據最長鏈規則，這筆紀錄不會被其他節點承認 ¶REF: 比特幣交易如何防偽？私鑰公鑰地址啥意思？李永樂老師講比特幣（2）","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"區塊鏈","slug":"區塊鏈","permalink":"https://qi-xiang.github.io/tags/%E5%8D%80%E5%A1%8A%E9%8F%88/"}]},{"title":"李永樂老師講比特幣(1)-重點整理","slug":"blockchainyt1","date":"2021-10-25T17:57:33.000Z","updated":"2022-03-08T15:30:51.785Z","comments":true,"path":"2021/10/26/blockchainyt1/","link":"","permalink":"https://qi-xiang.github.io/2021/10/26/blockchainyt1/","excerpt":"","text":"一、 比特幣是一種基於&quot;密碼學&quot;的電子貨幣 2008年11月1日 中本聰-&gt;(白皮書-比特幣:一種點對點的交易系統) 去中心化的電子記帳系統-&gt;帳本皆為公開 假設: 現有4人，A、B、C、D A支付B:10比特幣、 B支付C:5比特幣、 C支付D:2比特幣 ，每筆交易廣播給其他3人，而這些交易紀錄會形成一個&quot;區塊&quot;，再將其鏈結到舊區塊上，形成&quot;區塊鏈&quot;。 問題 1.帳單以誰為準?(會因為延遲造成每人的資訊不對稱) 2.為何需要記帳? 3.如何防偽? 為何需要記帳? 記帳有獎勵 手續費收益 打包交易紀錄獎勵(只能一個人) 中本聰設計為10分鐘打一個包，每打一個包獎勵50比特幣，每4年遞減，故比特幣有總量限制，約只有2100萬個 帳單以誰為準? 只能一個人打包 中本聰-&gt;工作量證明(PoW) 每一參與打包的用戶都必須解數學題，做出來後，就有打包的權利，並獲得手續費、打包獎勵-&gt;挖到礦 二、 挖礦原理 Hash Function: SHA256(256位的二進位數) 特色: 正向算容易，反向算困難 具體原理 每一區塊並不只有交易訊息，還可分成區塊的頭部 數學題的產生 字符串: 前區塊的頭部+現有帳單信息+時間+…+隨機數 對字符串作2次Hash Function(SHA256)，產生2進位數 規定前幾位數必須是0(關係到運算難度) 算出的Hash數做為新區塊的頭部完成打包，並與舊區塊鏈結-&gt;挖礦Fin. 如何算出前幾位是0? 透過改變隨機數(其餘都是定值) 比賽誰的計算能力強 計算難度設置 特過操控前n位0-&gt;保證每10分鐘打包一個區塊 ¶REF: 比特幣和區塊鏈到底是啥？礦機挖礦咋回事？李永樂老師講比特幣(1)","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"區塊鏈","slug":"區塊鏈","permalink":"https://qi-xiang.github.io/tags/%E5%8D%80%E5%A1%8A%E9%8F%88/"}]},{"title":"財報狗教你挖好股 [1.獲利性分析-股東權益報酬率]","slug":"frdog1-3","date":"2021-10-25T17:49:36.000Z","updated":"2022-03-08T15:34:43.489Z","comments":true,"path":"2021/10/26/frdog1-3/","link":"","permalink":"https://qi-xiang.github.io/2021/10/26/frdog1-3/","excerpt":"","text":"¶股東權益報酬率 股東權益報酬率 = 淨利 / 股東權益(自有資金) * 100% 股東拿錢出來投資一家公司，這筆錢稱為股東權益 ¶4種ROE型態，顯示公司以自有資金賺錢的能力 觀察ROE的高低與走勢，可以看出公司所處產業的特性，有利判斷投資方向 觀察ROE的時間越長越好，最好超過兩個景氣循環的時間，也就是6~8年的時間 1.平穩型-&gt; 受景氣波動影響小，多為民生必需產業 2.大幅波動型(不宜長期投資) -&gt; 受景氣影響大，多為景氣循環股 3.趨勢向下型 -&gt; 夕陽產業或公司競爭力衰退 4.趨勢向上型 -&gt; 火紅產業或公司具有競爭實力 ¶利用&quot;杜邦分析&quot;看出公司ROE變化玄機 杜邦分析法將ROE拆成3項財務數字: 1.淨利率 2.總資產周轉率 3.權益乘數 淨利率: 代表公司獲利能力 = 淨利 / 營收 總資產周轉率: 公司利用資產創造營收的效率 = 營收 / 總資產 權益乘數: 公司使用的財務槓桿大小 = 總資產 / 股東權益 (負債越多就越大) ROE = 淨利率 X 總資產周轉率 X 權益乘數 ¶淨利率推動ROE上升，才是名副其實績優股 若公司的ROE成長單純來自&quot;總資產周轉率&quot;的提升，代表好業績來自短期營收的衝刺，甚至可能有削價競爭的情況 ¶ROE提高但淨利率下滑，營收反轉時股價恐跌 若ROE提高淨利反而下滑，則須注意是來自總資產周轉率或權益乘數的成長 總資產周轉率提高可能來自削價競爭 權益乘數提高可能來自公司的債務 月營收開始下跌時，此類公司股價可能大幅向下修正 ¶淨利率衰退連累ROE下滑，應避免長期投資 ROE下滑的主因為淨利率的公司，不宜作為長期投資標的 ¶經營者資金操作轉趨保守，亦會拉低ROE 在資金操作方面降低負債，代表經營者心態趨向保守，公司ROE要重上軌道，經營心態是關鍵 在眾多獲利指標中，ROE絕對是最重要的一個。投資者在研究一家新公司時，請謹記先看公司長期的ROE走勢；走勢平穩是最好的，若出現轉折，可通過杜邦分析了解其中原因，說不定能發現不錯的投資機會! ¶Written By QI-XIANG 2021/03/30","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"財報狗挖好股精華","slug":"財報狗挖好股精華","permalink":"https://qi-xiang.github.io/tags/%E8%B2%A1%E5%A0%B1%E7%8B%97%E6%8C%96%E5%A5%BD%E8%82%A1%E7%B2%BE%E8%8F%AF/"}]},{"title":"財報狗教你挖好股 [1.獲利性分析-營運周轉天數]","slug":"frdog1-2","date":"2021-10-25T17:48:11.000Z","updated":"2022-03-08T15:34:40.295Z","comments":true,"path":"2021/10/26/frdog1-2/","link":"","permalink":"https://qi-xiang.github.io/2021/10/26/frdog1-2/","excerpt":"","text":"¶營運周轉天數-產品賣得快，收錢也要快 經營公司最大的風險有2個，1個是&quot;貨賣不出去&quot;，另1個則是&quot;帳收不回來&quot;。貨賣不出去，會造成公司存貨的跌價損失；帳收不回來，公司的獲利會縮水，嚴重時甚至會進入虧損。 公司賺取利潤的過程，稱為&quot;商業循環&quot;，一般可分為4個步驟，依序為進貨、製造、銷貨、收款，同時又可分為前後兩部分(存貨循環、應收帳款循環) ¶存貨循環 存貨進到公司，經過製造後並銷售出去的過程，所花費的時間稱為&quot;存貨周轉天數&quot; 存貨周轉率 = 營業成本 / 平均存貨 * 100% -&gt; 1年內可以賣幾次平均存貨量 存貨周轉率反映公司經營效率 存貨周轉天數 = 365天 / 存貨周轉率 -&gt; 需要幾天賣完平均存貨量 存貨周轉的天數要低於多少才算好?要看產品的生命週期而定。 比較不同公司時，要注意是不是屬於同一產業 ¶存貨週轉天數搭配營收走勢觀察，可看出產業供需狀況 總共有四種不同的狀況 1.公司處於擴張期(存貨週轉天數上升、營收上升) 注意: 月營收開始下滑，則為營運衰退的警訊 2.產品供不應求(存貨週轉天數下降、營收上升) 注意: 存貨周轉天數反轉向上，營收將有下滑風險 3.產品供過於求(存貨週轉天數上升、營收下降) 注意: 存貨周轉天數反轉向下，則營收有望重回成長 4.公司處於收縮期(存貨週轉天數下降、營收下降) 注意: 存貨週轉天數反轉上升，營收可能有所回升 ¶應收帳款循環 產品銷售給顧客直到收款，所花費的時間稱為&quot;應收帳款周轉天數&quot; 應收帳款周轉率 = 年營收 / 平均應收帳款 * 100% -&gt; 1年內可以收回幾次應收帳款 應收帳款周轉天數 = 365天 / 應收帳款周轉率 -&gt; 平均幾天能收回帳款 應收帳款周轉天數反映公司帳務管理能力 應收帳款周轉天數的大小與&quot;公司相對客戶的規模大小&quot;有關，同產業進行比較，則可看出企業在產業中的地位 應收帳款周轉天數持續上升，盈餘品質恐惡化(淪於&quot;紙上富貴&quot;，公司認列的營收，並沒有真正進入公司)，但需長期觀察判斷 ¶存貨周轉天數+應收帳款周轉天數 = 營運周轉天數 ¶Written By QI-XIANG 2021/03/23","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"財報狗挖好股精華","slug":"財報狗挖好股精華","permalink":"https://qi-xiang.github.io/tags/%E8%B2%A1%E5%A0%B1%E7%8B%97%E6%8C%96%E5%A5%BD%E8%82%A1%E7%B2%BE%E8%8F%AF/"}]},{"title":"財報狗教你挖好股 [1.獲利性分析-利潤比率]","slug":"frdog1-1","date":"2021-10-25T17:35:54.000Z","updated":"2022-03-08T15:34:36.858Z","comments":true,"path":"2021/10/26/frdog1-1/","link":"","permalink":"https://qi-xiang.github.io/2021/10/26/frdog1-1/","excerpt":"","text":"¶利潤比率-高營收不代表賺得多 利潤才是做生意賺不賺錢的關鍵。衡量利潤時，我們會利用&quot;利潤比率&quot;，也就是&quot;毛利率&quot;、“營業利益率”、&quot;淨利率&quot;這3個數字 ¶毛利率-&gt;可看出公司產品本身的競爭力 “毛利&quot;是營業收入(營收)減去營業成本後的金額；毛利佔公司營收的比重就是&quot;毛利率” 營業成本是與產品直接相關的支出，像是原料成本、設備折舊成本、工廠員工薪資成本等。 ¶製造業有高毛利率，代表產品越有競爭優勢!! 降低成本提高毛利率，最好能具持續性 舉台灣電子產業為例，透過提高售價來拉高毛利率是不可行的，唯有採用降低成本的方式。 降低成本的方法很多，主要可從以下兩種角度觀察 1.改善產品製程可讓產品競爭力與股價雙升 2.原料價格波動造成毛利率提升，不代表產品競爭力提高 ¶營業利益率-&gt;可看出公司本業的經營狀況 營收扣除營業成本後是毛利，毛利再扣除&quot;營業費用&quot;就是&quot;營業利益&quot; 營業費用是與產品間接相關的支出，主要可分為以下三類 管理費用 銷售費用 研發費用 評估腦力密集型產業，先從營利率下手。對於軟體公司、IC設計這些主要以營業費用為主的產業，從營利率走勢下手，比較能掌握公司營運狀況。 有些不肖公司會將部分成本轉移到營業費用上，造成高毛利率，故實際在評估公司本業獲利狀況時，最好仍以公司的營利率為準。 ¶淨利率-&gt;呈現公司最終的獲利情形 公司除了本業經營外，還有一些業外損益與稅額。(ex.所得稅、投資) 一家公司最終淨賺的獲利，必須將營業利益減去&quot;業外損失&quot;(或加上&quot;業外獲利&quot;)與&quot;稅額&quot;，最後算出來的就是&quot;淨利&quot;，&quot;淨利率&quot;就是淨利佔營收的比重，數值越高表示公司獲利能力越強。 ¶業外帶來的淨利飆升，需判斷是否是曇花一現 業外損益項目眾多，需判斷其屬於一次性或具有長期性 例如: 保險理賠、匯兌損益、處分資產損益、短期投資損益都是屬於一次性業外損益 觀察到一間公司營利率小於淨利率時，我們可以知道公司主要獲利來源為業外收入，此時應小心評估這個業外收益的本質是什麼? 一次性或長期性? ¶長期投資標的，淨利率不宜低於10% 淨利率反映出公司最終獲利狀況，最好不要低於10%，低於10%不但代表公司獲利能力差，也代表獲利變動風險很大，股價容易隨之崩跌。當觀察到媒體報導哪間公司營收再創新高時，宜留意淨利率是否也有亮眼表現。 ¶Written By QI-XIANG 2021/03/19","categories":[{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"財報狗挖好股精華","slug":"財報狗挖好股精華","permalink":"https://qi-xiang.github.io/tags/%E8%B2%A1%E5%A0%B1%E7%8B%97%E6%8C%96%E5%A5%BD%E8%82%A1%E7%B2%BE%E8%8F%AF/"}]},{"title":"2021/10/25 NLP Matplotlib(範例1)","slug":"nlp20211025","date":"2021-10-25T15:04:45.000Z","updated":"2022-03-08T15:29:11.080Z","comments":true,"path":"2021/10/25/nlp20211025/","link":"","permalink":"https://qi-xiang.github.io/2021/10/25/nlp20211025/","excerpt":"","text":"¶Axes Axes 圖框 程式語言-看盤版面(上)-圖框教學 123456789101112131415161718192021222324252627282930313233343536373839#產生圖中圖的效果#%matplotlib inline #此行是為了將圖表呈現在jupyter notebook中#import 需要的套件import matplotlibimport numpy as npimport matplotlib.pyplot as plt#開始繪圖fig = plt.figure()#指定x,y軸座標x = [1, 2, 3, 4, 5, 6, 7]y = [1, 3, 4, 2, 5, 8, 6]# below are all percentage 下面的數字全部都是以百分比為單位#使用add_axes繪製圖框，圖框的位置是自己定義的，兩個圖塊可以重疊#參數：add_axes( x初始座標, y初始座標, 寬, 高 )left, bottom, width, height = 0.1, 0.1, 0.8, 0.8ax1 = fig.add_axes([left, bottom, width, height]) # main axesax1.plot(x, y, &#x27;r&#x27;) #將線段以紅色繪出ax1.set_xlabel(&#x27;x&#x27;) #賦予坐標軸名稱ax1.set_ylabel(&#x27;y&#x27;)ax1.set_title(&#x27;title&#x27;) #圖表的標題ax2 = fig.add_axes([0.2, 0.6, 0.25, 0.25]) # inside axesax2.plot(y, x, &#x27;b&#x27;) #同上ax2.set_xlabel(&#x27;x&#x27;)ax2.set_ylabel(&#x27;y&#x27;)ax2.set_title(&#x27;title inside 1&#x27;)# different method to add axes 另一種新增圖框的方法####################################plt.axes([0.05, 0.2, 0.8, 0.25])plt.plot(y[::-1], x, &#x27;g&#x27;) #同上plt.xlabel(&#x27;x&#x27;)plt.ylabel(&#x27;y&#x27;)plt.title(&#x27;title inside 2&#x27;)plt.show()#plt.savefig(&quot;./axes_plot.png&quot;,dpi=72) ¶x/y limit xlim、ylim 限制作畫的座標軸範圍 123456789101112131415161718192021222324# x/y limit 限制 x,y 畫的範圍%matplotlib inline#引入需要的套件import matplotlibimport numpy as npimport matplotlib.pyplot as plt#在 -pi~pi 之間產生256個均分點(等差數列)，包含 stop(endpoint=True)X = np.linspace(-np.pi, np.pi, 256, endpoint=True) C,S = np.cos(X), np.sin(X) #換算成 sin、cos 值# x limits#plt.xlim(0, 3) #在 x 軸只畫 0~3 的範圍plt.xlim(X.min()*1.1, X.max()*1.1) #乘上 1.1 是為了完整呈現圖表預留空間# y limitsplt.ylim(C.min()*1.1, C.max()*1.1) #如果不乘上 1.1 則圖表會顯得比較擠plt.plot(X,C) #繪製線段plt.plot(X,S, color=&#x27;red&#x27;, linewidth=10) #linewidth 調整線條粗細 plt.show() #顯示圖表#plt.savefig(&quot;./limit_plot1.png&quot;,dpi=72) ¶x/y tick xticks、yticks 用來設定圖表座標軸刻度 xticks的詳細參數說明 123456789101112131415161718192021222324252627#%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltX = np.linspace(-np.pi, np.pi, 256, endpoint=True) #跟之前一樣產生256個數字的等差數列C,S = np.cos(X), np.sin(X) #換算sin、cos值# x limitsplt.xlim(-4.0,4.0) #設定 x 座標的範圍# x ticks#在 -4~4 間，產生9個均分點，包含 stop，並以此作為 x 軸上的刻度plt.xticks(np.linspace(-4,4,9,endpoint=True)) # y limitsplt.ylim(-1.0,1.0) #在不調整的情況下，會有部分圖形消失# y ticks#同於 x 軸plt.yticks(np.linspace(-1,1,5,endpoint=True)) plt.plot(X,C) #繪製線段plt.plot(X,S, color=&#x27;red&#x27;, linewidth=10)plt.show() #顯示圖表#plt.savefig(&quot;./ticks_plot1.png&quot;,dpi=72) 使用 LaTex Format 作為 ticks label Latex各种命令、符号、公式、数学符号、排版 123456789101112131415161718192021#%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltX = np.linspace(-np.pi, np.pi, 256, endpoint=True)C,S = np.cos(X), np.sin(X)# latex format 數學格式轉換#下面將刻度以 latex 方式呈現plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r&#x27;$-\\pi$&#x27;, r&#x27;$-\\pi/2$&#x27;, r&#x27;$0$&#x27;, r&#x27;$+\\pi/2$&#x27;, r&#x27;$+\\pi$&#x27;]) #第一個參數是實際的數值、第二個參數作為label使用plt.yticks([-1, 0, +1], [r&#x27;$-1$&#x27;, r&#x27;$0$&#x27;, r&#x27;$+1$&#x27;]) #前面加上 r 表示是原始字串plt.plot(X,C)plt.plot(X,S, color=&#x27;red&#x27;, linewidth=10)plt.show() #顯示圖表#plt.savefig(&quot;./ticks_plot2.png&quot;,dpi=72) ¶Coordinate axis 移動x,y座標軸 ax.spines——matplotlib坐标轴设置 Matplotlib入门-3-plt.gca( )挪动坐标轴 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltx = np.linspace(-3, 3, 50) #在-3到3間產生等差數列(數量為50)y1 = 2*x + 1y2 = x**2plt.figure() #開始繪圖plt.plot(x, y2)# plot the second curve in this figure with certain parametersplt.plot(x, y1, color=&#x27;red&#x27;, linewidth=1.0, linestyle=&#x27;--&#x27;) #調整線段粗細以及樣式# set x limitsplt.xlim((-1, 2)) #設定座標軸範圍限制plt.ylim((-2, 3))# set new ticksnew_ticks = np.linspace(-1, 2, 5) #設定圖表的刻度plt.xticks(new_ticks)# set tick labelsplt.yticks([-2, -1.8, -1, 1.22, 3], [&#x27;$really\\ bad$&#x27;, &#x27;$bad$&#x27;, &#x27;$normal$&#x27;, &#x27;$good$&#x27;, &#x27;$really\\ good$&#x27;])# to use &#x27;$ $&#x27; for math text and nice looking, e.g. &#x27;$\\pi$&#x27;# gca = &#x27;get current axis&#x27;ax = plt.gca() #獲取圖像的軸，總共有四個軸top、bottom、left和right#不需要right、top的座標軸，故將其顏色設為none(透明)#ax.spines[&#x27;right&#x27;]取得右方的軸，以此類推ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;) ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)ax.xaxis.set_ticks_position(&#x27;bottom&#x27;) #設定x軸方向刻度的位置# ACCEPTS: [ &#x27;top&#x27; | &#x27;bottom&#x27; | &#x27;both&#x27; | &#x27;default&#x27; | &#x27;none&#x27; ]ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0)) #&#x27;data&#x27;表示按數值挪動，其後數字代表挪動到Y軸的刻度值# the 1st is in &#x27;outward&#x27; | &#x27;axes&#x27; | &#x27;data&#x27;# axes: percentage of y axis# data: depend on y dataax.yaxis.set_ticks_position(&#x27;left&#x27;) #同x軸刻度# ACCEPTS: [ &#x27;left&#x27; | &#x27;right&#x27; | &#x27;both&#x27; | &#x27;default&#x27; | &#x27;none&#x27; ]ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;,0)) #同上plt.show() #繪製出圖表#plt.savefig(&quot;./Coordinate_axis.png&quot;,dpi=72) ¶Annotation 用於寫註解 plt.scatter()函数解析（最清晰的解释） matplotlib.pyplot.annotate matplotlib.pyplot.text 123456789101112131415161718192021222324252627282930313233343536373839#%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltx = np.linspace(-3, 3, 50)y = 2*x + 1plt.figure(num=1, figsize=(8, 5),)plt.plot(x, y,)ax = plt.gca()ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))ax.yaxis.set_ticks_position(&#x27;left&#x27;)ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0))x0 = 1y0 = 2*x0 + 1plt.plot([x0, x0,], [0, y0,], &#x27;k--&#x27;, linewidth=2.5) #linestyle=&#x27;k--&#x27;plt.scatter([x0, ], [y0, ], s=50, color=&#x27;b&#x27;) #s代表的是點的大小，scatter()用來畫散佈圖# method 1:######################用於寫註解 詳細參數說明: https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.annotate.htmlplt.annotate(r&#x27;$2x+1=%s$&#x27; % y0, xy=(x0, y0), xycoords=&#x27;data&#x27;, xytext=(+30, -30), textcoords=&#x27;offset points&#x27;, fontsize=16, arrowprops=dict(arrowstyle=&#x27;-&gt;&#x27;, connectionstyle=&quot;arc3,rad=.2&quot;))# method 2:#########################用於在圖表中加入文字 詳細參數說明: https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.text.htmlplt.text(-3.7, 3, r&#x27;$This\\ is\\ the\\ some\\ text. \\mu\\ \\sigma_i\\ \\alpha_t$&#x27;, fontdict=&#123;&#x27;size&#x27;: 16, &#x27;color&#x27;: &#x27;r&#x27;&#125;)plt.show() #繪製出圖表#plt.savefig(&quot;./Annotation.png&quot;,dpi=72) ¶Line Style 調整線的樣式 (ex. 虛線) matplotlib.pyplot.plot (裡面有關於marker、linestyle的詳細說明) 1234567891011121314151617#%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltcolor = &#x27;cornflowerblue&#x27;X = np.linspace(-np.pi, np.pi, 256, endpoint=True) #等差數列C = np.cos(X) #計算 cos 值linestyles = [&#x27;-&#x27;, &#x27;--&#x27;, &#x27;-.&#x27;, &#x27;:&#x27;] #不同的線段樣式for x, linestyle in enumerate(linestyles): #enumerate產生索引序列 plt.plot(X, C+x, linestyle=linestyle, color=color, linewidth=3) plt.show() #繪製圖表#plt.savefig(&quot;./linestyle.png&quot;,dpi=72) ¶Marker 在線段上實際標出點，參考Line Style的補充資料 1234567891011121314151617#%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltcolor = &#x27;cornflowerblue&#x27;X = np.linspace(-np.pi, np.pi, 12, endpoint=True)C = np.cos(X)markers = [&#x27;o&#x27;, &#x27;v&#x27;, &#x27;^&#x27;, &#x27;&lt;&#x27;] #標出點的樣式for x, linestyle in enumerate(markers): #enumerate產生索引序列 plt.plot(X, C+x, marker=markers[x], color=color, linewidth=1) plt.show() #繪製圖表#plt.savefig(&quot;./marker.png&quot;,dpi=72) 不實際畫出線，而是描出點 1234567891011121314#%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltx = [1, 2, 3, 4]y = [1, 4, 9, 16]plt.plot(x, y,&#x27;ro&#x27;) #參數ro中r為red，o代表使用圓形標記繪製而不是用線繪製plt.ylabel(&#x27;y label&#x27;) #更改坐標軸標題plt.xlabel(&#x27;x label&#x27;)plt.show() #繪製圖表#plt.savefig(&quot;./marker2.png&quot;,dpi=72) ¶Legend 區分出線段 matplotlib.pyplot.legend 1234567891011121314151617181920212223#%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltX = np.linspace(-np.pi, np.pi, 256, endpoint=True)C,S = np.cos(X), np.sin(X)plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r&#x27;$-\\pi$&#x27;, r&#x27;$-\\pi/2$&#x27;, r&#x27;$0$&#x27;, r&#x27;$+\\pi/2$&#x27;, r&#x27;$+\\pi$&#x27;])plt.yticks([-1, 0, +1], [r&#x27;$-1$&#x27;, r&#x27;$0$&#x27;, r&#x27;$+1$&#x27;]) # latex formatplt.plot(X,C, label=&#x27;cosine&#x27;) #label標記線段名稱plt.plot(X,S, color=&#x27;red&#x27;, linewidth=10, label=&#x27;sine&#x27;)#plt.legend(loc=&#x27;upper left&#x27;, frameon=True)# frameon 決定是否有外框、設定 loc=&#x27;best&#x27;，python會自動找到有空位的地方放legendplt.legend(loc=&#x27;best&#x27;, frameon=False) plt.show() #繪製圖表#plt.savefig(&quot;./legend.png&quot;,dpi=72) ¶Figure 下次內容紀錄的是從bar chart開始的部分。","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"NLP自然語言處理","slug":"NLP自然語言處理","permalink":"https://qi-xiang.github.io/tags/NLP%E8%87%AA%E7%84%B6%E8%AA%9E%E8%A8%80%E8%99%95%E7%90%86/"}]},{"title":"2021/10/18 NLP Matplotlib(範例)","slug":"nlp20211018","date":"2021-10-24T16:02:46.000Z","updated":"2022-03-08T15:29:03.185Z","comments":true,"path":"2021/10/25/nlp20211018/","link":"","permalink":"https://qi-xiang.github.io/2021/10/25/nlp20211018/","excerpt":"","text":"¶Simple plot 12345678910111213141516171819%matplotlib inline #此行目的是為了畫在jupyter notebook裡#import 需要的套件import numpy as npimport matplotlib.pyplot as plt#在 -pi 和 pi 間，以等差數列的方式取256個點，endpoint=True(包含stop)X = np.linspace(-np.pi, np.pi, 256, endpoint=True)#print(X)C,S = np.cos(X), np.sin(X) #分別計算cos、sin值plt.plot(X,C) #使用plt.plot()繪圖並帶入x,y座標plt.plot(X,S)plt.title(&#x27;this is title&#x27;) #設定圖表標題plt.ylabel(&#x27;y label&#x27;) #設定y軸名稱plt.xlabel(&#x27;x label&#x27;) #設定x軸名稱plt.grid() #顯示網格#plt.show() #匯出圖表plt.savefig(&quot;./simple_plot.png&quot;,dpi=72) #將圖表存成檔案；dpi是解析度 要特別注意，plt.savefig()之前不能有plt.show()，不然存到的會是空白圖。 numpy.linspace(等差數列): 此陣列以等差數列的形式產生，指定個數 ¶Figure 1234567891011121314151617181920%matplotlib inline #此行目的是為了畫在jupyter notebook裡#import必要套件import matplotlibimport numpy as npimport matplotlib.pyplot as plt#在 -pi 和 pi 間，以等差數列的方式取256個點，endpoint=True(包含stop)X = np.linspace(-np.pi, np.pi, 256, endpoint=True)C,S = np.cos(X), np.sin(X)#分別計算cos、sin值#要畫一張新的圖只要重新呼叫 plt.figure() 即可#以下分開繪製 cos、sin 的圖plt.figure()plt.plot(X,C) #使用plt.plot()繪圖並帶入x,y座標#重新繪製另一張圖plt.figure()plt.plot(X,S, color=&#x27;red&#x27;, linewidth=10) #將線段設為紅色，linewidth=10 用來調整線段寬度plt.show() #繪出兩個圖表 ¶Subplot 畫子圖，將原來的一張圖分成數個子圖 subplot函數需要使用幾個參數(row,col,# of plot) 1234567891011121314151617181920212223#%matplotlib inline #此行目的是為了畫在jupyter notebook裡#import必要套件import matplotlibimport numpy as npimport matplotlib.pyplot as pltplt.figure(figsize=(6, 4)) #開始繪圖，指定 figsize# plt.subplot(n_rows, n_cols, plot_num)plt.subplot(2, 2, 1) #繪製子圖 plt.subplot(row,col,number of plot) 第一張圖plt.plot([0, 1], [0, 1]) #繪製從(0,0)到(1,1)的點plt.subplot(2,2,2) #第二張圖plt.plot([1, 1], [0, 2]) #以此類推plt.subplot(2,2,3) #...plt.plot([2, 1], [3, 3])plt.subplot(2,2,4) #...plt.plot([4, 1], [1, 4])#tight_layout automatically adjusts subplot params so that the subplot(s) fits in to the figure area.plt.tight_layout() #用於自動調整子圖參數以提供指定的填充 1234567891011121314151617181920212223%matplotlib inlineimport matplotlibimport numpy as npimport matplotlib.pyplot as pltplt.figure(figsize=(6, 4))# plt.subplot(n_rows, n_cols, plot_num)plt.subplot(2, 1, 1)# figure splits into 2 rows, 1 col, plot to the 1st sub-figplt.plot([0, 1], [0, 1])plt.subplot(2,3,4)# figure splits into 2 rows, 3 col, plot to the 4th sub-figplt.plot([0, 1], [0, 2])plt.subplot(2,3,5)# figure splits into 2 rows, 3 col, plot to the 5th sub-figplt.plot([0, 1], [0, 3])plt.subplot(2,3,6)# figure splits into 2 rows, 3 col, plot to the 6th sub-figplt.plot([0, 1], [0, 4])plt.tight_layout() 要注意這個例題的圖表順序，因為第一張圖表佔據3個位置(1~3)，所以下面的圖表要以4、5、6來排列。 ¶補充資料: Matplotlib讓資料視覺化！ NumPy基礎介紹 subplot和subplots绘制子图 Python Matplotlib.pyplot.tight_layout()用法及代碼示例","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"NLP自然語言處理","slug":"NLP自然語言處理","permalink":"https://qi-xiang.github.io/tags/NLP%E8%87%AA%E7%84%B6%E8%AA%9E%E8%A8%80%E8%99%95%E7%90%86/"}]},{"title":"Hexo 官方教學","slug":"hello-world","date":"2021-10-21T10:28:26.490Z","updated":"2022-03-08T15:37:14.777Z","comments":true,"path":"2021/10/21/hello-world/","link":"","permalink":"https://qi-xiang.github.io/2021/10/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. ¶Quick Start ¶Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing ¶Run server 1$ hexo server More info: Server ¶Generate static files 1$ hexo generate More info: Generating ¶Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[]},{"title":"JS30 全攻略 第30天","slug":"ironman2021D30","date":"2021-09-30T07:46:50.000Z","updated":"2022-03-08T15:28:45.534Z","comments":true,"path":"2021/09/30/ironman2021D30/","link":"","permalink":"https://qi-xiang.github.io/2021/09/30/ironman2021D30/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 最後一天要實作的內容是&quot;網頁版打地鼠&quot;。 ¶解析程式碼 ¶HTML 部分 &lt;h1&gt;是頁面的標題，旁邊的&lt;span class=&quot;score&quot;&gt;是打地鼠遊戲的記分板。 &lt;button&gt;在滑鼠點擊時，會呼叫startGame()方法，開始打地鼠遊戲。 &lt;div class=&quot;game&quot;&gt;是打地鼠遊戲的主體，內部有&lt;dvi class=&quot;hole&quot;&gt;共計六個洞，每個洞(.hole)都有一隻初始被隱藏的地鼠(&lt;div class=&quot;mole&quot;&gt;)。 1234567891011121314151617181920212223&lt;h1&gt;Whack-a-mole! &lt;span class=&quot;score&quot;&gt;0&lt;/span&gt;&lt;/h1&gt;&lt;button onClick=&quot;startGame()&quot;&gt;Start!&lt;/button&gt;&lt;div class=&quot;game&quot;&gt; &lt;div class=&quot;hole hole1&quot;&gt; &lt;div class=&quot;mole&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hole hole2&quot;&gt; &lt;div class=&quot;mole&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hole hole3&quot;&gt; &lt;div class=&quot;mole&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hole hole4&quot;&gt; &lt;div class=&quot;mole&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hole hole5&quot;&gt; &lt;div class=&quot;mole&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hole hole6&quot;&gt; &lt;div class=&quot;mole&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; ¶CSS 部分 初始每一隻地鼠(.mole)都是採用絕對定位(position:absolute)，然後將top指定為100%，把地鼠(.mole)隱藏起來。 在遊戲過程中，我們會為地洞(.hole)添加.up這個 CSS class 選擇器，讓地鼠探頭出來給我們打 XD。 12345678910.mole &#123; /*上略...*/ position: absolute; top: 100%; /*下略...*/&#125;.hole.up .mole &#123; top: 0;&#125; ¶JS 部分 宣告常數holes取得所有的地洞(.hole)，資料型態是 NodeList。 宣告常數scoreBoard取得頁面中顯示的分數(.score)。 宣告常數mole取得所有的地鼠(.mole)，資料型態是 NodeList。 123const holes = document.querySelectorAll(&#x27;.hole&#x27;); //NodeListconst scoreBoard = document.querySelector(&#x27;.score&#x27;);const moles = document.querySelectorAll(&#x27;.mole&#x27;); 撰寫ranTime()幫我們決定地鼠出現的持續時間並給定參數min、max作為出現持續時間範圍的最小、最大值。 下面用Math.random()隨機產生一個介於0~1的數字，然後把它乘上(max-min)再加上min，最後用Math.round()四捨五入得到隨機的出現持續時間。 123function randTime(min,max)&#123; return Math.round(Math.random() * (max-min) + min);&#125; randomHole()幫我們隨機選擇地鼠出現的洞，為避免接連選到兩次一樣的洞，所以另外宣告變數lastHole，來幫我們記住上一次出現的洞。 在方法裡，首先要傳入所有洞穴(holes，NodeList)，接著一樣用Math.random()隨機產生0~1的數字並乘上holes的長度後，呼叫Math.floor()無條件捨去小數點，取得一個隨機的index放入常數idx中。 然後，宣告的常數hole就可以用這個idx，隨機取得holes中的一個洞穴。 為避免選到和上次一樣的洞穴，利用條件判斷hole是不是跟lastHole相同，如果相同就遞迴呼叫randomHole()，直至選到不同的洞為止。 在方法的最後，把這次的結果放到lastHole中，之後回傳被隨機選到的hole。 123456789101112let lastHole;function randomHole(holes)&#123; const idx = Math.floor(Math.random() * holes.length); const hole = holes[idx] if(hole === lastHole)&#123; console.log(&#x27;You got the same hole.&#x27;); return randomHole(holes); &#125; lastHole = hole; return hole;&#125; 宣告變數timeup作為遊戲是否已經結束的flag。 peep()是讓地鼠從洞穴探頭出來的關鍵!!! 在peep()的最一開始，宣告常數time並取得由randTime(200,1000)隨機產生的地鼠持續出現時間，接著宣告常數hole取得由randomHole(holes)隨機挑出的地洞。 隨機挑出的hole會被添加.up這個 class，目的是讓躲在洞中的地鼠探出頭來。 如果超過地鼠持續出現的時間，地鼠就應該要重新回到洞中。所以這邊使用setTimeout()，在經過地鼠出現持續時間time後，移除hole上的.up，讓地鼠順利回家。在遊戲未結束(timeup = false)且前一隻地鼠已經回家的狀態下，我們會重新呼叫peep()，讓下一隻地鼠探頭出來。 1234567891011let timeup = false;function peep()&#123; const time = randTime(200,1000); const hole = randomHole(holes); hole.classList.add(&#x27;up&#x27;); setTimeout(()=&gt;&#123; hole.classList.remove(&#x27;up&#x27;); if(!timeup) peep(); &#125;,time);&#125; 宣告變數score給定初始值0，用來幫我們算分數。 startGame()可以讓我們在點擊頁面上的button後，立即開始打地鼠遊戲。 在方法的一開始，先把記分板(scoreBoard)歸零，然後把代表結束遊戲與否的timeup設成flase，同時也把計算的分數(score)歸零。 上面都做完後，呼叫peep()讓地鼠開始探頭出來給我們打，接著利用setTimeout()訂定打地鼠遊戲的時間限制，這邊設定遊戲時間為15秒(15000毫秒)，15秒後把timeup設為true並提示使用者遊戲結束。 123456789101112let score = 0;function startGame()&#123; scoreBoard.textContent = 0; timeup = false; score = 0; peep(); setTimeout(()=&gt;&#123; timeup = true; alert(&quot;時間到，遊戲結束!!!&quot;); &#125; , 15000);&#125; 最後一部分要來處理的是&quot;當地鼠被點擊到，頁面上的得分要加1，然後地鼠要縮回洞中&quot;。 我們可以為每一隻地鼠(mole)註冊click event listener以bonk()作為event handler。 在bonk()裡，首先判斷點擊是不是&quot;人為&quot;的，如果是使用者點擊觸發，則e.isTrusted會回傳true，而如果是用像是script之類的去觸發click event，則會回傳false並直接停止往下執行方法。 接著，在每一次點擊成功後，把分數(score)加1並移除加到地鼠(mole)上的.up，讓地鼠回到洞中，之後更新頁面上的得分(scoreBoard)就完成了。 12345678function bonk(e)&#123; if(!e.isTrusted) return; //cheater score++; this.classList.remove(&#x27;up&#x27;); scoreBoard.textContent = score;&#125;moles.forEach(mole =&gt; mole.addEventListener(&#x27;click&#x27;,bonk)); ¶補充資料: Math.random() Math.round() Math.floor() setTimeout() Element.classList Node.textContent Event.isTrusted ¶範例網頁請點此 ¶完整程式碼請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第29天","slug":"ironman2021D29","date":"2021-09-29T07:46:44.000Z","updated":"2022-03-08T15:28:35.204Z","comments":true,"path":"2021/09/29/ironman2021D29/","link":"","permalink":"https://qi-xiang.github.io/2021/09/29/ironman2021D29/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 製作網頁版的倒數計時器，透過點按網頁上的按鈕快速設定倒數計時器或是在輸入框內輸入要設定倒數的分鐘數。 在這裡順便說明什麼是Vanilla JS，Vanilla JS是一個快速、輕量化、跨平台的 JavaScript 框架。 ¶解析程式碼 ¶HTML 部分 .timer是倒數計時器的本體，以下又可分成兩大部分，.timer__controls是其下設置倒數計時器的控制列，.display是其下用來展示剩餘時間和倒數結束時間的容器。 此外，可以發現在每一個button元素上，都有設定data-time屬性，這個屬性用來幫我們快速地設置倒數計時器且單位是以秒計算。 #custom內部放置一個文字輸入框，在使用者輸入數字按下 enter 後，這個數字會被拿來設定倒數計時器並以分鐘作為單位。 .display__time-left用來放置正在倒數的時間(分:秒)。 display__end-time用來放置倒數結束的時間。 12345678910111213141516&lt;div class=&quot;timer&quot;&gt; &lt;div class=&quot;timer__controls&quot;&gt; &lt;button data-time=&quot;20&quot; class=&quot;timer__button&quot;&gt;20 Secs&lt;/button&gt; &lt;button data-time=&quot;300&quot; class=&quot;timer__button&quot;&gt;Work 5&lt;/button&gt; &lt;button data-time=&quot;900&quot; class=&quot;timer__button&quot;&gt;Quick 15&lt;/button&gt; &lt;button data-time=&quot;1200&quot; class=&quot;timer__button&quot;&gt;Snack 20&lt;/button&gt; &lt;button data-time=&quot;3600&quot; class=&quot;timer__button&quot;&gt;Lunch Break&lt;/button&gt; &lt;form name=&quot;customForm&quot; id=&quot;custom&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;minutes&quot; placeholder=&quot;Enter Minutes&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;display&quot;&gt; &lt;h1 class=&quot;display__time-left&quot;&gt;&lt;/h1&gt; &lt;p class=&quot;display__end-time&quot;&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; ¶JS 部分 宣告變數countdown，待會用來指定成後面setInterval()的間隔代碼(Interval ID)。 宣告常數timeDisplay取得用來放置倒數時間的元素。 12let countdown;const timeDisplay = document.querySelector(&#x27;.display__time-left&#x27;); 在timer()裡首先要取得現在的時間(Date.now())，要注意這邊回傳的是以毫秒為單位的timestamp。 接著宣告then作為倒數計時結束的時間點，把要倒數的秒數乘上1000(換成毫秒)再加上現在的時間(毫秒)就完成了。 再接下來可以注意到在第五行，呼叫了displayTimeLeft()這個方法，這個方法用來幫我們把倒數中的時間放到.display__time-left還有網頁的標題裡面(方法的詳細內容在更下面)。 那為什麼在開始倒數之前，要先呼叫displayTimeLeft()呢? 因為用setInterval()倒數的話，它會有1秒的延遲時間，也就是說最一開始的那1秒是什麼都沒有的狀態，所以要呼叫displayTimeLeft()補上那1秒的空窗期。 然後就是用setInterval()開始倒數的部分啦~ 在這邊宣告常數secondsLeft放入經計算後的剩餘秒數，記得要除上1000，因為每一秒 then - Date.now() 的結果單位都是毫秒，最後用Math.round()四捨五入取最近的整數。 secondLeft小於0的時候，我們應該要立即停止倒數，這時候前面指定的 Interval ID 就派上用場啦~ 用clearInterval(countdown)就可以把倒數輕鬆移除。 12345678910111213141516function timer(seconds)&#123; const now = Date.now(); const then = now +seconds * 1000; //run immediately not run after 1 sec displayTimeLeft(seconds); countdown = setInterval(()=&gt;&#123; const secondsLeft = Math.round((then - Date.now())/1000); //display it if(secondsLeft &lt; 0)&#123; clearInterval(countdown); return; &#125; displayTimeLeft(secondsLeft); &#125;,1000)&#125; 在displayTimeLeft()，它會把拿到的剩餘秒數換算成分和秒，再放回到’.display__time-left’裡並同時修改網頁標題。 這邊要特別注意如果經換算後，秒數的部分不足10秒，則要透過條件判斷在前方補上0。(ex. 10:5 &gt;&gt;&gt; 10:05) 1234567function displayTimeLeft(seconds)&#123; const minutes = Math.floor(seconds/60); const reminderSeconds = seconds%60; const display = `$&#123;minutes&#125;:$&#123;reminderSeconds &lt; 10 ? &#x27;0&#x27; : &#x27;&#x27;&#125;$&#123;reminderSeconds&#125;`; document.title = display; timeDisplay.textContent = display;&#125; 宣告常數endTime取得放置倒數結束時間的元素，接下來就要用displayEndTime()來處理倒數結束的時間囉! 在displayEndTime()，他把傳入的timestamp(單位 : 毫秒)，用new Date(timestamp)建立成一個Date物件再放入常數end裡面。 接下來 Do Re Mi SO，把endTime(結束時間)，修改成自Date物件取得的小時、分鐘。特別注意遇到分鐘數不足10分鐘時，要利用條件判斷在數字前方補上0，例如: 21:5 &gt;&gt;&gt; 21:05。 12345678const endTime = document.querySelector(&#x27;.display__end-time&#x27;);/*中略....*/function displayEndTime(timestamp)&#123; const end = new Date(timestamp); const hour = end.getHours(); const minutes = end.getMinutes(); endTime.textContent = `Be Back At $&#123;hour&#125;:$&#123;minutes &lt; 10 ? &#x27;0&#x27; : &#x27;&#x27;&#125;$&#123;minutes&#125;`;&#125; new Date(timestamp)的一些操作如下圖 : (我一開始覺得怪怪的，為什麼getMonth()回傳的是8而不是9? 後來一查才發現0代表的是1月 XD) 下面把timer()倒數結束的時間(then，毫秒)，傳入displayEndTime()，修改頁面上的倒數結束時間。 12345function timer(seconds)&#123; /*上略...*/ displayEndTime(then); /*下略...*/&#125; 宣告常數buttons取得所有用來快速設定倒數計時器的按鈕。 然後為每個button都註冊click event listener以startTimer()作為event handler。 在startTimer()，宣告常數seconds取得被點擊按鈕上的data-time屬性值，接著把這個seconds丟入timer()，成功建立一個倒數計時器。 12345678const buttons = document.querySelectorAll(&#x27;[data-time]&#x27;);/*中略...*/function startTimer()&#123; const seconds = parseInt(this.dataset.time); timer(seconds);&#125;buttons.forEach(button =&gt; button.addEventListener(&#x27;click&#x27;,startTimer)); 如果這時候開始瘋狂點擊按鈕建立倒數計時器，你會發現網頁上的倒數時間開始&quot;抽搐&quot;，因為之前建立的倒數計時器仍在運作，造成網頁倒數時間的文字被頻繁地修改，然後不自然的&quot;抽搐&quot;就出現了。 所以我們需要在timer()的最上面加上clearInterval(countdown);這一行，在每一次設定倒數計時器的時候，把之前的倒數計時器通通清掉。 12345function timer(seconds)&#123; //clear any existing timer clearInterval(countdown); /*下略...*/&#125; 最後要來處理文字輸入框的部分，在form元素上註冊submit event listener以後面的function()作為event handler。 因為submit表單時會重新整理網頁，所以在第一行寫e.preventDefault()防止網頁重新整理。接著宣告常數mins承接來自&lt;input name=&quot;minutes&quot;&gt;的分鐘數(value)，然後再把分鐘數乘上60換成秒傳入timer()，成功設定倒數計時器。最後一行的this.reset()用來重置表單元素。 1234567document.customForm.addEventListener(&#x27;submit&#x27;,function(e)&#123; e.preventDefault(); const mins = this.minutes.value; console.log(mins); timer(mins * 60); this.reset();&#125;); ¶補充資料: Date.now() WindowOrWorkerGlobalScope.setInterval() clearInterval() Math.floor() Node.textContent Date.prototype.getHours() Date.prototype.getMinutes() HTMLElement.dataset ¶範例網頁 ¶完整程式碼請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第28天","slug":"ironman2021D28","date":"2021-09-28T07:46:39.000Z","updated":"2022-03-08T15:28:22.299Z","comments":true,"path":"2021/09/28/ironman2021D28/","link":"","permalink":"https://qi-xiang.github.io/2021/09/28/ironman2021D28/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 除了原本在video元素自帶的影片控制器(設定controls屬性)，我們可以另外實作一個調節影片速度的控制介面，這個介面可以用拖拉的方式改變影片的播放速度。 ¶解析程式碼 ¶HTML 部分 div(.wrapper)是我們整個的影片播放器，下面可拆作兩部分，一個是 video(.flex)和自帶的預設控制介面(啟用controls)，另一個是我們這次要實作出的影片速度調節介面 div(.speed)。 123456&lt;div class=&quot;wrapper&quot;&gt; &lt;video class=&quot;flex&quot; width=&quot;765&quot; height=&quot;430&quot; src=&quot;http://clips.vorwaerts-gmbh.de/VfE_html5.mp4&quot; loop controls&gt;&lt;/video&gt; &lt;div class=&quot;speed&quot;&gt; &lt;div class=&quot;speed-bar&quot;&gt;1×&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; ¶JS 部分 首先，取得所有需要的元素 : 宣告常數speed放入取得的速度調節介面(.speed)。 宣告常數bar放入取得的速度調節介面內部的子元素(.speed-bar)。 宣告常數video放入取得的video元素(.flex)。 123const speed = document.querySelector(&#x27;.speed&#x27;);const bar = document.querySelector(&#x27;.speed-bar&#x27;);const video =document.querySelector(&#x27;.flex&#x27;); 在speed註冊mousemove event listener監聽是否有滑鼠在speed上移動，有的話就用後方的function()作為event handler。 在event handler裡，我們要先取得的是滑鼠在內部移動時的 y 座標(e.pageY，相對整個 HTML 文件頂部而言)，又因為我們無法保證速度調節介面(.speed)是在 HTML 文件的最頂端而且沒有margin、padding之類的，所以還須把取得的 y 座標減去.speed離視窗(offsetParent)頂端的距離(offsetTop)進行修正。 宣告常數percent算出目前滑鼠所在的 y 座標位置，相對於整個速度調節介面高度(this.offsetHeight)的比例，作為後續調整.speed-bar的高度和.flex影片播放速度的依據。 宣告常數max、min作為調整影片播放速度時能達到的最大、最小倍率。 1234567speed.addEventListener(&#x27;mousemove&#x27;, function(e)&#123; //we can&#x27;t assume that speed is on the top const y = e.pageY - this.offsetTop; const percent = y / this.offsetHeight; const min = 0.4; const max = 4;&#125;); 宣告常數height，用Math.round(percent*100)+'%'，將剛剛算出的比例換成百分比的形式。 宣告常數playbackRate計算現在的比例(percent)換算成的速度倍率。 將.speed-bar的高度設為我們算出的高度百分比(height)，然後再把它的文字內容換成現在的速度倍率(ex. 1.2x)。toFixed()幫我們把算出的速度倍率(playbackRate)取到小數點後1位。 最後修改video的playbackRate屬性就完成了。 (播放速度太快或太慢均有可能導致影片部分聲音消失!!!) 12345678speed.addEventListener(&#x27;mousemove&#x27;, function(e)&#123; /*上略...*/ const height = Math.round(percent*100)+&#x27;%&#x27;; const playbackRate = percent * (max-min) + min; bar.style.height = height; bar.textContent = playbackRate.toFixed(1)+&#x27;x&#x27;; video.playbackRate = playbackRate;&#125;); ¶補充資料 : HTMLElement.offsetTop HTMLMediaElement.playbackRate HTMLElement.offsetHeight Number.prototype.toFixed() Math.round() ¶範例網頁請點此 ¶觀看完整程式碼","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第27天","slug":"ironman2021D27","date":"2021-09-27T07:46:34.000Z","updated":"2022-03-08T15:28:10.938Z","comments":true,"path":"2021/09/27/ironman2021D27/","link":"","permalink":"https://qi-xiang.github.io/2021/09/27/ironman2021D27/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 實作出能夠按住滑鼠左右拖曳的水平捲軸。 ¶解析程式碼 ¶HTML 部分 捲軸(div.items)由內部的25個div.item共同組成。 123456789&lt;div class=&quot;items&quot;&gt; &lt;div class=&quot;item item1&quot;&gt;01&lt;/div&gt; &lt;div class=&quot;item item2&quot;&gt;02&lt;/div&gt; &lt;div class=&quot;item item3&quot;&gt;03&lt;/div&gt; &lt;!--中間省略...--&gt; &lt;div class=&quot;item item23&quot;&gt;23&lt;/div&gt; &lt;div class=&quot;item item24&quot;&gt;24&lt;/div&gt; &lt;div class=&quot;item item25&quot;&gt;25&lt;/div&gt;&lt;/div&gt; ¶JS 部分 宣告常數slider取得捲軸(div.items)元素。 宣告變數isDown作為判斷滑鼠是否有被按住的 flag，給定預設值是 false。 宣告變數startX用來放入之後取得的移動起始點座標。 宣告變數scrollLeft用來取得div.items下方 scrollbar 的位置，最左方是 0。 1234const slider = document.querySelector(&#x27;.items&#x27;);let isDown = false; //flag variablelet startX;let scrollLeft; 當滑鼠被按住(mousedown) : 把isDown設為true。 當滑鼠離開 slider 的範圍(mouseleave) : 把isDown設為false，因為離開 slider 範圍不應再有拖拉的效果(不執行mousemove裡面的內容)。 當放開滑鼠(mouseup) : 把isDown設為false，因為mouseup代表已放開滑鼠。 當滑鼠在 slider 裡移動(mousemove) : 先判斷滑鼠是否被按住，若沒被按住(isDown = false)則直接跳出方法不往下執行。 123456789101112131415slider.addEventListener(&#x27;mousedown&#x27;, () =&gt; &#123; isDown = true;&#125;);slider.addEventListener(&#x27;mouseleave&#x27;, () =&gt; &#123; isDown = false;&#125;);slider.addEventListener(&#x27;mouseup&#x27;, () =&gt; &#123; isDown = false;&#125;);slider.addEventListener(&#x27;mousemove&#x27;, () =&gt; &#123; if(!isDown) return; //stop the function from running&#125;); 接下來在按住滑鼠時，在 slider 上添加.active這個 class，而在滑鼠離開 slider 範圍或放開滑鼠時，移除 slider 上的.active。 .active這個 CSS class 選擇器，用來設定拖拉捲軸時產生的效果，例如處於拖拉狀態，捲軸(.items)會比原來的大小略為放大一點。 event.preventDefault()用來取消DOM的預設功能，在這裡是避免被 browser 認為想要選取文字之類的。 12345678910111213141516171819slider.addEventListener(&#x27;mousedown&#x27;, () =&gt; &#123; isDown = true; slider.classList.add(&#x27;active&#x27;);&#125;);slider.addEventListener(&#x27;mouseleave&#x27;, () =&gt; &#123; isDown = false; slider.classList.remove(&#x27;active&#x27;);&#125;);slider.addEventListener(&#x27;mouseup&#x27;, () =&gt; &#123; isDown = false; slider.classList.remove(&#x27;active&#x27;);&#125;);slider.addEventListener(&#x27;mousemove&#x27;, () =&gt; &#123; if(!isDown) return; //stop the function from running e.preventDefault();&#125;); 在 slider 裡面按住滑鼠(mousedown)，首先要做的是取得滑鼠在整個 HTML 文件的座標(會隨著捲軸移動改變)，所以先呼叫e.pageX。那為什麼還要減去slider.offserLeft呢? 因為我們要取得的是在 slider 裡面的 x 座標，而 slider 剛好有左 margin，所以要減掉offsetLeft修正再放回startX(滑鼠在 slider 裡的 x 座標)。 宣告常數scrollLeft放入按住滑鼠時 slider 下方 scrollbar 的位置。 12345678slider.addEventListener(&#x27;mousedown&#x27;, (e) =&gt; &#123; //省略... //know where we click on the slider startX = e.pageX - slider.offsetLeft;// if the slider has the margin left then we should correct it scrollLeft = slider.scrollLeft; console.log(startX); console.log(scrollLeft);&#125;); 在mousemove event handler裡，宣告常數x不斷更新滑鼠在 slider 內移動的座標，跟上面一樣要把 e.pageX 減去 slider.offsetLeft 作 slider 有左 morgin 時的修正。 常數walk放入移動時的x座標減去起始點的x座標作為移動下方 scrollbar 的依據，把算出來的值乘上3是為了讓 scrollbar 移動的距離更加大、明顯。 最後，為了讓移動時更加順暢，把先前取得的 scrollLeft 減去 walk，指定捲軸移動的位置和距離大小，這裡一定要用減的，因為移動方向和算出來的值剛好差負號。 舉例來說按住滑鼠向左拉，此時的捲軸應該要往右(+)移動，但算出的 walk 會是負的，所以要再加上-號修正。 123456slider.addEventListener(&#x27;mousemove&#x27;, (e) =&gt; &#123; //省略... const x = e.pageX - slider.offsetLeft; const walk = (x - startX)*3; slider.scrollLeft = scrollLeft - walk;&#125;); ¶補充資料 : Element.scrollLeft HTMLElement.offsetLeft MouseEvent.pageX JS一秒區分clientX,offsetX,screenX,pageX之間關係 ¶範例網頁請點此 ¶完整程式碼請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第26天","slug":"ironman2021D26","date":"2021-09-26T07:42:42.000Z","updated":"2022-03-08T15:28:02.807Z","comments":true,"path":"2021/09/26/ironman2021D26/","link":"","permalink":"https://qi-xiang.github.io/2021/09/26/ironman2021D26/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 今天我們要實作的內容是當使用者hover in 或 out 導覽列時，展開顯示下方的連結、文字內容並搭配上 CSS 的動畫效果。 ¶解析程式碼 ¶HTML 部分 &lt;h2&gt;&lt;/h2&gt;用來模擬&lt;nav&gt;&lt;/nav&gt;不是 HTML 最上面元素的情況。 &lt;nav&gt;&lt;/nav&gt;(.top)是我們的導覽列，其中包含作項目內容背景用途的&lt;div&gt;&lt;/dvi&gt;(.dropDownBackground)，以及項目列表&lt;ul&gt;&lt;/ul&gt;(.cool)和項目內容&lt;li&gt;&lt;/li&gt;，其中每一個項目的內容除了&lt;a&gt;&lt;/a&gt;標題連結有顯示外，剩餘資訊.dropdown的部分都被預設隱藏。 123456789101112131415161718192021222324252627&lt;h2&gt;Cool&lt;/h2&gt;&lt;nav class=&quot;top&quot;&gt; &lt;div class=&quot;dropdownBackground&quot;&gt; &lt;span class=&quot;arrow&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;ul class=&quot;cool&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;About Me&lt;/a&gt; &lt;div class=&quot;dropdown dropdown1&quot;&gt; &lt;!--省略--&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Courses&lt;/a&gt; &lt;ul class=&quot;dropdown courses&quot;&gt; &lt;!--省略--&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Other Links&lt;/a&gt; &lt;ul class=&quot;dropdown dropdown3&quot;&gt; &lt;!--省略--&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; ¶CSS 部分 .dropdown : 分別設定opacity: 0;、display: none;預設隱藏.dropdown，然後用transition監控 CSS 屬性值的變化，達成 CSS 動畫的效果。 .trigger-enter .dropdown : .trigger-enter 這個 class 會在 hover in 任意一個&lt;li&gt;&lt;/li&gt;時，被加到.dropdown上。設定display:block;把隱藏的項目資訊 show 出來，但現在還是透明的。 .trigger-enter-active .dropdown : .trigger-enter-active 這個 class 會在 hover in 任意一個&lt;li&gt;&lt;/li&gt;時，被加到.dropdown上。設定opacity:1;把隱藏的項目資訊 show 出來，現在是不透明的。 為什麼要把opacity、display分開寫而不寫在同一個 class 選擇器呢? 因為寫在一起的話，transition的動畫效果會失效。 12345678910111213141516.dropdown &#123; /*省略...*/ opacity: 0; /*省略...*/ transition: all 0.5s; /*省略...*/ display: none; &#125;.trigger-enter .dropdown &#123; display: block;&#125;.trigger-enter-active .dropdown &#123; opacity: 1; /*display和opacity分開寫是為了CSS動畫效果*/&#125; .dropdownBackground : 初始項目內容的背景被隱藏(透明)。 .dropdownBackground.open : 讓項目內容的背景被顯示出來(不透明)。而.open 這個 class 會在 hover in 任意一個&lt;li&gt;&lt;/li&gt;時，被加到.dropdownBackground上。 12345678.dropdownBackground &#123; /*省略...*/ opacity:0;&#125;.dropdownBackground.open &#123; /*show the background*/ opacity: 1;&#125; ¶JS 部分 首先取得所有必要的網頁元素，包括項目列表下的每個&lt;li&gt;、作為列表項目內容背景的.dropdownBackground以及導覽列.top。 123const triggers = document.querySelectorAll(&#x27;.cool &gt; li&#x27;);const background = document.querySelector(&#x27;.dropdownBackground&#x27;);const nav = document.querySelector(&#x27;.top&#x27;); 為項目列表中的每個&lt;li&gt;都分別註冊mouseenter event listener(hover in 觸發)和mouseleave event listener(hover out 觸發)，然後各自以handleEnter()和handleLeave作事件處理。 1234567891011//listen for hovering in and outfunction handleEnter()&#123;&#125;function handleLeave()&#123; &#125;triggers.forEach(trigger =&gt; trigger.addEventListener(&#x27;mouseenter&#x27;,handleEnter));triggers.forEach(trigger =&gt; trigger.addEventListener(&#x27;mouseleave&#x27;,handleLeave)); hover in &lt;li&gt;時，將trigger-enter加到&lt;li&gt;上。 然後利用setTimeout()讓在&lt;li&gt;加上trigger-enter-active這件事被延遲150毫秒，利用條件判斷只有當&lt;li&gt;上已經有.trigger-enter這個 class，才執行後方的在&lt;li&gt;加上.trigger-enter-active，會需要做到這樣是為避免使用者 hover in and out 的時間過快，讓一個項目的內容還沒來得及消失，另一個卻馬上出現，造成殘影的效果。 最後，在項目內容背景加上.open這個 class 讓它被 show 出來。 12345678function handleEnter()&#123; this.classList.add(&#x27;trigger-enter&#x27;); //use the arrow function or &#x27;this&#x27; will be the window //不要讓內容太早被show出來，不然可能會出現殘影 setTimeout(()=&gt; this.classList.contains(&#x27;trigger-enter&#x27;) &amp;&amp; this.classList.add(&#x27;trigger-enter-active&#x27;),150); //set background background.classList.add(&#x27;open&#x27;);&#125; handleLeave()要做的事情很簡單，就是當使用者 hover out 時，移除所有被新增的 class。 12345function handleLeave()&#123; this.classList.remove(&#x27;trigger-enter&#x27;,&#x27;trigger-enter-active&#x27;); //set background background.classList.remove(&#x27;open&#x27;);&#125; 最後的最後，我們要把項目內容的背景移到它該待的地方。 首先取得項目內容的元素然後再取得項目內容相對視窗右上角的座標(這個座標不隨著 scroll down 而有所改變)。 複習一下getBoundingClientRect()取得的元素座標圖 : 那為什麼我們還需要取得導覽列nav的座標呢? 因為在 nav 不是 HTML 文件裡的第一個元素時，如果只單單用.dropdown的left、top進行項目內容背景的位置設定，會發現到背景被稍微往下擠了一點，被往下擠的大小剛好可以用導覽列nav的位置來作修正，分別將指定的left、top減去nav的left、top就好。 我們將大小、位置等等資訊整合在物件coords裡，之後再個別利用coords裡的指定值去修改項目內容背景的 CSS 屬性就完成了。 12345678910111213141516171819function handleEnter()&#123; // 上略... // set position of the background const dropDown = this.querySelector(&#x27;.dropdown&#x27;); const dropDownCoords = dropDown.getBoundingClientRect(); const navCoords = nav.getBoundingClientRect(); console.log(dropDownCoords); const coords = &#123; height: dropDownCoords.height, width: dropDownCoords.width, top: dropDownCoords.top - navCoords.top, left: dropDownCoords.left - navCoords.left &#125; background.style.setProperty(&#x27;width&#x27;,`$&#123;coords.width&#125;px`); background.style.setProperty(&#x27;height&#x27;,`$&#123;coords.height&#125;px`); background.style.setProperty(&#x27;transform&#x27;,`translate($&#123;coords.left&#125;px,$&#123;coords.top&#125;px)`);&#125; ¶補充資料 : mouseenter mouseleave Element.getBoundingClientRect() CSSStyleDeclaration.setProperty() ¶範例網頁請點此 ¶完整程式碼","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第25天","slug":"ironman2021D25","date":"2021-09-25T07:42:38.000Z","updated":"2022-03-08T15:27:55.451Z","comments":true,"path":"2021/09/25/ironman2021D25/","link":"","permalink":"https://qi-xiang.github.io/2021/09/25/ironman2021D25/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 瞭解addEventListener中事件的捕捉、傳遞(Event Bubbling/Capturing)以及一次性的事件監聽(Once)。 ¶解析程式碼 ¶HTML 部分 建立三層的div做為測試event listener的物件。 div(.one) : 淡紫色 div(.two) : 淡粉色 div(.three) : 橘色 123456&lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;two&quot;&gt; &lt;div class=&quot;three&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; ¶JS 部分 Event Bubbling 首先取得所有的div標籤，然後在每個div上都註冊cllick event listener並以logText()進行事件處理把div標籤的class屬性值印出來。 1234567const divs = document.querySelectorAll(&#x27;div&#x27;);function logText(e)&#123; console.log(this.classList.value);&#125;divs.forEach(div =&gt; div.addEventListener(&#x27;click&#x27;,logText)); 點擊最內層的div(橘色)，console 印出的內容如下 : 由上面的結果，我們可以得知在 div(.three)捕捉到事件後，還會連帶向上觸發parents的event handler，這種由底部向上傳遞觸發event handler的機制稱為event bubbling。 傳遞順序 : div.three(橘色) -&gt; div.two(淡粉色) -&gt; div.one(淡紫色) Event Capturing 前面的Event Bubbling是從觸發事件的element開始向外層的parent element進行事件傳遞，而Event Capturing則是從觸發事件的element的最外層parent element向內進行傳遞。 要做到這一點，我們就必須使用到addEvenListener的第三個參數Options Object的capture屬性，這個屬性的預設值是false，我們只需要把它改成true即可。 1234/*上略...*/divs.forEach(div =&gt; div.addEventListener(&#x27;click&#x27;,logText,&#123; capture: true&#125;)); 設定完後點擊div.three，console 印出結果如下 : 傳遞順序 : div.one(淡紫色) -&gt; div.two(淡粉色) -&gt; div.three(橘色) capture : true，Event Capturing。 capture : false，Event Bubbling。 上方的Event Bubbling其實可被改寫如下 : 1234/*上略...*/divs.forEach(div =&gt; div.addEventListener(&#x27;click&#x27;,logText,&#123; capture: false //預設就是 false 可直接省略&#125;)); Event Propagation 那如果不想讓事件由內向外(bubbling)或由外向內(capturing)傳遞要怎麼辦呢? 我們可以在event handler裡面對Event呼叫stopPropagation()，讓事件不再繼續傳遞。 以阻止Event Bubbling為例，在event handler裡面，我們對event(e)呼叫stopPropagation()。 123456789/*上略...*/function logText(e)&#123; console.log(this.classList.value); e.stopPropagation(); //stop bubbling or capturing&#125;divs.forEach(div =&gt; div.addEventListener(&#x27;click&#x27;,logText,&#123; capture: false&#125;)); 然後點擊div.three，console 印出結果如下 : 由上可知呼叫stopPropagation()後，事件就沒有繼續傳遞。 Event Once addEvenListener的第三個參數Options Object的屬性除了capture之外，還有once這個屬性(預設是false)，它可以用來指定是否在觸發一次事件處理後，就unbind event listener(讓事件監聽器失效)。 下面以按鈕作為例子 : 在網頁上放置一個button。 1&lt;button&gt;Button&lt;/button&gt; 透過 JS 取得button標籤，然後為其註冊click event listener並指定Options Object的once屬性為 true。 12345const button = document.querySelector(&#x27;button&#x27;);const text = &#x27;努力は自分に裏切らない、梦想は裏切ります！努力は梦を実现することはできない！しかし、努力している事実は自分を慰めることができる。--大先生&#x27;button.addEventListener(&#x27;click&#x27;,() =&gt; alert(text),&#123; once: true&#125;); 此時點擊button，視窗會顯示提示訊息，但若在未 reload 頁面的情況下二次點擊button，會發現視窗不再顯示提示訊息，也就是button失效了。 這個效果可以放在提交表單的按鈕上，用來防止使用者重複提交表單。 ¶補充資料 : EventTarget.addEventListener() Event.stopPropagation() [教學] 瀏覽器事件：Event Bubbling, Event Capturing 及 Event Delegation ¶點擊檢視完整程式碼(Wes Bos)","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第24天","slug":"ironman2021D24","date":"2021-09-24T07:41:19.000Z","updated":"2022-03-08T15:27:44.392Z","comments":true,"path":"2021/09/24/ironman2021D24/","link":"","permalink":"https://qi-xiang.github.io/2021/09/24/ironman2021D24/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 今天我們要做的是置頂導覽列，當使用者拉下捲軸而視窗頂部碰到導覽列頂部時，若往後繼續下拉捲軸則將導覽列始終固定在最上方。 ¶解析程式碼 ¶HTML 部分 header是網頁上方的標題。 #main是網頁的導覽列，包含.logo(初始隱藏)還有其他五個項目。 .site-wrap放的是一大堆假文還有圖片。 123456789101112131415161718&lt;header&gt; &lt;h1&gt;A story about getting lost.&lt;/h1&gt;&lt;/header&gt;&lt;nav id=&quot;main&quot;&gt; &lt;ul&gt; &lt;li class=&quot;logo&quot;&gt;&lt;a href=&quot;#&quot;&gt;LOST.&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Images&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Locations&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Maps&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt;&lt;div class=&quot;site-wrap&quot;&gt; &lt;!--以下是假文還有圖片，為不佔空間所以省略--&gt;&lt;/div&gt; ¶JS 部分 宣告常數nav取得網頁導覽列。 宣告常數topOfNav取得導覽列頂部離視窗最上方的距離。 12const nav = document.querySelector(&#x27;#main&#x27;);const topOfNav = nav.offsetTop; 我們置頂導覽列的機制主要是透過觀測捲軸的&quot;捲動量&quot;來決定是否置頂捲軸。為此首先要在window註冊scroll event listener在捲軸捲動時不斷觸發，然後用fixNav()進行事件處理。 在fixedNav()裡面，我們可以判斷現在視窗的 y 方向捲動量(window.scrollY)是否超過導覽列的頂部(topOfNav)，如果超過的話就在body上添加fixed-nav這個 class，反之若沒有超過則移除fixed-nav。 那為什麼我們還要特別設定body的padding-top呢? 因為在導覽列(#main)的 CSS 設定中，我們使用了position: fixed;，這樣就會造成導覽列(#main)原本佔的空間突然空出來，之後下方的.site-wrap看上面還有空間就會擠上來，但擠上來的速度過快，因此在視覺上就會出現詭異的彈跳。 為避免這種狀況發生，我們可以在置頂導覽列的同時，指定body的padding-top: nav.ofsetHeight;，讓原本導覽列佔有的空間，被padding-top補上。不置頂導覽列的同時，理所當然我們就要將body的padding-top改回 0。 123456789101112function fixNav()&#123; console.log(topOfNav,window.scrollY); if(window.scrollY &gt;= topOfNav)&#123; document.body.style.paddingTop = nav.offsetHeight + &#x27;px&#x27;; document.body.classList.add(&#x27;fixed-nav&#x27;); &#125;else&#123; document.body.style.paddingTop = 0; document.body.classList.remove(&#x27;fixed-nav&#x27;); &#125;&#125;window.addEventListener(&#x27;scroll&#x27;,fixNav); ¶CSS 部分 下面是在body上有.fixed-nav這個 class 時的特殊設定。 設定導覽列position: fixed，在預設上是固定在left: 0;、top: 0;的位置(視窗左上角)，然後加上一點陰影。 1234.fixed-nav nav&#123; position: fixed; box-shadow: 0 5px rgba(0,0,0,0.1);&#125; 把原本在導覽列隱藏的logo顯示出來，設定max-width(最大寬度)為500px，這裡原本也可以用width: 500px;就好，但是設定width會讓transition產生的動畫效果失效。 123.fixed-nav li.logo&#123; max-width: 500px; /*use width can&#x27;t show animation effect*/&#125; 在置頂導覽列的同時，把下方的文章區塊略為放大。 123.fixed-nav .site-wrap&#123; transform: scale(1);&#125; ¶補充資料: HTMLElement.offsetTop HTMLElement.offsetHeight Element.classList CSS Transform Element: scroll event Window.scrollY ¶範例網頁請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第23天","slug":"ironman2021D23","date":"2021-09-23T07:29:15.000Z","updated":"2022-03-08T15:27:34.602Z","comments":true,"path":"2021/09/23/ironman2021D23/","link":"","permalink":"https://qi-xiang.github.io/2021/09/23/ironman2021D23/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 還記得在 Day 20 - Native Speech Recognition，我們使用了 Web Speech API 中語音識別(Speech recognition)的部分，而這次我們要使用的是語音合成(Speech synthesis)的部分。 這次的主角是Web Speech API的SpeechSynthesis、SpeechSynthesisUtterance。 在下面的範例，我們會利用 API 語音合成功能，讓網頁用不同的聲音讀出textarea裡面的文字。 ¶解析程式碼 ¶HTML 部分 select(#voices)是一個用來選擇要用什麼聲音讀出文字的選單。 input([name=&quot;rate&quot;]) 是用來調整讀字的速度。 input([name=&quot;rate&quot;]) 是用來調整讀字音高。 textarea([name=&quot;text&quot;]) 是要讀的文字。 button(#stop) 是停止讀的按鈕。 button(#speak) 是開始讀的按鈕。 12345678910111213141516171819&lt;div class=&quot;voiceinator&quot;&gt; &lt;h1&gt;The Voiceinator 5000&lt;/h1&gt; &lt;select name=&quot;voice&quot; id=&quot;voices&quot;&gt; &lt;option value=&quot;&quot;&gt;Select A Voice&lt;/option&gt; &lt;/select&gt; &lt;label for=&quot;rate&quot;&gt;Rate:&lt;/label&gt; &lt;input name=&quot;rate&quot; type=&quot;range&quot; min=&quot;0&quot; max=&quot;3&quot; value=&quot;1&quot; step=&quot;0.1&quot;&gt; &lt;label for=&quot;pitch&quot;&gt;Pitch:&lt;/label&gt; &lt;input name=&quot;pitch&quot; type=&quot;range&quot; min=&quot;0&quot; max=&quot;2&quot; step=&quot;0.1&quot;&gt; &lt;textarea name=&quot;text&quot;&gt;Hello! I love JavaScript 👍&lt;/textarea&gt; &lt;button id=&quot;stop&quot;&gt;Stop!&lt;/button&gt; &lt;button id=&quot;speak&quot;&gt;Speak&lt;/button&gt;&lt;/div&gt; ¶JS 部分 宣告常數 msg 並建立一個SpeechSynthesisUtterance物件，這個物件主要包含兩種資訊，一個是要讀出的內容(what to read)，另一個是要如何讀它(how to read)。 宣告空陣列 voices，之後我們會放入由SpeechSynthesis.getVoices()取得的聲音種類陣列。 後面的四個常數分別取得聲音種類選單、調整速度/音高的滑動桿、開始讀出文字按鈕、停止讀出文字按鈕。 123456const msg = new SpeechSynthesisUtterance(); //come from WEB Speech APIlet voices = [];const voicesDropdown = document.querySelector(&#x27;[name=&quot;voice&quot;]&#x27;);const options = document.querySelectorAll(&#x27;[type=&quot;range&quot;], [name=&quot;text&quot;]&#x27;);const speakButton = document.querySelector(&#x27;#speak&#x27;);const stopButton = document.querySelector(&#x27;#stop&#x27;); text是SpeechSynthesisUtterance的一個屬性，用來指定要讀出的內容，下面我們指定要讀出的內容是textarea的文字。 1msg.text = document.querySelector(&#x27;[name=&quot;text&quot;]&#x27;).value; 接下來我們需要取得網頁支援的聲音種類並把它們做成選項放到選單裡面。 在做選單前，我們還要確保真的有拿到聲音種類的陣列，所以在speechSynthesis註冊voiceschanged event listener以populateVoices()作為事件處理函式。 在populateVoices()裡，我們首先將取得的聲音陣列放到voices裡面，在 console 印出陣列內容的話，可以發現陣列中的元素都是SpeechSynthesisVoice物件，這個物件擁有該種聲音的名稱、語言等等的屬性。 然後我們可以把 voices 陣列進行 map，把每種聲音都做成選項，因為 map 結束是一個陣列，還要加上join()讓它變成 HTML 格式的大字串，之後才能放入voicesDropdown當作選項。 123456789function populateVoices()&#123; voices = this.getVoices(); console.log(voices); voicesDropdown.innerHTML = voices .map(voice =&gt; `&lt;option value=&quot;$&#123;voice.name&#125;&quot;&gt;$&#123;voice.name&#125; ($&#123;voice.lang&#125;)&lt;/option&gt;`) .join(&#x27;&#x27;);&#125; speechSynthesis.addEventListener(&#x27;voiceschanged&#x27;,populateVoices); voices陣列的內容 : toggle()用來開始讀出文字或停止讀出文字，我們預設參數startOver = true表示在正常情況下都要開始讀文字。方法最上面寫speechSynthesis.cancel();的功能是停止讀文字，因為希望每一次讀都是重新開始讀。 123456function toggle(startOver = true)&#123; speechSynthesis.cancel(); // stop speaking if(startOver)&#123; speechSynthesis.speak(msg); // restart speaking &#125;&#125; 在選單(voiceDropdown)註冊change event listener，用來把讀文字的聲音種類，改成我們選擇的那種。 事件處理函式setVoice()，用來調整讀文字時的聲音種類。前面有說過SpeechSynthesisUtterance可以決定 how to read，所以它有一個voice屬性可以指定聲音種類。 要注意的是我們指定的聲音種類要是一個SpeechSynthesisVoice物件而不是給它聲音的名稱就好，所以還要在voices陣列尋找擁有和選項的value一樣聲音名稱(name)的SpeechSynthesisVoice物件。 在方法最後呼叫toggle()，就可以發現隨著每一次選的選項不同，它會重新讀一次文字。 1234567function setVoice()&#123; console.log(&#x27;changing voice&#x27;); msg.voice = voices.find(voice =&gt; voice.name === this.value); toggle();&#125;voicesDropdown.addEventListener(&#x27;change&#x27;, setVoice); 倒數第二個要處理的是讀文字時的速度和音高調整，因為SpeechSynthesisUtterance本身有pitch和rate屬性可供修改，所以我們只要拿設定好的&lt;input&gt;的 name 和 value 來修改SpeechSynthesisUtterance對應的屬性值就好。 在兩個&lt;input&gt;上都註冊change event listener，可以讓每一次滑桿值有改變時，就重新指定聲音屬性並重新開始讀文字(別忘記在setOption()的最後放入toggle())。 1234567function setOption()&#123; console.log(this.name,this.value); msg[this.name] = this.value; toggle();&#125;options.forEach(option =&gt; option.addEventListener(&#x27;change&#x27;,setOption)) 最後就是關於開始和停止讀文字鈕的部分啦~ 開始讀文字的按鈕比較簡單，只要註冊click event listener然用toggle()處理就好。 認真要說的話，停止讀文字的按鈕也沒有難到哪裡，只是這邊我們不能直接用... , toggle(false)，而是要寫... , ()=&gt;toggle(false)才會有停止讀文字的效果。 12speakButton.addEventListener(&#x27;click&#x27;,toggle);stopButton.addEventListener(&#x27;click&#x27;,() =&gt; toggle(false)); ¶補充資料: Web Speech API SpeechSynthesis SpeechSynthesisUtterance SpeechSynthesisVoice ¶範例網頁請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第22天","slug":"ironman2021D22","date":"2021-09-22T07:29:10.000Z","updated":"2022-03-08T15:27:26.346Z","comments":true,"path":"2021/09/22/ironman2021D22/","link":"","permalink":"https://qi-xiang.github.io/2021/09/22/ironman2021D22/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 當滑鼠移入&lt;a&gt;所代表的連結時，快速移動一個白框，產生文字背景為白底的聚光燈效果。 ¶解析程式碼 ¶HTML 部分 總共分成兩個部分，一個是上方的導覽列(.menu)，另一個是放置眾多文字段落和連結的容器(.wrapper)。 1234567891011121314151617&lt;nav&gt; &lt;ul class=&quot;menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Order Status&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Tweets&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Read Our History&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Contact Us&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt;&lt;div class=&quot;wrapper&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, &lt;a href=&quot;&quot;&gt;consectetur&lt;/a&gt; adipisicing elit. Est &lt;a href=&quot;&quot;&gt;explicabo&lt;/a&gt; unde natus necessitatibus esse obcaecati distinctio, aut itaque, qui vitae!&lt;/p&gt; &lt;p&gt;Aspernatur sapiente quae sint &lt;a href=&quot;&quot;&gt;soluta&lt;/a&gt; modi, atque praesentium laborum pariatur earum &lt;a href=&quot;&quot;&gt;quaerat&lt;/a&gt; cupiditate consequuntur facilis ullam dignissimos, aperiam quam veniam.&lt;/p&gt; &lt;p&gt;Cum ipsam quod, incidunt sit ex &lt;a href=&quot;&quot;&gt;tempore&lt;/a&gt; placeat maxime &lt;a href=&quot;&quot;&gt;corrupti&lt;/a&gt; possimus &lt;a href=&quot;&quot;&gt;veritatis&lt;/a&gt; ipsum fugit recusandae est doloremque? Hic, &lt;a href=&quot;&quot;&gt;quibusdam&lt;/a&gt;, nulla.&lt;/p&gt; &lt;p&gt;Esse quibusdam, ad, ducimus cupiditate &lt;a href=&quot;&quot;&gt;nulla&lt;/a&gt;, quae magni odit &lt;a href=&quot;&quot;&gt;totam&lt;/a&gt; ut consequatur eveniet sunt quam provident sapiente dicta neque quod.&lt;/p&gt; &lt;p&gt;Aliquam &lt;a href=&quot;&quot;&gt;dicta&lt;/a&gt; sequi culpa fugiat &lt;a href=&quot;&quot;&gt;consequuntur&lt;/a&gt; pariatur optio ad minima, maxime &lt;a href=&quot;&quot;&gt;odio&lt;/a&gt;, distinctio magni impedit tempore enim repellendus &lt;a href=&quot;&quot;&gt;repudiandae&lt;/a&gt; quas!&lt;/p&gt;&lt;/div&gt; 在這邊先破梗一下，類似聚光燈的白底效果，其實是靠在文件上新增一個&lt;span&gt;來達成。 ¶CSS 部分 這次的 CSS 很重要，需要稍微說明一下。 .highlight 這個 class 選擇器，是要用來加到前面說的那個&lt;span&gt;上面。 在滑鼠移動到&lt;a&gt;元素上面的時候，我們會利用 JS 取得&lt;a&gt;元素的寬、高，還有元素離視窗上方(top)、左方的距離(left)，讓&lt;span&gt;的寬、高和目前所在的&lt;a&gt;元素一致且因為設定&lt;span&gt;的position: absolute;，可以利用取得的top、left，令&lt;span&gt;和&lt;a&gt;貼在一起。 為避免&lt;span&gt;貼到和&lt;a&gt;同一個位置造成覆蓋，我們把z-index設為-1，讓&lt;a&gt;在上層而&lt;span&gt;在下層，最後設定background: white;，就會發現到&lt;span&gt;完全變成&lt;a&gt;的背景了呢~ 123456789101112.highlight &#123; transition: all 0.2s; border-bottom: 2px solid white; position: absolute; top: 0; background: white; left: 0; z-index: -1; border-radius: 20px; display: block; box-shadow: 0 0 10px rgba(0,0,0,0.2);&#125; ¶JS 部分 宣告常數triggerts用來放置所有取得的&lt;a&gt;元素(NodeList)。 宣告常數highlight用來放置我們建立的&lt;span&gt;元素。 12const triggers = document.querySelectorAll(&#x27;a&#x27;);const highlight = document.createElement(&#x27;span&#x27;); 把.highlight這個 CSS class 選擇器套用到新建的&lt;span&gt;元素，然後將其加入到body裡面 12highlight.classList.add(&#x27;highlight&#x27;);document.body.append(highlight); 我們希望在移入&lt;a&gt;時觸發事件處理函式highlightlink()，所以利用forEach()在每個&lt;a&gt;上註冊mouseenter event listener。 123function highlightLink()&#123;&#125;triggers.forEach(trigger =&gt; trigger.addEventListener(&#x27;mouseenter&#x27;,highlightLink)); 在事件處理函式highlightLink()裡，我們首先要做的就是取得先前提到滑鼠移入的那個&lt;a&gt;標籤的寬、高和它離視窗上方(top)、左方(left)的距離。 1234function highlightLink()&#123; const linkCoords = this.getBoundingClientRect(); console.log(linkCoords);&#125; Element.getBoundingClientRect() : 這個方法會回傳一個DOMRect物件，DOMRect本身是一個可以包住該元素的最小方形(包含padding、borderWidth)，而從這個物件可以得知呼叫元素的width、height、left、top、bottom等等…。 接下來，我們依序指定&lt;span&gt;元素的寬高和位置，讓它的寬高和位置與滑鼠移入的&lt;a&gt;相同。(一定要記得加上單位喔!) 1234567function highlightLink()&#123; /*上略...*/ highlight.style.width = `$&#123;linkCoords.width&#125;px`; highlight.style.height = `$&#123;linkCoords.height&#125;px`; highlight.style.top = `$&#123;linkCoords.top&#125;px`; highlight.style.left = `$&#123;linkCoords.left&#125;px`; &#125; 嗯，看起來還蠻正常的落在soluta。 (捲軸往下拉) 滑鼠一樣移到soluta，但&lt;span&gt;卻浮在更上面的位置。 會有這樣的問題出現是因為DOMRect始終是以初始視窗的左上角計算元素的top和left，當我們把捲軸往下拉，它的位置沒有加上捲軸的移動量，自然就會出現在較上方的位置。 下面我們對left、top進行修正，分別加上x和y方向的捲軸移動量，這樣就完成了。 1234567function highlightLink()&#123; /*上略...*/ highlight.style.width = `$&#123;linkCoords.width&#125;px`; highlight.style.height = `$&#123;linkCoords.height&#125;px`; highlight.style.top = `$&#123;linkCoords.top + window.scrollY&#125;px`; highlight.style.left = `$&#123;linkCoords.left + window.scrollX&#125;px`;&#125; 當然我們也可以把這些屬性值都寫到一個物件裡，再個別呼叫物件屬性。 123456789101112131415function highlightLink()&#123; /*上略...*/ const coords = &#123; width: linkCoords.width, height: linkCoords.height, top: linkCoords.top + window.scrollY, left: linkCoords.left + window.scrollX &#125; highlight.style.width = `$&#123;coords.width&#125;px`; highlight.style.height = `$&#123;coords.height&#125;px`; highlight.style.top = `$&#123;coords.top&#125;px`; highlight.style.left = `$&#123;coords.left&#125;px`; &#125; ¶補充資料: Element.getBoundingClientRect() DOMRect 今天的內容也相對簡單，相信大家都可以輕鬆愉快的學習~ ¶範例網頁請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第21天","slug":"ironman2021D21","date":"2021-09-21T07:29:06.000Z","updated":"2022-03-08T15:27:18.064Z","comments":true,"path":"2021/09/21/ironman2021D21/","link":"","permalink":"https://qi-xiang.github.io/2021/09/21/ironman2021D21/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 取得使用者的位置資訊，實作出簡易的羅盤和速度表。 ¶設定本地伺服器 這次的範例會需要取得位置的存取權限，而在取得過程必須是透過https或是localhost這類的secure origin才行，以下我們透過npm install和npm start架起自己的 little server (localhost)。 如果發現下面的指令無效的話，表示沒有安裝Node.js，可以點這邊下載 LTS 的版本，都用預設的安裝就好。 第一步 : 先移動到編輯檔案的工作目錄，接著輸入npm install，它會幫你安裝一些套件 第二步 : 輸入npm start，它會去執行package.json裡的start，開始運行一個 little server。(紅色框是目前的網頁位置) 這次不用 VisualStudio 的 Go Live Server，是因為它沒有提供 external server url，也讓行動裝置沒辦法直接用來測試。 ¶解析程式碼 ¶HTML 部分 總體而言只有兩個重點，一個是羅盤的 svg(.arrow) 圖，另一個是速度表(.speed)。 1234567&lt;svg class=&quot;arrow&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; version=&quot;1.1&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewBox=&quot;0 0 64 64&quot; enable-background=&quot;new 0 0 64 64&quot; xml:space=&quot;preserve&quot;&gt;&lt;g&gt;&lt;path fill=&quot;#ffffff&quot; d=&quot;M32,1.824C15.361,1.824,1.825,15.361,1.825,32c0,16.639,13.537,30.176,30.175,30.176 S62.175,48.639,62.175,32C62.175,15.361,48.639,1.824,32,1.824z M29.715,3.988h1.12l2.333,3.807V3.988h1.069v5.701h-1.155 l-2.298-3.718v3.718h-1.069V3.988z M9.323,33.917H8.102l-1.136-4.262l-1.132,4.262H4.587l-1.361-5.701h1.178l0.859,3.916 l1.042-3.916h1.369l0.999,3.982l0.875-3.982h1.159L9.323,33.917z M33.995,59.828c-0.181,0.285-0.438,0.497-0.77,0.636 c-0.332,0.139-0.745,0.208-1.241,0.208c-0.721,0-1.274-0.167-1.661-0.5c-0.386-0.333-0.617-0.819-0.692-1.456l1.12-0.109 c0.067,0.376,0.204,0.652,0.41,0.828c0.206,0.176,0.484,0.264,0.834,0.264c0.371,0,0.65-0.078,0.838-0.235 c0.188-0.157,0.282-0.34,0.282-0.55c0-0.135-0.04-0.25-0.119-0.344c-0.079-0.095-0.217-0.177-0.414-0.247 c-0.135-0.047-0.442-0.13-0.922-0.249c-0.617-0.153-1.05-0.341-1.299-0.564c-0.35-0.314-0.525-0.696-0.525-1.147 c0-0.29,0.082-0.562,0.247-0.815c0.165-0.253,0.402-0.445,0.712-0.577c0.31-0.132,0.684-0.198,1.122-0.198 c0.716,0,1.254,0.157,1.616,0.471c0.362,0.314,0.552,0.733,0.57,1.256l-1.151,0.051c-0.049-0.293-0.155-0.504-0.317-0.632 c-0.162-0.128-0.405-0.193-0.729-0.193c-0.334,0-0.596,0.069-0.786,0.206c-0.122,0.088-0.183,0.206-0.183,0.354 c0,0.135,0.057,0.25,0.171,0.346c0.145,0.122,0.498,0.249,1.058,0.381c0.56,0.132,0.974,0.269,1.243,0.41 c0.268,0.141,0.478,0.334,0.63,0.58c0.152,0.245,0.227,0.548,0.227,0.908C34.267,59.237,34.176,59.543,33.995,59.828z M32,52.795 c-11.466,0-20.795-9.329-20.795-20.795c0-11.466,9.329-20.795,20.795-20.795S52.795,20.534,52.795,32 C52.795,43.466,43.466,52.795,32,52.795z M55.014,33.917v-5.701h4.227v0.965h-3.076v1.264h2.862v0.96h-2.862v1.552h3.185v0.961 H55.014z&quot;/&gt;&lt;g&gt;&lt;path fill=&quot;#000000&quot; d=&quot;M48.904,31.863c-4.074-1.358-8.148-2.717-12.226-4.066c-0.265-0.087-0.399-0.223-0.486-0.486 c-1.349-4.077-2.708-8.151-4.066-12.226c-0.029-0.087-0.074-0.169-0.132-0.3c-0.054,0.152-0.09,0.245-0.122,0.34 c-1.352,4.053-2.707,8.104-4.048,12.161c-0.096,0.292-0.246,0.428-0.532,0.522c-4.056,1.342-8.108,2.696-12.16,4.049 c-0.097,0.032-0.189,0.074-0.344,0.137c0.172,0.06,0.267,0.093,0.362,0.125c4.074,1.358,8.148,2.717,12.224,4.072 c0.204,0.068,0.337,0.158,0.412,0.386c1.243,3.757,2.498,7.511,3.75,11.265c0.144,0.432,0.291,0.862,0.463,1.373 c0.068-0.185,0.108-0.285,0.142-0.386c1.349-4.042,2.701-8.083,4.04-12.128c0.094-0.284,0.231-0.438,0.523-0.534 c4.056-1.341,8.108-2.696,12.161-4.048c0.099-0.033,0.195-0.076,0.347-0.137C49.067,31.925,48.987,31.891,48.904,31.863z M37.475,32.038c-1.316,0.439-2.631,0.879-3.947,1.314c-0.095,0.031-0.139,0.081-0.17,0.173c-0.434,1.313-0.873,2.625-1.311,3.937 c-0.012,0.033-0.024,0.066-0.046,0.126c-0.056-0.166-0.104-0.306-0.15-0.446c-0.407-1.219-0.814-2.437-1.218-3.657 c-0.025-0.074-0.068-0.104-0.134-0.125c-1.323-0.44-2.646-0.881-3.968-1.322c-0.031-0.01-0.062-0.022-0.118-0.041 c0.05-0.02,0.081-0.034,0.112-0.045c1.315-0.439,2.631-0.879,3.947-1.314c0.093-0.03,0.142-0.075,0.173-0.17 c0.435-1.316,0.875-2.632,1.314-3.947c0.01-0.031,0.022-0.062,0.039-0.11c0.019,0.042,0.033,0.069,0.043,0.097 c0.441,1.323,0.882,2.645,1.321,3.969c0.028,0.085,0.072,0.129,0.158,0.158c1.324,0.438,2.646,0.879,3.969,1.32 c0.027,0.009,0.053,0.02,0.1,0.038C37.538,32.013,37.507,32.027,37.475,32.038z&quot;/&gt;&lt;path fill=&quot;#000000&quot; d=&quot;M24.436,27.633c-1.069-2.137-2.119-4.237-3.216-6.43c2.189,1.094,4.292,2.145,6.433,3.216 c-0.359,0.713-0.706,1.404-1.057,2.091c-0.023,0.045-0.078,0.082-0.127,0.106C25.807,26.949,25.143,27.28,24.436,27.633z&quot;/&gt;&lt;path fill=&quot;#000000&quot; d=&quot;M39.573,27.632c-0.696-0.348-1.351-0.673-2.002-1.005c-0.076-0.038-0.155-0.104-0.193-0.177 c-0.338-0.661-0.666-1.326-1.019-2.033c2.121-1.061,4.228-2.115,6.43-3.217C41.69,23.399,40.635,25.509,39.573,27.632z&quot;/&gt;&lt;path fill=&quot;#000000&quot; d=&quot;M24.436,36.339c0.712,0.357,1.394,0.698,2.074,1.043c0.046,0.024,0.088,0.073,0.113,0.121 c0.339,0.671,0.674,1.345,1.028,2.051c-2.126,1.063-4.232,2.117-6.43,3.216C22.317,40.577,23.37,38.472,24.436,36.339z&quot;/&gt;&lt;path fill=&quot;#000000&quot; d=&quot;M36.358,39.555c0.354-0.707,0.688-1.38,1.028-2.05c0.028-0.056,0.084-0.111,0.14-0.139 c0.67-0.339,1.343-0.674,2.047-1.026c1.066,2.131,2.118,4.235,3.215,6.43C40.601,41.676,38.503,40.628,36.358,39.555z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;h1 class=&quot;speed&quot;&gt; &lt;span class=&quot;speed-value&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;units&quot;&gt;KM/H&lt;/span&gt;&lt;/h1&gt; ¶JS 部分 宣告常數arrow用來放取得的 Svg 羅盤圖片。 宣告常數speed用來放自速度表(.speed)取得的速度(.speed-value)。 12const arrow = document.querySelector(&#x27;.arrow&#x27;);const speed = document.querySelector(&#x27;.speed-value&#x27;); Navigator.geolocation會回傳一個唯讀的 Geolocation 物件，這個物件可以被用來存取裝置的位置資訊。 Geolocation物件有一個方法watchPosition()，用來註冊使用者裝置位置更新的監聽器。我們在下面的例子傳入2個參數，分別作為成功取得位置資訊(success)和無法取得位置資訊(error)的回傳函式。 無法取得位置資訊，會拿到PositionError物件。 成功取得位置資訊的話，會拿到Position物件，這個物件的內容如下: 在Position物件的coords屬性裡面，我們可以發現包含經緯度(longitude、latitude)、定位精準度(accuracy)、移動速度(speed)還有偏離北方的度數(heading)等等…。 在成功取得位置資訊的情況下，我們把取得的Position物件(data)丟到第一個回傳函式，然後把速度表上的速度換成自位置資訊得知的速度，再把 svg 圖也旋轉自位置資訊得知的北方偏移量就完成了。 在無法取得位置資訊的情況下，我們把取得的PositionError物件(err)丟到第二個回傳函式，然後把錯誤印到 console 上並且提示使用者。 12345678navigator.geolocation.watchPosition((data)=&gt;&#123; console.log(data); speed.textContent = data.coords.speed; arrow.style.transform = `rotate($&#123;data.coords.heading&#125;deg)`; &#125;,(err) =&gt;&#123; console.err(err); alert(&#x27;Hey! You gotta allow that to happen!!!&#x27;);&#125;); 今天的內容相對前幾天的 Webcam 要來得和藹可親許多，我覺得學習像這樣用一鬆一緊的方式比較會有持續下去的動力 \\(&gt; &lt;)/ ¶補充資料: Navigator.geolocation Geolocation Geolocation.watchPosition() ¶範例網頁請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第20天","slug":"ironman2021D20","date":"2021-09-20T07:29:01.000Z","updated":"2022-03-08T15:26:58.737Z","comments":true,"path":"2021/09/20/ironman2021D20/","link":"","permalink":"https://qi-xiang.github.io/2021/09/20/ironman2021D20/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 利用 Web Speech API 取得使用者的麥克風存取權限進行語音辨識，然後把識別出的內容寫到網頁上。 ¶設定本地伺服器 跟昨天一樣，要取得使用者的媒體裝置必須是在安全連線之下(secure origin)，所以我們必須自己架一個 little server。 今天不採用 Wes Bos 用 NPM 架 Server 的方法，因為我發現只要在Visual Studio 有安裝 Live Server 這個延伸模組就可以不用安裝一些 NPM 看不懂的套件，也能達到一樣的效果。 點擊左方的方塊(延伸模組 or Extension)，然後搜尋Live Server安裝後啟用即可 打開你的網頁檔案，右下角就會有一個Go Live的按鈕，點下去就可以用localhost即時預覽網頁 這樣有比用 NPM 來得輕鬆很多吧~~~ ¶解析程式碼 ¶HTML 部分 div(.words) 用來放經過語音辨識後所產生的文字段落(&lt;p&gt;~&lt;/p&gt;)。 1&lt;div class=&quot;words&quot; contenteditable&gt;&lt;/div&gt; ¶JS 部分 SpeechRecognition本身是一個在 browser 之下的 global variable，但是因為瀏覽器支援性的問題，我們在 Chrome 必須使用帶有前綴字的webkitSpeechRecognition。 1window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; 首先建立一個SpeechRecognition物件recognition來幫我們做語音辨識。 設定SpeechRecognition物件的屬性interimResults為 true，它就會將現在辨識到的所有內容都回傳，如果是 false 的話，則只有停止說話才回傳內容。 設定SpeechRecognition物件的屬性lang為en-US，表示要辨識的語言是英文。 123const recognition = new SpeechRecognition();recognition.interimResults = true;recognition.lang = &#x27;en-US&#x27;; 建立&lt;p&gt;標籤用來放入辨識出的文字內容。 宣告常數words並取得 div(.words)。 words.appendChild(p);，將&lt;p&gt;標籤的文字段落放到div(.words)裡面，換句話說就是把辨識出的內容先放到&lt;p&gt;再放到&lt;div class=&quot;words&quot;&gt;裡面。 123let p = document.creatElement(&#x27;p&#x27;);const words = document.querySelector(&#x27;.words&#x27;);words.appendChild(p); 替SpeechRecognition物件recognition註冊result event的監聽器，如果有回傳result就觸發事件，然後把這個Speech Recognition Event印到 console，觀察後你會發現我們需要用到的東西是放在‵e.results這個 lsit 裡面。 recognition.start();開始語音識別，原則上只會識別一次，當停止說話一段時間即停止。 1234567recognition.addEventListener(&#x27;result&#x27;,e=&gt;&#123; console.log(e); //log speech recognition event console.log(e.results); debugger; //breakpoint&#125;);recognition.start(); SpeechRecognitionEvent SpeechRecognitionEvent.results 其中 results[0] 隱含一些必要資訊，包括語音辨識出的內容(transcript)和是否已經停止辨識(isFinal)。 宣告常數transcript並透過兩次map取得results[0].transcript也就是語音辨識出的內容。 因為results本身不是 Array 不能用 map()，所以先用Array.from()換成 Array。 第一次的 map() 取的 results[0] 所構成的陣列，第二次 map() 取得 results[0] 內部 transcript 所構成的陣列，最後將陣列內的元素 transcript 用join()串成一個大字串。 p.textContent = transcript;，將這次辨識出的所有內容放到&lt;p&gt;標籤裡面。 12345678recognition.addEventListener(&#x27;result&#x27;,e=&gt;&#123; /*上略...*/ const transcript = Array.from(e.results) .map(result =&gt; result[0]) .map(result =&gt; result.transcript).join(&#x27;&#x27;); p.textContent = transcript; // will be overwrite&#125;); 在第一次語音辨識結束之後，接下來它不會主動開始下一次的語音辨識。 我們可以在recognition註冊end event，當語音辨識結束就觸發下一次語音辨識開始(recognition.start)。 1recognition.addEventListener(&#x27;end&#x27;,recognition.start); 目前為止我們還有一個問題沒有解決，就是在每一次的語音辨識的過程，&lt;p&gt;標籤會不斷被覆寫，因為我們沒有為每一次的語音辨識建立自己的&lt;p&gt;標籤，一直都是在改原來的那個。 下面我們用 if 判斷當這次的語音辨識結束，就新增一個新的&lt;p&gt;標籤到&lt;div class=&quot;words&quot;&gt;上，這樣就不會有覆寫的狀況。 1234567recognition.addEventListener(&#x27;result&#x27;,e=&gt;&#123; /*上略...*/ if(e.results[0].isFinal)&#123; p = document.createElement(&#x27;p&#x27;); words.appendChild(p); &#125;&#125;); 最後，我們還可以加點有趣的東西，當語音辨識到特定內容，就在 console 上印出提示。 12345678recognition.addEventListener(&#x27;result&#x27;,e=&gt;&#123; //上略...// if(transcript.includes(&#x27;rainning day&#x27;))&#123; console.log(&#x27;It is a bad weather.&#x27;); &#125; console.log(transcript);&#125;); ¶補充資料: 使用 Web Speech API SpeechRecognition ¶範例網頁請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第19天","slug":"ironman2021D19","date":"2021-09-19T07:28:54.000Z","updated":"2022-03-08T15:26:50.143Z","comments":true,"path":"2021/09/19/ironman2021D19/","link":"","permalink":"https://qi-xiang.github.io/2021/09/19/ironman2021D19/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 取得使用者的鏡頭影像，藉此實作出網頁版的相機以及影像濾鏡效果。 ¶設定本地伺服器 這次的範例會需要取得鏡頭的存取權限，而在取得過程必須是透過https或是localhost這類的secure origin才行，以下我們透過npm install和npm start架起自己的 little server (localhost)。 如果發現下面的指令無效的話，表示沒有安裝Node.js，可以點這邊下載 LTS 的版本，都用預設的安裝就好。 第一步 : 先移動到編輯檔案的工作目錄，接著輸入npm install，它會幫你安裝一些套件 第二步 : 輸入npm start，它會去執行package.json裡的start，開始運行一個 little server。(紅色框是目前的網頁位置) ¶解析程式碼 ¶HTML 部分 div(.controls) : 裡面放置用來拍照的按鈕和調整綠幕效果的按鈕。 canvas(.photo) : 用來放入鏡頭的影像，之後會搭配一些濾鏡。 video(.player) : 固定在右上角的小影像視窗。 div(.strip) : 用來放入擷取下來的圖片。 audio(.snap) : 放入按下拍照按鈕時要撥放的音效。 12345678910111213141516171819202122232425262728293031&lt;div class=&quot;photobooth&quot;&gt; &lt;div class=&quot;controls&quot;&gt; &lt;button onClick=&quot;takePhoto()&quot;&gt;Take Photo&lt;/button&gt; &lt;div class=&quot;rgb&quot;&gt; &lt;label for=&quot;rmin&quot;&gt;Red Min:&lt;/label&gt; &lt;input type=&quot;range&quot; min=0 max=255 name=&quot;rmin&quot;&gt; &lt;label for=&quot;rmax&quot;&gt;Red Max:&lt;/label&gt; &lt;input type=&quot;range&quot; min=0 max=255 name=&quot;rmax&quot;&gt; &lt;br&gt; &lt;label for=&quot;gmin&quot;&gt;Green Min:&lt;/label&gt; &lt;input type=&quot;range&quot; min=0 max=255 name=&quot;gmin&quot;&gt; &lt;label for=&quot;gmax&quot;&gt;Green Max:&lt;/label&gt; &lt;input type=&quot;range&quot; min=0 max=255 name=&quot;gmax&quot;&gt; &lt;br&gt; &lt;label for=&quot;bmin&quot;&gt;Blue Min:&lt;/label&gt; &lt;input type=&quot;range&quot; min=0 max=255 name=&quot;bmin&quot;&gt; &lt;label for=&quot;bmax&quot;&gt;Blue Max:&lt;/label&gt; &lt;input type=&quot;range&quot; min=0 max=255 name=&quot;bmax&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;canvas class=&quot;photo&quot;&gt;&lt;/canvas&gt; &lt;video class=&quot;player&quot;&gt;&lt;/video&gt; &lt;div class=&quot;strip&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;audio class=&quot;snap&quot; src=&quot;./snap.mp3&quot; hidden&gt;&lt;/audio&gt; ¶JS 部分 老樣子，我們要先取得所有要用到的元素。 .player 是小鏡頭畫面。 canvas 是可以套上濾鏡的大鏡頭畫面。 ctx 是canvas的渲染環境。 strip 是放照片的容器。 snap 是拍照的音效。 12345const video = document.querySelector(&#x27;.player&#x27;);const canvas = document.querySelector(&#x27;.photo&#x27;);const ctx = canvas.getContext(&#x27;2d&#x27;);const strip = document.querySelector(&#x27;.strip&#x27;);const snap = document.querySelector(&#x27;.snap&#x27;); ¶先來處理取得鏡頭影像的部分 : navigator.mediaDevices.getUserMedia()，用來取得使用者的媒體裝置，因為我們只需要取得影像，所以指定&#123;video:true,audio:false&#125;不存取音訊，最後回傳一個Promise。 我們用then()繼續進行處理，因為不能直接將取得的MediaStream指定為video的來源(它看不懂QQ)，還需要透過window.URL.createObjectURL()把MediaStream換成video可以理解的URL，然後video.play()開始播放影像。 到這邊，我們還需要用catch()來處理例外發生的狀況，當無法順利取得媒體裝置或是媒體裝置不存在，就會在 console 上印出錯誤訊息。 12345678910111213function getVideo()&#123; navigator.mediaDevices.getUserMedia(&#123;video:true,audio:false&#125;) .then(localMediaStream =&gt; &#123; console.log(localMediaStream); video.src = window.URL.createObjectURL(localMediaStream); video.play(); &#125;) .catch(err =&gt; &#123; console.log(`OH NO!!!`,err); &#125;);&#125;getVideo(); ¶把影像放到畫布(canvas)上 : 為了讓畫布的大小和取得的影像大小一致，使用 video.videoWidth、video.videoHeight取得影像的寬、長，然後修改畫布的寬(canvas.width)、長(canvas.height)。 setInterval()，設定每隔一段時間就把影像更新到畫布(這邊是設定16毫秒)。 ctx.drawImage()，把影像畫到畫布(canvas)上。 video.addEventListener('canplay',paintToCanvas)，如果影像現在是可以正常播放的話，就持續將影像輸出到畫布上。 123456789101112function paintToCanvas()&#123; const width = video.videoWidth; const height = video.videoHeight; canvas.width = width; canvas.height = height; setInterval(() =&gt;&#123; ctx.drawImage(video,0,0,width,height); &#125;,16);&#125;video.addEventListener(&#x27;canplay&#x27;,paintToCanvas); ¶按下Take Photo時的快門音效、把擷取下來的圖片放入strip內供下載 : snap.currentTime = 0，確保每一次都是從頭開始播放音效，snap.play()開始播放。 canvas.toDataURL('image/jpeg')將canvas上的影像轉換成image/jpeg格式的URL檔案連結。 const link = document.createElement('a')，在文件上新增一個&lt;a&gt;標籤。 link.href = data，將標籤連結指定為取得的影像圖檔連結。 link.setAttribute('download','handsome')，設定這個連結是可被點擊下載，同時下載的檔案名稱為handsome。 link.innerHTML = &lt;img src=&quot;$&#123;data&#125;&quot; alt=&quot;handsome man&quot; /&gt;，在&lt;a&gt;內部放入我們取得的圖片，現在只要點擊圖片就會把圖片下載下來。 strip.insertBefore(link,strip.firstChild)，將整個&lt;a&gt;&lt;img&gt;&lt;/a&gt;(擷取的影像圖)插入到.strip裡面並且是第一個位置。 1234567891011121314function takePhoto()&#123; //Play the sound snap.currentTime = 0; snap.play(); const data = canvas.toDataURL(&#x27;image/jpeg&#x27;); console.log(data); const link = document.createElement(&#x27;a&#x27;); link.href = data; link.setAttribute(&#x27;download&#x27;,&#x27;handsome&#x27;); //link.textContent = &#x27;Download Image&#x27;; link.innerHTML = `&lt;img src=&quot;$&#123;data&#125;&quot; alt=&quot;handsome man&quot; /&gt;`; strip.insertBefore(link,strip.firstChild);&#125; ¶影像的濾鏡效果 : 不同的濾鏡效果其實只是將CanvasRenderingContext2D.getImageData()取得的畫布像素(pixels)數據以每四個為一組(R-G-B-A)的方式修改，然後再將修改完的像素用CanvasRenderingContext2D.putImageData()放回畫布。 1. 紅色濾鏡 增強紅色並減弱綠、藍色 12345678function redEffect(pixels)&#123; for(let i=0;i &lt; pixels.data.lenght;i+=4)&#123; pixels.data[i + 0] = pixels.data[i + 0] + 100;// R pixels.data[i + 1] = pixels.data[i + 0] - 50;// G pixels.data[i + 2] = pixels.data[i + 0] * 0.5;// B &#125; return pixels;&#125; 2. 色彩分離 實際上是讓色板產生位移 (這部分不太好理解@@) 12345678function rgbSplit(pixels)&#123; for(let i=0;i &lt; pixels.data.lenght;i+=4)&#123; pixels.data[i - 150] = pixels.data[i + 0];// R pixels.data[i + 500] = pixels.data[i + 0];// G pixels.data[i - 550] = pixels.data[i + 0];// B &#125; return pixels;&#125; 3. 綠幕 讓一定數值範圍內的 R、G、B 消失。 建立一個空物件levels，接著放入每一個 range 的名稱和數值。 以每四個為一組的方式取得畫布像素的 R、G、B 數值，接著把顏色進行比對，舉紅色為例，如果像素的 R 值處在 rmin 和 rmax 之間，就把該像素的透明度設定為0(在畫面上消失)。 1234567891011121314151617181920212223242526function greenScreen(pixels) &#123; const levels = &#123;&#125;; document.querySelectorAll(&#x27;.rgb input&#x27;).forEach((input) =&gt; &#123; levels[input.name] = input.value; &#125;); for (i = 0; i &lt; pixels.data.length; i = i + 4) &#123; red = pixels.data[i + 0]; green = pixels.data[i + 1]; blue = pixels.data[i + 2]; alpha = pixels.data[i + 3]; if (red &gt;= levels.rmin &amp;&amp; green &gt;= levels.gmin &amp;&amp; blue &gt;= levels.bmin &amp;&amp; red &lt;= levels.rmax &amp;&amp; green &lt;= levels.gmax &amp;&amp; blue &lt;= levels.bmax) &#123; // take it out! pixels.data[i + 3] = 0; &#125; &#125; return pixels; &#125; ¶套用濾鏡 : (以套用紅色濾鏡為例，其他濾鏡也是同理) 12345678910111213141516171819function paintToCanvas()&#123; const width = video.videoWidth; const height = video.videoHeight; canvas.width = width; canvas.height = height; return setInterval(() =&gt;&#123; ctx.drawImage(video,0,0,width,height); //take the pixels out let pixels = ctx.getImageData(0,0,width,height); //mass with them pixels = redEffect(pixels); //put them back ctx.putImageData(pixels,0,0); &#125;,16);&#125; 這次的練習是目前為止最複雜的，連我自己本身也花了非常多的時間查資料，但仍然沒有辦法把細節交代清楚。 所以大家可能要多花些精力在學習這次的課程內容上，大家加油~~~ ¶補充資料: Enabling the Microphone/Camera in Chrome for (Local) Unsecure Origins Navigator Navigator.mediaDevices MediaDevices.getUserMedia() URL.createObjectURL() CanvasRenderingContext2D.drawImage() HTMLCanvasElement.toDataURL() Document.createElement() HTMLMediaElement Element.setAttribute() Node.insertBefore() debugger CanvasRenderingContext2D.putImageData() CanvasRenderingContext2D.getImageData() ¶範例網頁請點此 ps. 這次的網頁比較特殊，如果打開鏡頭仍然無法看到效果的話，可能就要自己 fork 程式碼到本地端測試~","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第18天","slug":"ironman2021D18","date":"2021-09-18T07:08:37.000Z","updated":"2022-03-08T15:26:42.359Z","comments":true,"path":"2021/09/18/ironman2021D18/","link":"","permalink":"https://qi-xiang.github.io/2021/09/18/ironman2021D18/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 今天也是複習回，主要是拿來重新複習下 Array 的map()和reduce()的用法。我們的最終目標是算出影片的長度總和並以時、分、秒呈現在 console裡。 ¶解析程式碼 ¶HTML 部分 以下是我們要用來計算影片總時數的清單，其中data-time屬性值標示出影片的長度。 123456789101112131415161718&lt;ul class=&quot;videos&quot;&gt; &lt;li data-time=&quot;5:43&quot;&gt; Video 1 &lt;/li&gt; &lt;li data-time=&quot;2:33&quot;&gt; Video 2 &lt;/li&gt; &lt;li data-time=&quot;3:45&quot;&gt; Video 3 &lt;/li&gt; &lt;li data-time=&quot;0:47&quot;&gt; Video 4 &lt;/li&gt; &lt;li data-time=&quot;5:21&quot;&gt; Video 5 &lt;/li&gt; &lt;!--以下省略--&gt;&lt;ul&gt; ¶JS 部分 一開始，我們宣告常數timeNodes用來放我們取得的所有清單項目(&lt;li&gt;~&lt;/li&gt;)，因為之後會用到 Array 的reduce()、map()，這裡就順便把NodeList用Array.from()轉換成 Array。 1const timeNodes = Array.from(document.querySelectorAll(&#x27;[data-time]&#x27;)); 宣告常數seconds存入所有影片的秒數總和。 第一個map()幫我們取得個別影片時間所構成的陣列(分:秒)。 第二個map()幫我們把影片時間的分和秒切開(間隔符號:)，第三個map()幫我們把陣列中的元素都轉換成浮點數，最後把影片的長度都換成秒(mins * 60 + secs)。 把影片長度都換成以秒為單位後，就可以用reduce()將它們加在一起囉! 1234567const seconds = timeNodes .map(node =&gt; node.dataset.time) .map(timeCode =&gt; &#123; const [mins, secs] = timeCode.split(&#x27;:&#x27;).map(parseFloat); return (mins * 60) + secs; &#125;) .reduce((total, vidSeconds) =&gt; total + vidSeconds); 第一次map()後產生的陣列 第二、三次map()後產生的陣列 所有影片長度的秒數總和 接下來，把得到的總秒數換成時、分、秒的形式就完成本日的目標囉! 123456789let secondsLeft = seconds;//Math.floor() 回傳小於等於所給數字的最大整數const hours = Math.floor(secondsLeft / 3600);secondsLeft = secondsLeft % 3600;const mins = Math.floor(secondsLeft / 60);secondsLeft = secondsLeft % 60;console.log(hours, mins, secondsLeft); ¶補充資料: Array.from() parseFloat() Array.prototype.map() Array.prototype.reduce() Math.floor()","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第17天","slug":"ironman2021D17","date":"2021-09-17T07:08:32.000Z","updated":"2022-03-08T15:26:34.035Z","comments":true,"path":"2021/09/17/ironman2021D17/","link":"","permalink":"https://qi-xiang.github.io/2021/09/17/ironman2021D17/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 將陣列元素拿掉冠詞再進行排序，然後個別轉成 HTML 的格式放入清單中。(今天是複習回，相信只要有認真學習前面的課程內容，一定可以輕鬆完成的!!!) ¶解析程式碼 ¶HTML 部分 嗯，就是一個空的清單。 1&lt;ul id=&quot;bands&quot;&gt;&lt;/ul&gt; ¶JS 部分 (ps. 這次基本上都是在複習之前Array的東西，所以就不再贅述Array方法的運用) 我們要拿來做排序的陣列bands。 1const bands = [&#x27;The Plot in You&#x27;, &#x27;The Devil Wears Prada&#x27;, &#x27;Pierce the Veil&#x27;, &#x27;Norma Jean&#x27;, &#x27;The Bled&#x27;, &#x27;Say Anything&#x27;, &#x27;The Midway State&#x27;, &#x27;We Came as Romans&#x27;, &#x27;Counterparts&#x27;, &#x27;Oh, Sleeper&#x27;, &#x27;A Skylit Drive&#x27;, &#x27;Anywhere But Here&#x27;, &#x27;An Old Dog&#x27;]; 依照陣列元素的字母順序排列。 1234567const sortedBands = bands.sort((a,b) =&gt; &#123; if(a &gt; b)&#123; return 1; &#125;else&#123; return -1; &#125;&#125;); 我們希望去掉冠詞(articles)後再做排序，所以撰寫strip()用來去掉冠詞。 replace(/^(a |the |an )/i, ''): 將陣列元素的冠詞(不分大小寫)以空白取代。 trim() : 去掉字串兩邊的空白。 123function strip(bandName)&#123; return bandName.replace(/^(a |the |an )/i, &#x27;&#x27;).trim();&#125; 改成去掉冠詞再排序: 1234567const sortedBands = bands.sort(function(a,b)&#123; if(strip(a) &gt; strip(b))&#123; return 1; &#125;else&#123; return -1; &#125;&#125;); 精簡一點的寫法: 123const sortedBands = bands.sort((a,b) =&gt; &#123; return strip(a) &gt; strip(b) ? 1 : -1;&#125;); 將排序過的陣列元素轉換成 HTML 格式放入清單(#bands)作為其中的項目。 1document.querySelector(&#x27;#bands&#x27;).innerHTML = sortedBands.map(band =&gt; `&lt;li&gt;$&#123;band&#125;&lt;/li&gt;`); 這個時候打開瀏覽器，我們會發現好像有那裡怪怪的，清單項目之前怎麼有的會有逗號(,)呢? 那是因為我們放進去的是被用toString()先轉型過後的字串，但原本陣列元素之間就有用逗號(,)作為間隔符號，在轉型後雖然去掉[]，但是逗號(,)依然還在，也就這樣被放進去了。 我們可以用老方法join()幫我們先把陣列元素以空白作為間隔符號串聯成字串再放進去#band的innerHTML，這樣逗號就消失啦。 1document.querySelector(&#x27;#bands&#x27;).innerHTML = sortedBands.map(band =&gt; `&lt;li&gt;$&#123;band&#125;&lt;/li&gt;`).join(&quot;&quot;); 今天的內容基本上是在複習之前學過的東西，觀看 JS30 的教學影片時，可以考慮暫停影片，自己練習看看喔! ¶補充資料: Array.prototype.sort() Array.prototype.map() String.prototype.replace() String.prototype.trim() Array.prototype.join() Template literals ¶範例網頁請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第16天","slug":"ironman2021D16","date":"2021-09-16T07:08:27.000Z","updated":"2022-03-08T15:26:26.265Z","comments":true,"path":"2021/09/16/ironman2021D16/","link":"","permalink":"https://qi-xiang.github.io/2021/09/16/ironman2021D16/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 讓文字陰影跟著滑鼠一起移動。 ¶解析程式碼 ¶HTML 部分 在.hero內放入我們預計要用來產生文字陰影(Text Shadow)效果的文字(h1)。 h1上有一個特殊的屬性:contenteditable，表示&lt;h1&gt;&lt;/h1&gt;之間的內容是可以被修改的。 123&lt;div class=&quot;hero&quot;&gt; &lt;h1 contenteditable&gt;🔥WOAH!&lt;/h1&gt;&lt;/div&gt; &lt;h1&gt;&lt;/h1&gt;之間的內容可被修改如下: 修改前 修改後 ¶JS 部分 在實作文字陰影效果之前，我們要先取得.hero和內部的h1。 12const hero = document.querySelector(&#x27;.hero&#x27;);const text = hero.querySelector(&#x27;h1&#x27;); 由於我們的目的是產生文字陰影隨著滑鼠移動的效果，所以在.hero上註冊mousemove 事件的監聽器並以shadow()進行事件處理。 1hero.addEventListener(&#x27;mousemove&#x27;,shadow); ¶shadow() : const &#123; offsetWidth: width, offsetHeight: height&#125; = hero; : 最初，我們必須先取得.hero的width、height，用來計算後續文字陰影的移動量。 let &#123; offsetX: x, offsetY: y&#125; = e; : 我們也必須知道現在滑鼠所在的座標。 注意，這裡我們使用的是 ES6 Destructuring Assignment(解構賦值)的語法所以不使用像是const width = hero.offsetWidth;、const height = hero.offsetHeight;這種較繁瑣的寫法。 12345678910function shadow(e)&#123; //const width = hero.offsetWidth; //const height = hero.offsetHeight; const &#123; offsetWidth: width, offsetHeight: height&#125; = hero; //where the person&#x27;s cursor was //let x = e.offsetX; //let y = e.offsetY; let &#123; offsetX: x, offsetY: y&#125; = e;&#125; 因為event.offsetX、event.offsetY取得的是滑鼠相對於事件源元素（srcElement）的X,Y坐標，所以當我們把滑鼠移動到h1得到的座標就會是以h1的左上角為(0,0)開始的位置。 這樣的位置是有問題的，我們原本要取得的應該是滑鼠在視窗裡面的位置(或說是滑鼠相對.hero的位置)，所以必須要做一點修正。 我們在觸發mousemove event的 DOM 物件不是.hero的情況下(this !== e.target)進行座標修正，只要滑鼠處於h1內部，就分別把(x,y)加上h1相對.hero左方和上方的距離。 12345678function shadow(e)&#123; /*上略...*/ //if hovering h1 instead of hero, then modify the x and the y values if (this !== e.target)&#123; x = x + e.target.offsetLeft; y = y + e.target.offsetTop; &#125;&#125; 接下來，我們要決定文字陰影實際上可以移動的距離和範圍。 宣告常數walk作為在(x,y)方向所能移動的最遠距離，這裡我們設為500，也就是向左或向右各250、向上或向下各250。 const xWalk = Math.round((x / width * walk) - (walk / 2));，把.hero的中心點x 座標指定為0，x的範圍從-250~250(視窗最左邊到最右邊)。 const yWalk = Math.round((y / height * walk) - (walk / 2));，把.hero的中心點y 座標指定為0，y的範圍從-250~250(視窗最上面到最下面)。 結合兩者，畫面上的座標 : 左上角(-250,-250)、正中央(0,0)、右下角(250,250)。 12345678const walk = 500;function shadow(e)&#123; /*上略...*/ //how far the text shadow should actually go const xWalk = Math.round((x / width * walk) - (walk / 2)); const yWalk = Math.round((y / height * walk) - (walk / 2));&#125; TextShadow能移動的範圍 (以walk = 500為例) 決定TextShadow可以移動的範圍後，接下來只要設定TextShadow的移動方向和顏色就完成囉! 123456789function shadow(e)&#123; /*上略...*/ text.style.textShadow = ` $&#123;xWalk&#125;px $&#123;yWalk&#125;px 0 rgba(255,0,255,0.7), $&#123;xWalk * -1&#125;px $&#123;yWalk&#125;px 0 rgba(0,255,255,0.7), $&#123;yWalk&#125;px $&#123;xWalk * -1&#125;px 0 rgba(0,255,0,0.7), $&#123;yWalk * -1&#125;px $&#123;xWalk&#125;px 0 rgba(0,0,255,0.7) `;&#125; ¶補充資料: contenteditable [筆記] ES6: Destructuring Assignment 解構賦值的使用 JS一秒區分clientX,offsetX,screenX,pageX之間關係 ¶範例網頁請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第15天","slug":"ironman2021D15","date":"2021-09-15T07:08:22.000Z","updated":"2022-03-08T15:26:18.855Z","comments":true,"path":"2021/09/15/ironman2021D15/","link":"","permalink":"https://qi-xiang.github.io/2021/09/15/ironman2021D15/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 將被新增到menu的項目儲存到localStorage中，使得後續刷新頁面時，可以從localStorage調用資料回復之前新增在menu的項目。 ¶解析程式碼 ¶HTML 部分 最外層的.wrapper代表的是整個的 menu，.plates則用來放入 menu 的內容項目。最後，.add-items是一個表單元素，裡面有一個文字輸入框(&lt;input type=&quot;text&quot;&gt;&lt;/input&gt;)用來填入要新增的項目名稱，還有一個用來加入項目到 menu 的 submit button(&lt;input type=&quot;submit&quot;&gt;&lt;/input&gt;)。 1234567891011&lt;div class=&quot;wrapper&quot;&gt; &lt;h2&gt;LOCAL TAPAS&lt;/h2&gt; &lt;p&gt;&lt;/p&gt; &lt;ul class=&quot;plates&quot;&gt; &lt;li&gt;Loading Tapas...&lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;add-items&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;item&quot; placeholder=&quot;Item Name&quot; required&gt; &lt;input type=&quot;submit&quot; value=&quot;+ Add Item&quot;&gt; &lt;/form&gt;&lt;/div&gt; ¶JS 部分 宣告常數addItems用來存放取得的整個 menu(.add-items)。 宣告常數itemsList用來存放 menu 裡的所有項目(.plates)。 宣告常數items為一個空陣列，用來存放我們每次在文字輸入框填入要新增到 menu 的 item。 123const addItems = document.querySelector(&#x27;.add-items&#x27;);const itemsList = document.querySelector(&#x27;.plates&#x27;);const items = []; ¶addItem() : 我們首先用e.preventDefault()避免每次提交新的內容進入items造成頁面的 reloading。 宣告常數text用來存放在文字輸入框填入的項目名稱。 建立物件item並賦予兩個屬性text(項目的名稱)、done(是否被勾選)，這裡我們原本可以用text:text;，但在 ES6 裡可以被簡寫為text。 將建立出的物件放入(push)陣列items中，之後用this.reset()清掉在文字輸入框的文字以利下一次新增項目。 123456789101112function addItem(e)&#123; e.preventDefault();//prevent page from reloading const text = this.querySelector(&#x27;[name=&quot;item&quot;]&#x27;).value; const item = &#123; text, //text: text done: false &#125; items.push(item); this.reset(); //form element clear the input&#125;addItems.addEventListener(&#x27;submit&#x27;,addItem); ¶populateList(): 用來將items裡所有的item逐一轉換成 HTML 的格式，藉此更新 menu 上的項目。 透過map()將陣列中的item(方法裡用plate代稱)，逐一用&lt;li&gt;~&lt;li&gt;的格式重新組合成一個有checkBox可以勾選的列表項目。 因為map()回傳的是一個陣列，所以在最後用join()將陣列中的元素以空白作為間隔符號串聯成一個 HTML 格式的字串並修改列表(ul)裡的項目內容(innerHTML)。 1234567891011//create the actual html here function populateList(plates = [], platesList)&#123; //plates default: empty, prvent to crash javascript if you forget to pass it platesList.innerHTML = plates.map((plate,i) =&gt;&#123; //i: index return ` &lt;li&gt; &lt;input type=&quot;checkbox&quot; data-index=$&#123;i&#125; id=&quot;item$&#123;i&#125;&quot; $&#123;plate.done ? &#x27;checked&#x27; : &#x27;&#x27;&#125;&gt; &lt;label for=&quot;item$&#123;i&#125;&quot;&gt;$&#123;plate.text&#125;&lt;/label&gt; &lt;/li&gt; `; &#125;).join(&#x27;&#x27;); &#125; JS 的部分完成到這裡，基本上就可以將新建立的項目放到 menu 中。 但是將網頁重新整理(F5)，我們可以發現原來放到 menu 中的東西都不見了。那要怎麼保留我們之前在 menu 放入的項目呢? 相信 localStorage 可以幫我們這個忙。 ¶Window.localStorage localStorage 允許我們存取目前文件(Document)隸屬網域來源的Storage 物件，簡單來說我們可以用key-value(鍵-值)的方式來存取這個Storage物件的資料，localStorage存放的資料是沒有時間限制的(不會關閉網頁就不見)。另外，這邊的鍵-值都是以字串型態存放。 實際在localStorage放資料(localStorage.setItem()): 1localStorage.setItem(&#x27;myCat&#x27;, &#x27;Tom&#x27;); 打開檢查模式，查看我們放的資料(Application -&gt; Local Storage): 資料真的被放到 Local Storage 裡面了，我們之後就可以用 Local Storage 的方法調用這些已存的資料。 ¶用 localStorage 存取資料 items : 我們原本宣告常數items為一個空陣列，但是我們也可以改成如果localStorage有資料(localStorage.getItem('items'))就將其放入items。要注意localStorage放的資料是字串型態，所以還要藉助JSON.parse()把它還原成物件再傳遞給items。 addItem() : 每一次加入新的item到items，我們都需要同時更新現在menu的項目內容，所以我們在方法裡面加上populateList(items,itemsList);。 localStorage.setItem('items',JSON.stringify(items));用來把我們新增的item存進localStorage保存新增在menu的項目。要注意items本身是物件型別(Object)，所以要先用JSON.stringify()將其轉換成字串再存入localStorage。 12345678const items = JSON.parse(localStorage.getItem(&#x27;items&#x27;)) || []; // dump data from localstorage if existed function addItem(e)&#123; /*上略*/ populateList(items,itemsList); localStorage.setItem(&#x27;items&#x27;,JSON.stringify(items)); /*下略...*/ &#125; 只要做到這裡，之前加入到menu的item就不會在重新整理網頁的時候消失不見，每次都會從localStorage取得之前的資料(如果有資料的話)。 但這樣好像還是少了什麼，如果我們將checkBox勾起來再去重新整理網頁，就會發現checkBox又回到沒勾選的狀態。要儲存checkBox的勾選狀態，我們可以用另一個方法toggleDone()來處理。 toggleDone() : Event.target 指向最初觸發事件的 DOM 物件。 if(!e.target.matches('input')) return;，如果觸發事件的 DOM 物件不是input element的話，就停止繼續執行。 宣告常數el存放觸發事件的 DOM 物件。 宣告常數index存放觸發事件的 DOM 物件的data-index屬性。 items[index].done = !items[index].done;，讓觸發事件的 DOM 物件的done變為相反值(true to false；false to true)，前面我們在populateList()裡設定item (plate)的done屬性是true就將checkBox打勾(checked)。($&#123;plate.done ? 'checked' : ''&#125;) 最後我們需要將變更後的items再次的放入localStorage中，要注意先用JSON.stringify()轉換成字串再放入，接著用populateList()去更新現在menu的內容就完成了。 12345678910function toggleDone(e)&#123; if(!e.target.matches(&#x27;input&#x27;)) return; const el = e.target; const index = el.dataset.index; items[index].done = !items[index].done; localStorage.setItem(&#x27;items&#x27;,JSON.stringify(items)); populateList(items,itemsList);&#125;itemsList.addEventListener(&#x27;click&#x27;,toggleDone); 1234567891011//create the actual html herefunction populateList(plates = [], platesList)&#123; //plates default: empty, prvent to crash javascript if you forget to pass it platesList.innerHTML = plates.map((plate,i) =&gt;&#123; //i: index return ` &lt;li&gt; &lt;input type=&quot;checkbox&quot; data-index=$&#123;i&#125; id=&quot;item$&#123;i&#125;&quot; $&#123;plate.done ? &#x27;checked&#x27; : &#x27;&#x27;&#125;&gt; &lt;label for=&quot;item$&#123;i&#125;&quot;&gt;$&#123;plate.text&#125;&lt;/label&gt; &lt;/li&gt; `; &#125;).join(&#x27;&#x27;);&#125; ¶補充資料: Array.prototype.map() Window.localStorage Storage Event.target Event Delegation — 事件委派介紹 與 觸發委派的回呼函數 ¶範例網頁請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第14天","slug":"ironman2021D14","date":"2021-09-14T07:08:17.000Z","updated":"2022-03-08T15:26:11.116Z","comments":true,"path":"2021/09/14/ironman2021D14/","link":"","permalink":"https://qi-xiang.github.io/2021/09/14/ironman2021D14/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 瞭解 JavaScript 的 Passed by Value 和 Passed by Reference 以及 Object 的 shallow copy 和 deep copy。 ¶解析程式碼 ¶JS 部分 ¶Passed by Value 在 JavaScript 裡，如果變數的資料型態屬於 Primitive(原生型別)，則在傳遞變數時，採用的是 Passed by Value (傳遞值)。 ¶常見的 Primitive: String Number BigInt Boolean Symbol 在下面的兩個例子，我們分別將age、name傳遞給age2、name2，之後改變age2、name2的數值。結果原本的age、name均不會受到影響，因為在傳遞過程是 Passed by Value，將原本存於age、name的值複製一份給age2、name2。 123456let age = 100;let age2 = age;console.log(age,age2);age = 200;console.log(age,age2); 123456let name = &#x27;Mes&#x27;;let name2 = name;console.log(name,name2);name = &#x27;wesley&#x27;;console.log(name,name2); 簡易概念圖 ¶Passed by Reference 在 JavaScript 裡，如果變數的資料型態屬於 Object(物件型別)，則在傳遞變數時，採用的是 Passed by Reference (傳遞位址)。 常見的 Object: Array Object 下面的例子，我們將陣列 players 傳遞給常數 team，之後將team[3](Poppy)改成Lux，再把兩個陣列都印到 console，會發現到兩個陣列的第四個位置都被修改成新的值(Lux)。 這是因為物件在傳遞的過程中採取的是 Passed by Reference，也就是將物件在記憶體上的位置傳遞給另一個物件(兩者共享同一個記憶體位置)，所以只要更改其中一方，另一方也會受到影響。 123456const players = [&#x27;Wes&#x27;,&#x27;Sarah&#x27;,&#x27;Ryan&#x27;,&#x27;Poppy&#x27;];const team = players;console.log(players,team); team[3] = &#x27;Lux&#x27;;console.log(players,team); 如果想修改陣列的值又不影響另一個陣列的話，我們可以使用slice()來複製陣列並回傳新陣列(擁有自己的記憶體空間)。 下面的例子，我們呼叫players.slice()將陣列players完整的複製一份到新陣列中並傳遞給team2，之後再修改team2的第四個位置，這次我們發現到原來的陣列players並沒有被修改到。 注意:slice()進行的是shallow copy(淺複製)!!! 1234const team2 = players.slice()team2[3] = &#x27;Lux&#x27;;console.log(players,team2) 其他修改陣列的值又不影響另一個陣列的方法有: concat() : 將多個陣列進行串聯和slice()一樣會回傳串聯後的新陣列。 Spread : 將陣列中的元素展開並逐個放到新陣列中。 Array.from() : 建立一個新的 Array 實體。 123456const team3 = [].concat(players);//use the new ES6 Spreadconst team4 = [...players];const team5 = Array.from(players); 另一個例子，我們宣告物件person並把它傳遞給captain，在captain上新增number: 90後將兩個物件都印到 consle，此時會發現在captain新增的number: 90，也會被加到person上。會這樣是因為物件在傳遞過程是 Passed by Reference，兩物件同時指向一個記憶體空間。 123456789const person = &#123; name: &#x27;Wes Bos&#x27;, age: 80&#125;;const captain = person;captain.number = 99;console.log(person,captain); 如果不想修改到另一個物件的話，我們可以使用Object.assign(target, ...sources)來複製一個或多個物件的屬性到另一個目標物件，最後回傳目標物件。 下面我們利用Object.assign(&#123;&#125;,person,&#123;number: 99,age:12&#125;);，將物件person和&#123;number:99,age:12&#125;的屬性複製到目標物件({ })。 如果複製的多個物件的屬性有重複，以後面物件的屬性為準進行合併。舉例來說age是重複出現的屬性，最後複製屬性值時，要以後面出現的age:12為準合併物件。 注意 : Object.assign()做的是 shallow copy(淺複製)，如果要複製的物件屬性包含子物件，就會複製到子物件的參照(reference)!!!。 1234567const person = &#123; name: &#x27;Wes Bos&#x27;, age: 80&#125;;const cap2 = Object.assign(&#123;&#125;,person,&#123;number: 99,age:12&#125;);console.log(person,cap2); 原來的person並沒有被改動到。 簡單概念圖 ¶Shallow Copy &amp; Deep Copy 前面我們有提到，Object.assign()做的是 shallow copy(淺複製)，若要複製的物件屬性包含子物件，就會複製到子物件的參照。 所以只要去改動新物件的子物件屬性值，就會連帶影響原本複製的物件子屬性值。 下面我們用Object.assign()複製來源物件(wes)的屬性到目標物件({})，再將目標物件傳遞給dev物件，要留意wes的屬性包含子物件屬性(social)。 例子中我們修改複製來的物件屬性(name)和子物件屬性(social.twitter)，之後把wes、dev物件印到 console 會發現複製的來源物件wes的屬性(name)不受影響，但wes的子物件屬性(social.twitter)卻被影響。 12345678910111213141516const wes = &#123; name: &#x27;Wes&#x27;, age: 100, social: &#123; twitter: &#x27;@wesbos&#x27;, facebook: &#x27;wesbos.developer&#x27; &#125;&#125;//shallow copyconst dev = Object.assign(&#123;&#125;,wes);dev.name = &#x27;Wesley&#x27;;console.log(wes,dev);dev.social.twitter = &#x27;@coolman&#x27;;console.log(wes.social,dev.social); 如果不想改動複製來源物件的子屬性值(social.twitter)，我們可以將要複製的物件用JSON.stringify()先轉換成 JSON String(因為是Primitive，所以是 Passed by Value)，再用JSON.parse()把它還原成物件再回傳給dev2。 下面我們一樣修改子物件的屬性值，但這次的原物件子屬性值並沒有受到影響。 12345678910111213const wes = &#123; name: &#x27;Wes&#x27;, age: 100, social: &#123; twitter: &#x27;@wesbos&#x27;, facebook: &#x27;wesbos.developer&#x27; &#125;&#125;// deep copyconst dev2 = JSON.parse(JSON.stringify(wes));//先轉成string再換回objectdev2.social.twitter = &#x27;@coolman&#x27;;console.log(wes.social,dev2.social); ¶補充資料: JavaScript: var, let, const 差異 Array.prototype.concat() Spread syntax (…) Array.from() Object.assign() JSON.stringify() JSON.parse()","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第13天","slug":"ironman2021D13","date":"2021-09-13T06:53:12.000Z","updated":"2022-03-08T15:26:01.917Z","comments":true,"path":"2021/09/13/ironman2021D13/","link":"","permalink":"https://qi-xiang.github.io/2021/09/13/ironman2021D13/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 當捲動捲軸到一定位置，原本隱藏的圖片會由右或左方滑入原本的空白格顯現出來；當捲軸捲動量超過圖片的底部，圖片就會向左或右方滑出並重新的被隱藏。 ¶解析程式碼 本次的結構由&lt;p&gt;標籤的假文和穿插其中向左或向右對齊的&lt;img&gt;標籤的圖片所組成。在 CSS 裡，我們透過float:right;和float:left;刻意去產生文繞圖效果並讓圖片的透明度為0，因此出現一個個空格，但這些空格一開始並不是四四方方的，所以我們又設定text-align:justify;，讓文字向兩側對齊，也讓圖片留下的空格變成完美的方形。 ¶HTML 部分 1234567891011121314151617181920212223242526272829303132&lt;div class=&quot;site-wrap&quot;&gt; &lt;h1&gt;Slide in on Scroll&lt;/h1&gt; &lt;p&gt;Consectetur adipisicing elit. Tempore tempora rerum, est autem cupiditate, corporis a qui libero ipsum delectus quidem dolor at nulla, adipisci veniam in reiciendis aut asperiores omnis blanditiis quod quas laborum nam! Fuga ad tempora in aspernatur pariaturlores sunt esse magni, ut, dignissimos.&lt;/p&gt; &lt;p&gt;Lorem ipsum cupiditate, corporis a qui libero ipsum delectus quidem dolor at nulla, adipisci veniam in reiciendis aut asperiores omnis blanditiis quod quas laborum nam! Fuga ad tempora in aspernatur pariatur fugit quibusdam dolores sunt esse magni, ut, dignissimos.&lt;/p&gt; &lt;p&gt;Adipisicing elit. Tempore tempora rerum..&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempore tempora rerum, est autem cupiditate, corporis a qui libero ipsum delectus quidem dolor at nulla, adipisci veniam in reiciendis aut asperiores omnis blanditiis quod quas laborum nam! Fuga ad tempora in aspernatur pariatur fugit quibusdam dolores sunt esse magni, ut, dignissimos.&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempore tempora rerum, est autem cupiditate, corporis a qui libero ipsum delectus quidem dolor at nulla, adipisci veniam in reiciendis aut asperiores omnis blanditiis quod quas laborum nam! Fuga ad tempora in aspernatur pariatur fugit quibusdam dolores sunt esse magni, ut, dignissimos.&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempore tempora rerum, est autem cupiditate, corporis a qui libero ipsum delectus quidem dolor at nulla, adipisci veniam in reiciendis aut asperiores omnis blanditiis quod quas laborum nam! Fuga ad tempora in aspernatur pariatur fugit quibusdam dolores sunt esse magni, ut, dignissimos.&lt;/p&gt; &lt;img src=&quot;http://unsplash.it/400/400&quot; class=&quot;align-left slide-in&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptates, deserunt facilis et iste corrupti omnis tenetur est. Iste ut est dicta dolor itaque adipisci, dolorum minima, veritatis earum provident error molestias. Ratione magni illo sint vel velit ut excepturi consectetur suscipit, earum modi accusamus voluptatem nostrum, praesentium numquam, reiciendis voluptas sit id quisquam. Consequatur in quis reprehenderit modi perspiciatis necessitatibus saepe, quidem, suscipit iure natus dignissimos ipsam, eligendi deleniti accusantium, rerum quibusdam fugit perferendis et optio recusandae sed ratione. Culpa, dolorum reprehenderit harum ab voluptas fuga, nisi eligendi natus maiores illum quas quos et aperiam aut doloremque optio maxime fugiat doloribus. Eum dolorum expedita quam, nesciunt&lt;/p&gt; &lt;img src=&quot;http://unsplash.it/400/401&quot; class=&quot;align-right slide-in&quot;&gt; &lt;p&gt; at provident praesentium atque quas rerum optio dignissimos repudiandae ullam illum quibusdam. Vel ad error quibusdam, illo ex totam placeat. Quos excepturi fuga, molestiae ea quisquam minus, ratione dicta consectetur officia omnis, doloribus voluptatibus? Veniam ipsum veritatis architecto, provident quas consequatur doloremque quam quidem earum expedita, ad delectus voluptatum, omnis praesentium nostrum qui aspernatur ea eaque adipisci et cumque ab? Ea voluptatum dolore itaque odio. Eius minima distinctio harum, officia ab nihil exercitationem. Tempora rem nemo nam temporibus molestias facilis minus ipsam quam doloribus consequatur debitis nesciunt tempore officiis aperiam quisquam, molestiae voluptates cum, fuga culpa. Distinctio accusamus quibusdam, tempore perspiciatis dolorum optio facere consequatur quidem ullam beatae architecto, ipsam sequi officiis dignissimos amet impedit natus necessitatibus tenetur repellendus dolor rem! Dicta dolorem, iure, facilis illo ex nihil ipsa amet officia, optio temporibus eum autem odit repellendus nisi. Possimus modi, corrupti error debitis doloribus dicta libero earum, sequi porro ut excepturi nostrum ea voluptatem nihil culpa? Ullam expedita eligendi obcaecati reiciendis velit provident omnis quas qui in corrupti est dolore facere ad hic, animi soluta assumenda consequuntur reprehenderit! Voluptate dolor nihil veniam laborum voluptas nisi pariatur sed optio accusantium quam consectetur, corrupti, sequi et consequuntur, excepturi doloremque. Tempore quis velit corporis neque fugit non sequi eaque rem hic. Facere, inventore, aspernatur. Accusantium modi atque, asperiores qui nobis soluta cumque suscipit excepturi possimus doloremque odit saepe perferendis temporibus molestiae nostrum voluptatum quis id sint quidem nesciunt culpa. Rerum labore dolor beatae blanditiis praesentium explicabo velit optio esse aperiam similique, voluptatem cum, maiores ipsa tempore. Reiciendis sed culpa atque inventore, nam ullam enim expedita consectetur id velit iusto alias vitae explicabo nemo neque odio reprehenderit soluta sint eaque. Aperiam, qui ut tenetur, voluptate doloremque officiis dicta quaerat voluptatem rerum natus magni. Eum amet autem dolor ullam.&lt;/p&gt; &lt;img src=&quot;http://unsplash.it/200/500&quot; class=&quot;align-left slide-in&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Distinctio maiores adipisci quibusdam repudiandae dolor vero placeat esse sit! Quibusdam saepe aperiam explicabo placeat optio, consequuntur nihil voluptatibus expedita quia vero perferendis, deserunt et incidunt eveniet &lt;img src=&quot;http://unsplash.it/200/200&quot; class=&quot;align-right slide-in&quot;&gt; temporibus doloremque possimus facilis. Possimus labore, officia dolore! Eaque ratione saepe, alias harum laboriosam deserunt laudantium blanditiis eum explicabo placeat reiciendis labore iste sint. Consectetur expedita dignissimos, non quos distinctio, eos rerum facilis eligendi. Asperiores laudantium, rerum ratione consequatur, culpa consectetur possimus atque ab tempore illum non dolor nesciunt. Neque, rerum. A vel non incidunt, quod doloremque dignissimos necessitatibus aliquid laboriosam architecto at cupiditate commodi expedita in, quae blanditiis. Deserunt labore sequi, repellat laboriosam est, doloremque culpa reiciendis tempore excepturi. Enim nostrum fugit itaque vel corporis ullam sed tenetur ipsa qui rem quam error sint, libero. Laboriosam rem, ratione. Autem blanditiis&lt;/p&gt; &lt;p&gt;laborum neque repudiandae quam, cumque, voluptate veritatis itaque, placeat veniam ad nisi. Expedita, laborum reprehenderit ratione soluta velit natus, odit mollitia. Corporis rerum minima fugiat in nostrum. Assumenda natus cupiditate hic quidem ex, quas, amet ipsum esse dolore facilis beatae maxime qui inventore, iste? Maiores dignissimos dolore culpa debitis voluptatem harum, excepturi enim reiciendis, tempora ab ipsam illum aspernatur quasi qui porro saepe iure sunt eligendi tenetur quaerat ducimus quas sequi omnis aperiam suscipit! Molestiae obcaecati officiis quo, ratione eveniet, provident pariatur. Veniam quasi expedita distinctio, itaque molestiae sequi, dolorum nisi repellendus quia facilis iusto dignissimos nam? Tenetur fugit quos autem nihil, perspiciatis expedita enim tempore, alias ab maiores quis necessitatibus distinctio molestias eum, quidem. Delectus impedit quidem laborum, fugit vel neque quo, ipsam, quasi aspernatur quas odio nihil? Veniam amet reiciendis blanditiis quis reprehenderit repudiandae neque, ab ducimus, odit excepturi voluptate saepe ipsam. Voluptatem eum error voluptas porro officiis, amet! Molestias, fugit, ut! Tempore non magnam, amet, facere ducimus accusantium eos veritatis neque.&lt;/p&gt; &lt;img src=&quot;http://unsplash.it/400/400&quot; class=&quot;align-right slide-in&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Distinctio maiores adipisci quibusdam repudiandae dolor vero placeat esse sit! Quibusdam saepe aperiam explicabo placeat optio, consequuntur nihil voluptatibus expedita quia vero perferendis, deserunt et incidunt eveniet temporibus doloremque possimus facilis. Possimus labore, officia dolore! Eaque ratione saepe, alias harum laboriosam deserunt laudantium blanditiis eum explicabo placeat reiciendis labore iste sint. Consectetur expedita dignissimos, non quos distinctio, eos rerum facilis eligendi. Asperiores laudantium, rerum ratione consequatur, culpa consectetur possimus atque ab tempore illum non dolor nesciunt. Neque, rerum. A vel non incidunt, quod doloremque dignissimos necessitatibus aliquid laboriosam architecto at cupiditate commodi expedita in, quae blanditiis. Deserunt labore sequi, repellat laboriosam est, doloremque culpa reiciendis tempore excepturi. Enim nostrum fugit itaque vel corporis ullam sed tenetur ipsa qui rem quam error sint, libero. Laboriosam rem, ratione. Autem blanditiis laborum neque repudiandae quam, cumque, voluptate veritatis itaque, placeat veniam ad nisi. Expedita, laborum reprehenderit ratione soluta velit natus, odit mollitia. Corporis rerum minima fugiat in nostrum. Assumenda natus cupiditate hic quidem ex, quas, amet ipsum esse dolore facilis beatae maxime qui inventore, iste? Maiores dignissimos dolore culpa debitis voluptatem harum, excepturi enim reiciendis, tempora ab ipsam illum aspernatur quasi qui porro saepe iure sunt eligendi tenetur quaerat ducimus quas sequi omnis aperiam suscipit! Molestiae obcaecati officiis quo, ratione eveniet, provident pariatur. Veniam quasi expedita distinctio, itaque molestiae sequi, dolorum nisi repellendus quia facilis iusto dignissimos nam? Tenetur fugit quos autem nihil, perspiciatis expedita enim tempore, alias ab maiores quis necessitatibus distinctio molestias eum, quidem. Delectus impedit quidem laborum, fugit vel neque quo, ipsam, quasi aspernatur quas odio nihil? Veniam amet reiciendis blanditiis quis reprehenderit repudiandae neque, ab ducimus, odit excepturi voluptate saepe ipsam. Voluptatem eum error voluptas porro officiis, amet! Molestias, fugit, ut! Tempore non magnam, amet, facere ducimus accusantium eos veritatis neque.&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Distinctio maiores adipisci quibusdam repudiandae dolor vero placeat esse sit! Quibusdam saepe aperiam explicabo placeat optio, consequuntur nihil voluptatibus expedita quia vero perferendis, deserunt et incidunt eveniet temporibus doloremque possimus facilis. Possimus labore, officia dolore! Eaque ratione saepe, alias harum laboriosam deserunt laudantium blanditiis eum explicabo placeat reiciendis labore iste sint. Consectetur expedita dignissimos, non quos distinctio, eos rerum facilis eligendi. Asperiores laudantium, rerum ratione consequatur, culpa consectetur possimus atque ab tempore illum non dolor nesciunt. Neque, rerum. A vel non incidunt, quod doloremque dignissimos necessitatibus aliquid laboriosam architecto at cupiditate commodi expedita in, quae blanditiis. Deserunt labore sequi, repellat laboriosam est, doloremque culpa reiciendis tempore excepturi. Enim nostrum fugit itaque vel corporis ullam sed tenetur ipsa qui rem quam error sint, libero. Laboriosam rem, ratione. Autem blanditiis laborum neque repudiandae quam, cumque, voluptate veritatis itaque, placeat veniam ad nisi. Expedita, laborum reprehenderit ratione soluta velit natus, odit mollitia. Corporis rerum minima fugiat in nostrum. Assumenda natus cupiditate hic quidem ex, quas, amet ipsum esse dolore facilis beatae maxime qui inventore, iste? Maiores dignissimos dolore culpa debitis voluptatem harum, excepturi enim reiciendis, tempora ab ipsam illum aspernatur quasi qui porro saepe iure sunt eligendi tenetur quaerat ducimus quas sequi omnis aperiam suscipit! Molestiae obcaecati officiis quo, ratione eveniet, provident pariatur. Veniam quasi expedita distinctio, itaque molestiae sequi, dolorum nisi repellendus quia facilis iusto dignissimos nam? Tenetur fugit quos autem nihil, perspiciatis expedita enim tempore, alias ab maiores quis necessitatibus distinctio molestias eum, quidem. Delectus impedit quidem laborum, fugit vel neque quo, ipsam, quasi aspernatur quas odio nihil? Veniam amet reiciendis blanditiis quis reprehenderit repudiandae neque, ab ducimus, odit excepturi voluptate saepe ipsam. Voluptatem eum error voluptas porro officiis, amet! Molestias, fugit, ut! Tempore non magnam, amet, facere ducimus accusantium eos veritatis neque.&lt;/p&gt;&lt;/div&gt; ¶JS 部分 我們的目的是讓圖片隨著捲軸下滑一個個的從左或右滑進來，為了達成這個目的，我們會在視窗(window)上註冊scroll 事件的監聽器。 如果將每次觸發的scroll 事件用console.count(e)計算並印出到console上，你會發現只是稍微的滑動滾輪就觸發數次scroll 事件。而太頻繁地觸發事件的處理對瀏覽器來說是很大的負擔，也因此我們必須借助debounce()來幫我們延遲事件的處理，預設是延遲20毫秒。 1234567891011121314151617/*用來延遲執行方法*/function debounce(func, wait = 20, immediate = true) &#123; var timeout; return function() &#123; var context = this, args = arguments; var later = function() &#123; timeout = null; if (!immediate) func.apply(context, args); &#125;; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); &#125;;&#125;;window.addEventListener(&#x27;scroll&#x27;,e =&gt; console.count(e)); 宣告常數slideImages放入要滑進來的圖片們。 1const sliderImages = document.querySelectorAll(&#x27;.slide-in&#x27;); 觸發scroll 事件時，我們並沒有在第一時間處理它，而是利用debounce(checkSlide)讓checkSlide()被延遲20毫秒才執行。 在checkSlide()裡，我們首先必須決定圖片要在哪時候滑進來和滑出去。在這次的課程裡，我們決定要讓2分之1的圖片出現在視窗下緣時，讓圖片滑進來、捲軸移動超過圖片底端時，讓圖片滑出去。 我們使用sliderImages.forEach()分別計算2分之1圖片出現在下緣的距離(slideInAt)以及圖片的底端距離視窗上方的距離(imageBottom) window.scrollY(目前的捲軸捲動量) + window.innerHeight(視窗內部高度) = 視窗下緣離視窗頂部的距離。如果將這段距離再減去slideImage.height / 2(2分之1的圖片高度)，就會是實際上圖片的滑入點(slideInAt)。 slideImage.offsetTop(圖片頂部離視窗頂部的距離) + slideImage.height(圖片的高度) = 圖片底部離視窗頂部的距離(imageBottom)。 12345678910function checkSlide(e)&#123; sliderImages.forEach(slideImage =&gt;&#123; /*取得視窗下緣並預留2分之1的圖片高度*/ const slideInAt = (window.scrollY + window.innerHeight) - slideImage.height / 2; /*取得圖片底部離視窗頂部的距離*/ const imageBottom = slideImage.offsetTop + slideImage.height; &#125;);&#125;;window.addEventListener(&#x27;scroll&#x27;,debounce(checkSlide)); 宣告常數isHalfShown判斷圖片是否已有2分之1出現在視窗的下緣。 宣告常數isNotScrolledPast判斷捲軸的捲動量是否已經超過圖片的底部。 最後，利用 if 判斷圖片已經有2分之1出現在視窗下緣(isHalfShown = true)並且捲軸捲動量不超過圖片底部(isNotScrolledPast = true)就為圖片(slideImage)加上 .active選擇器，讓圖片滑入並顯示；反之則拿掉.active選擇器，讓圖片滑出並隱藏。 1234567891011121314function checkSlide(e)&#123; sliderImages.forEach(slideImage =&gt;&#123; /*上略*/ const isHalfShown = slideInAt &gt; slideImage.offsetTop; const isNotScrolledPast = window.scrollY &lt; imageBottom; if(isHalfShown &amp;&amp; isNotScrolledPast)&#123; slideImage.classList.add(&#x27;active&#x27;); &#125;else&#123; slideImage.classList.remove(&#x27;active&#x27;); &#125; &#125;);&#125;; 圖片初始都向左或右位移並隱藏，.active選擇器用來取消圖片原有的位移，讓圖片回到原始的位置(滑進來)。 12345678910111213/*CSS*/.align-left.slide-in &#123; transform: translateX(-30%) scale(0.95);&#125; .align-right.slide-in &#123; transform: translateX(30%) scale(0.95);&#125;.slide-in.active &#123; opacity: 1; transform: translateX(0%) scale(1);&#125; ¶補充資料: HTMLElement.offsetTop text-align ¶範例網頁請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第12天","slug":"ironman2021D12","date":"2021-09-12T06:53:06.000Z","updated":"2022-03-08T15:25:24.589Z","comments":true,"path":"2021/09/12/ironman2021D12/","link":"","permalink":"https://qi-xiang.github.io/2021/09/12/ironman2021D12/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 預先設定一組secretCode，如果在視窗畫面內輸入的文字與secretCode相同則在視窗畫面加上圖案。 (ps.背景圖是後來改的，原版是空白畫面。) ¶解析程式碼 這次我們需要藉助網路上別人寫好的 JavaScript API，讓他幫忙在每次視窗畫面中輸入文字等於secretCode時，在視窗畫面上新增一個生動的圖案。 觀看完整的 JavaScript API 內容 1&lt;script type=&quot;text/javascript&quot; src=&quot;https://www.cornify.com/js/cornify.js&quot;&gt;&lt;/script&gt; ¶JS 部分 宣告常數 pressed 為一個空陣列，用來存放我們在視窗畫面所輸入的值。 宣告常數secretCode作為預設的文字密碼。 12const pressed = [];const secretCode = &#x27;saber&#x27;; 我們替整個視窗註冊keyup 事件(放開按鍵時觸發)的監聽器，藉由console.log(e.key);可以在console看到我們按下的是哪一個按鍵，緊接著我們將按下的那個按鍵(key)放入陣列pressed的末端。 為了比對輸入文字是否等於secretCode，我們可以利用splice(start,deleteCount)來讓陣列的長度跟secretCode保持一樣，沒做這個處理的話，我們會發現陣列中的元素愈來愈多、長度愈來愈長，永遠沒有和secretCode相同的可能。 splice(start,deleteCount)可以刪除陣列自start索引開始的deleteCount個元素，要注意的是deleteCount要大於0才會開始刪去元素，範例中的secretCode長度是5，也就是說只有輸入到第6次才會開始刪去元素。 有趣的是我們將deleteCount指定為pressed.length - secretCode則效果和直接指定為1相同。只要pressed的長度到達6，經過計算後deleteCount是1，刪去一個元素後，pressed長度又變為5，由此周而復始(5-&gt;6；6-&gt;5)。 指定start = -secretCode.length - 1的效果是讓我們從最早被 push 進陣列(最前端)的元素開始刪除。 12345window.addEventListener(&#x27;keyup&#x27;,(e)=&gt;&#123; console.log(e.key); pressed.push(e.key); pressed.splice(-secretCode.length - 1,pressed.length - secretCode.length);&#125;); 最後，我們利用 if 判斷用pressed.join('')串聯出的字串是否有包含secretCode，如果有包含就在console印出DING DING!並呼叫 API 中的cornify_add()在視窗畫面裡加上圖片。我們也可以再補上console.log(pressed);，查看目前pressed陣列內的元素。 12345678910window.addEventListener(&#x27;keyup&#x27;,(e)=&gt;&#123; /***省略***/ /***省略***/ if(pressed.join(&#x27;&#x27;).includes(secretCode))&#123; console.log(&#x27;DING DING!&#x27;); cornify_add(); &#125; console.log(pressed);&#125;); ¶補充資料: keyup事件 Array.prototype.splice() ¶範例網頁請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第11天","slug":"ironman2021D11","date":"2021-09-11T06:53:01.000Z","updated":"2022-03-08T15:25:17.619Z","comments":true,"path":"2021/09/11/ironman2021D11/","link":"","permalink":"https://qi-xiang.github.io/2021/09/11/ironman2021D11/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 靈活運用 video 元素的相關屬性、方法，實作出一個擁有快進快退、播放速度倍率、控制音量大小、拖拉時間軸功能的簡易影片播放器。 ¶解析程式碼 ¶HTML 部分 .player 代表整個影片播放器，包含影片(.player__video)、播放控制列(.player__controls)兩部分。 播放控制列內部又可細分為四個部分: ¶1. 影片播放的時間軸 : .progress、.progress__filled ¶2. 播放/暫停鈕 : .toggle ¶3. 音量/播放速度倍率 : .player__slider ¶4. 快進/快退 : .player__button 1234567891011121314&lt;div class=&quot;player&quot;&gt; &lt;video class=&quot;player__video viewer&quot; src=&quot;652333414.mp4&quot;&gt;&lt;/video&gt; &lt;div class=&quot;player__controls&quot;&gt; &lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress__filled&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;button class=&quot;player__button toggle&quot; title=&quot;Toggle Play&quot;&gt;►&lt;/button&gt; &lt;input type=&quot;range&quot; name=&quot;volume&quot; class=&quot;player__slider&quot; min=&quot;0&quot; max=&quot;1&quot; step=&quot;0.05&quot; value=&quot;1&quot;&gt; &lt;input type=&quot;range&quot; name=&quot;playbackRate&quot; class=&quot;player__slider&quot; min=&quot;0.5&quot; max=&quot;2&quot; step=&quot;0.1&quot; value=&quot;1&quot;&gt; &lt;button data-skip=&quot;-10&quot; class=&quot;player__button&quot;&gt;« 10s&lt;/button&gt; &lt;button data-skip=&quot;25&quot; class=&quot;player__button&quot;&gt;25s »&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; ¶JS 部分 首先，取得所有要用到 HTML 標籤並放到對應宣告的常數中。 12345678910/*get element we need*/const player = document.querySelector(&#x27;.player&#x27;);const video = player.querySelector(&#x27;.viewer&#x27;);const progress = player.querySelector(&#x27;.progress&#x27;);const progressBar = player.querySelector(&#x27;.progress__filled&#x27;);const toggle = player.querySelector(&#x27;.toggle&#x27;);const skipButtons = player.querySelectorAll(&#x27;[data-skip]&#x27;);const ranges = player.querySelectorAll(&#x27;.player__slider&#x27;); 下面我們將各個播放器的功能一個個拆出來做 : ¶1. 影片的播放/暫停 功能目的 : 我們希望在點擊影片或播放/暫停鈕時，播放或暫停影片。 在video(影片)、toggle(播放/暫停鈕)上都註冊click 事件監聽器，觸發事件後用togglePlay()進行處理。 在togglePlay()裡，我們宣告一個常數method，經過條件判斷，當video.paused回傳 true 則 method = play；當video.paused回傳 false 則method = pause。 這邊有一個特殊的寫法video[method]();。舉例來說，當method = play則實際效果相當於video.play();。 12345678function togglePlay()&#123; const method = video.paused ? &#x27;play&#x27; : &#x27;pause&#x27;; video[method]();&#125;/*控制影片的播放*/video.addEventListener(&#x27;click&#x27;,togglePlay);toggle.addEventListener(&#x27;click&#x27;,togglePlay); ¶2. 更新播放/暫停圖示 功能目的 : 我們希望在影片播放/暫停的狀態下，同步更新圖示。 在video(影片)上註冊play 事件和pause 事件兩個監聽器並都以updateButton()進行事件處理。 在updateButton()裡，我們宣告一個常數icon指定當影片處於暫停狀態則icon = '►'，接著利用toggle.textContent = icon修改按鈕的圖示，當影片處於播放狀態的處理也是用一樣的方式。 12345678function updateButton()&#123; const icon = this.paused ? &#x27;►&#x27; : &#x27;❚ ❚&#x27;; toggle.textContent = icon;&#125;/*讓播放鍵的圖示改變*/video.addEventListener(&#x27;play&#x27;,updateButton);video.addEventListener(&#x27;pause&#x27;,updateButton); ¶3. 影片的快進/快退 功能目的 : 我們希望在點擊快進/快退按鈕時，同步調整影片的時間軸。 在skipButtons(快進、快退按鈕)裡的所有button都註冊click 事件並以skip()進行事件處理。 在skip()裡，我們將video.currentTime(影片現在播放的時間點)加上我們要快進或快退的秒數。 由於video.currentTime本身是 float 型別，因此需要將this.dataset.skip(快進/快退的秒數)用parseFloat()轉換成float型別之後再進行運算。 123456function skip()&#123; video.currentTime += parseFloat(this.dataset.skip);&#125;/*調整影片的快進和倒退*/skipButtons.forEach(button =&gt; button.addEventListener(&#x27;click&#x27;,skip)); ¶4. 調整影片的播放速度(倍率)、音量大小 功能目的 : 我們希望在滑鼠在倍率或音量條上移動改變數值時，同步反映到video(影片)上。 在速度倍率和音量條上都註冊change 事件和mousemove 事件，分別在數值改變和滑鼠拖曳時觸發事件，之後用handleRangeUpdate()進行事件處理。 在handleRangeUpdate()裡，我們使用和之前一樣的特殊語法video[this.name] = this.value;對video的屬性值進行調整。舉例來說，如果this.name = volume、this.value = 0，則video[this.name] = this.value;的效果和video.volume = 0;一樣。 1234567function handleRangeUpdate()&#123; video[this.name] = this.value;&#125;/*調整影片的播放速度、音量*/ranges.forEach(range =&gt; range.addEventListener(&#x27;change&#x27;,handleRangeUpdate));ranges.forEach(range =&gt; range.addEventListener(&#x27;mousemove&#x27;,handleRangeUpdate)); ¶5. 更新時間軸 功能目的 : 我們希望在影片播放的過程中，不斷地更新時間軸。 在video(影片)上註冊timeupdate 事件的監聽器，當影片的播放時間(currentTime)有變動就觸發事件，之後用handleProgress()進行事件處理。 在handleProgress()裡，我們宣告常數percent並放入video.currentTime(影片現在時間)除以video.duration(影片的總長度)再乘以100得到的比例值。 接著用progressBar.style.flexBasis = `$&#123;percent&#125;%`;，用percent指定時間軸的長度佔比。 1234567function handleProgress()&#123; const percent = (video.currentTime / video.duration) * 100 progressBar.style.flexBasis = `$&#123;percent&#125;%`; &#125;/*持續更新時間軸*/video.addEventListener(&#x27;timeupdate&#x27;,handleProgress); ¶6. 用拖拉的方式移動時間軸 功能目的 : 我們希望按住滑鼠拖或點擊時間軸的同時，更新video(影片)現在播放的時間。 宣告mousedown作為 flag 判斷現在是否有按住滑鼠。 我們在progress註冊click 事件、mousemove 事件、mousedown 事件、mouseup 事件監聽器。 觸發click 事件時，我們可以直接就以scrub(e)進行事件的處理。 但在觸發mousemove 事件時，我們需要先判斷是否有按住滑鼠，所以要借助mousedown 事件和mouseup 事件的幫忙，在mousedown 事件觸發地當下將 flag(mousedown) 設為 true，反之觸發mouseup 事件則將 flag(mousedown) 設為 false。最後用mousedown &amp;&amp; scrub(e)判斷是否執行scrub(e)，只有當flag(mousedown) 是 true 的時候，才接著執行scrub(e)完成事件處理。 在scrub(e)裡，我們宣告常數scrubTime放入將滑鼠在元素內部的X座標(e.offsetX)除以時間軸的長度(progress.offsetWidth)再乘以影片長度(video.duration)所得到要前往的時間點。最後將影片現在的時間(video.currentTime)指定為要前往的時間點(scrubTime)。 1234567891011function scrub(e)&#123; const scrubTime = (e.offsetX / progress.offsetWidth) * video.duration; video.currentTime = scrubTime;&#125;/*拖拉時間軸*/let mousedown = false;progress.addEventListener(&#x27;click&#x27;,scrub);progress.addEventListener(&#x27;mousemove&#x27;,(e)=&gt; mousedown &amp;&amp; scrub(e));progress.addEventListener(&#x27;mousedown&#x27;,() =&gt; mousedown = true);progress.addEventListener(&#x27;mouseup&#x27;,() =&gt; mousedown = false); ¶補充說明: HTMLVideoElement繼承自HTMLMediaElement所以一些video元素的屬性都可以到HTMLMediaElement查詢。 使用HTMLElement.offsetWidth所取得的元素(element)寬度包括透過 CSS 設定的width、border、padding等等…。 ¶補充資料: HTMLMediaElement HTMLElement.dataset HTMLElement.offsetWidth JS一秒區分clientX,offsetX,screenX,pageX之間關係 ¶範例網頁請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第10天","slug":"ironman2021D10","date":"2021-09-10T06:36:06.000Z","updated":"2022-03-08T15:25:08.855Z","comments":true,"path":"2021/09/10/ironman2021D10/","link":"","permalink":"https://qi-xiang.github.io/2021/09/10/ironman2021D10/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 在已經勾選一個核取方塊的前提下，按住shift鍵並勾選第二個方塊，最後將第一、二個方塊之間的方塊都勾選起來，實現同時勾選複數方塊的目的。 ¶解析程式碼 ¶HTML 部分 由最外層的 div(.inbox) 包覆住內部多個 div(.item)，每個div(.item) 都是以一個核取方塊(checkbox)搭配說明文字(p)組合而成。 1234567891011121314151617181920212223242526272829303132333435363738&lt;div class=&quot;inbox&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;This is an inbox layout.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Check one item&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Hold down your Shift key&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Check a lower item&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Everything in between should also be set to checked&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Try to do it without any libraries&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Just regular JavaScript&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Good Luck!&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;p&gt;Don&#x27;t forget to tweet your result!&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; ¶JS 部分 首先，宣告一個常數 checkboxes 並取得所有網頁上的核取方塊(checkbox)。 接著，宣告一個變數 lastChecked 用來幫我們記住上一次勾選的核取方塊(checkbox)。 12const checkboxes = document.querySelectorAll(&#x27;.inbox input[type=&quot;checkbox&quot;]&#x27;);let lastChecked; 我們在每個 checkbox 上都註冊 click 事件監聽器，當事件觸發就以handleCheck()進行事件處理。 在handleCheck()裡面，我們可以用lastChecked = this;來記住上一次選取的方塊。 12345function handleCheck(e)&#123; lastChecked = this;//更新上次勾選的點&#125;checkboxes.forEach(checkbox =&gt; checkbox.addEventListener(&#x27;click&#x27;,handleCheck)); 我們進行多選核取方塊的邏輯是先勾選其中一個作為起始點，之後按住shift鍵勾選終點方塊，而在起、終點之間的方塊都會被勾選。 在handleCheck()裡，可以使用 if 判斷現在是不是有按下shift鍵並同時勾選方塊，之後再做勾選間隔方塊的處理。 12345678function handleCheck(e)&#123; //檢查是否有按下shift鍵並選取方塊 if(e.shiftKey &amp;&amp; this.checked)&#123; &#125; lastChecked = this;//更新上次勾選的點 &#125; 宣告一個變數inBetween判斷checkbox是否處在起、終點的checkbox之間。 在checkboxes上呼叫forEach()對其下的每一個checkbox進行判斷。當這個checkbox是剛剛按住shift鍵勾選的checkbox，此時將inBetween設為 true；當這個checkbox是lastChecked，此時改將inBetween設為 false。 最後一個 if 判斷用來幫我們將起、終點之間的方塊通通勾選起來。 12345678910111213141516171819function handleCheck(e)&#123; let inBetween = false;//用來判斷checkbox是否被夾在起、終點之間 //檢查是否有按下shift鍵並選取方塊 if(e.shiftKey &amp;&amp; this.checked)&#123; checkboxes.forEach(checkbox =&gt; &#123; //將起始點的inBetween設為true、結束點的inBetewwn設為false作為斷點 if(checkbox === this || checkbox === lastChecked)&#123; inBetween = !inBetween; &#125; if(inBetween)&#123;//打勾夾在起點和終點的checkbox checkbox.checked = true; &#125; &#125;) &#125; lastChecked = this;//更新上次勾選的點&#125; ¶舉例說明: 假設現在先勾選第一個方塊，之後按住shift鍵並勾選第八個方塊，此時第一個方塊就會是lastChecked，而第八個方塊則是this剛剛勾選的。 在checkboxes上呼叫forEach()對其下的每一個checkbox進行判斷時，遇到第一個方塊也就是lastChecked就將inBetween改成 true，遇到第八個方塊也就是this則將inBetween改成 false。 最後，第一個方塊到第七個方塊的inBetween都會是 true，第八個方塊則是 false。作 if 判斷時，我們將inBetween是 true 的勾選起來，勾到第八個剛好inBetween是 false 成為一個勾選的終止點，成功地一次勾選八個方塊。 ¶補充資料: KeyboardEvent.shiftKey ¶範例網頁請點此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第9天","slug":"ironman2021D9","date":"2021-09-09T06:36:01.000Z","updated":"2022-03-08T15:24:54.146Z","comments":true,"path":"2021/09/09/ironman2021D9/","link":"","permalink":"https://qi-xiang.github.io/2021/09/09/ironman2021D9/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 學會使用一些操作 console 的 JS 方法。 ¶在網頁元素上設置斷點 在下面的例子中，只要我們點擊文字，文字就會變大並且顏色變為綠色。 現在假設我們知道這個效果是經由 JS 之手做出來，但不知道實際上是 JS 的哪一部分發揮功能。這個時候，我們可以利用網頁的檢查功能來設定 JS 執行時的 break point，讓它在觸發效果的那一行 JS 程式碼停下來。 首先打開網頁的檢查功能，將要查看變化的元素標籤選起來並按右鍵選擇 break on -&gt; attribute modification。 接著點擊文字，會發現文字的顏色改變，但文字大小卻沒有改變。 這是因為我們在這個元素標籤上設定了一個只要屬性值改變就觸發的斷點，所以執行到 JS 的 p.style.color = '#BADA55'; 修改到標籤屬性就停止繼續往下執行下一行 JS。 如果想要繼續執行下一行 JS，只要按圖片中的藍色播放鈕，它就會跳到下一行繼續執行，同時也可以發現文字變大。 總而言之，在元素標籤上設定斷點是 debug 的一個好方法，我們可以逐步觀察程式碼的執行過程並快速找出問題點。 ¶一些有關 console 的 JS 方法 ¶1. console.log() Regular: 直接輸出字串到 console 上。 Interpolated: 格式化輸出字串到 console 上，類似 Java 的 printf 方法。 Styled: 在輸出字串到 console 的同時，用指定的 CSS 修飾字串。 12345678// Regularconsole.log(&#x27;Hello World&#x27;)// Interpolatedconsole.log(&#x27;I am very interested in %s animation.&#x27;,&#x27;Japanese&#x27;);// Styledconsole.log(&#x27;%c I am very interested in Japanese animation.&#x27;,&#x27;font-weight: bold;background: skyblue;color:white;font-size:20px;&#x27;); ¶2. console.warn() 呼叫console.warn()在 console 輸出警告訊息。 12// warning!console.warn(&#x27;Something is wrong!&#x27;); ¶3. console.error() 呼叫console.error()在 console 輸出錯誤訊息。 12// Errorconsole.error(&#x27;There is a fatal error!&#x27;); ¶4. console.info() 呼叫console.info()在 console 輸出提示訊息。 12// Infoconsole.info(&#x27;info message&#x27;); ¶5. console.assert() 呼叫console.assert()時，若前方的判斷結果回傳 false 則印出後方字串到 console 上。 123// Testingconst p = document.querySelector(&#x27;p&#x27;);console.assert(p.classList.contains(&#x27;ouch&#x27;),&#x27;That is wrong!&#x27;); ¶6. console.clear() 呼叫console.clear()清空 console 的內容。 12// clearingconsole.clear(); ¶7. console.dir() 呼叫console.log(DOM Element)輸出該元素標籤到 console 上。 呼叫console.dir(DOM Element)以 JSON 格式將該元素的 property 全部輸出到 console 上。 不過我在 console 看到的結果是相同的。 123// Viewing DOM Elementsconsole.log(p);console.dir(p); ¶8. console.group()/groupEnd() 呼叫console.group(label);進行分組、console.groupEnd(label);結束分組。 label: 組別名稱 如果初始呼叫的是console.groupCollapsed(label)，則會預設以摺疊方式呈現。 123456789// Grouping togetherdogs.forEach(dog =&gt; &#123; //console.groupCollapsed(`$&#123;dog.name&#125;`); console.group(`$&#123;dog.name&#125;`); console.log(`This is $&#123;dog.name&#125;.`); console.log(`$&#123;dog.name&#125; is $&#123;dog.age&#125; years old.`); console.log(`$&#123;dog.name&#125; is $&#123;dog.age * 7&#125; years old.`); console.groupEnd(`$&#123;dog.name&#125;`);&#125;) 呼叫console.group(label) 呼叫console.groupCollapsed(label) ¶9. console.count() 呼叫console.count(label);可以得到 label 出現過的次數。 1234567// countingconsole.count(&#x27;Saber&#x27;);console.count(&#x27;Saber&#x27;);console.count(&#x27;Saber&#x27;);console.count(&#x27;Miku&#x27;);console.count(&#x27;Saber&#x27;);console.count(&#x27;Miku&#x27;); ¶10. console.time()/timeEnd() 呼叫console.time()/timeEnd()可以取得執行到某一行 JS 經過的時間。 12345678// timingconsole.time(&#x27;fetching data&#x27;);fetch(&#x27;https://api.github.com/users/wesbos&#x27;) .then(data =&gt; data.json()) .then(data =&gt; &#123; console.timeEnd(&#x27;fetching data&#x27;); console.log(data); &#125;); ¶補充資料: Console API reference","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第8天","slug":"ironman2021D8","date":"2021-09-08T06:35:55.000Z","updated":"2022-03-08T15:24:46.562Z","comments":true,"path":"2021/09/08/ironman2021D8/","link":"","permalink":"https://qi-xiang.github.io/2021/09/08/ironman2021D8/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 使用 JavaScript 實作出能在 HTML Canvas 上用筆刷畫圖的極簡版小畫家。 ¶解析程式碼 ¶HTML 部分 在 body 內放入 canvas 標籤作為我們的畫布，這裡雖然指定大小為 800*800，但之後會利用 JS 把它改成跟視窗(window)一樣大。 1&lt;canvas id=&quot;draw&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; ¶JS 部分 取得 canvas 標籤後，將畫布的寬、高，將其改成跟視窗內部的寬、高一樣的數值。 123const canvas = document.querySelector(&#x27;#draw&#x27;);canvas.width = window.innerWidth;canvas.height = window.innerHeight; canvas 只是一個空白的畫布，實際上我們需要“取得畫布的渲染環境(rendering context)”才能在渲染環境上作畫。 我們呼叫 canvas 的 getContext() 方法並放入 “2d” 作為參數，順利取得 canvas 的 2D 渲染環境，若是要取得 3D 渲染環境只要放入 “3d” 作為參數就好。 緊接著，我們調整 context 的 strokeStyle 屬性值，更改作畫時的畫筆顏色。 context 的 lineJoin 是用來設定兩條長度不為0的線段如何在接合處連接，把值設定為 “round” 則在相連部分以扇形連接。 context 的 lineCap 是用來設定線段末端的呈現方式，把值設定為 “round” 則在末端部分以扇形呈現。 context 的 lineWidth 用來設定線條的粗細。 12345const ctx = canvas.getContext(&#x27;2d&#x27;);ctx.strokeStyle = &#x27;#BADASS&#x27;;ctx.lineJoin = &#x27;round&#x27;;ctx.lineCap = &#x27;round&#x27;;ctx.lineWidth = 100; 我們希望在視窗下按住滑鼠拖曳時作畫，所以在 canvas 上註冊4個事件監聽器。 觸發’mousedown’事件時，設定 isDrawing = true，表示現在可以作畫；設定 [lastX,lastY] = [e.offsetX,e.offsetY]，更新作畫的起始點。 觸發’mousemove’事件時，用 draw() 方法持續的進行作畫。 觸發’mouseup’、'mouseout’時，皆設定 isDrawing = false，表示在滑鼠沒被按住和滑鼠離開視窗的情況下都停止作畫。 123456789101112let isDrawing = false;//flaglet lastX = 0;let lastY = 0;canvas.addEventListener(&#x27;mousemove&#x27;,draw);canvas.addEventListener(&#x27;mousedown&#x27;,(e)=&gt; &#123; isDrawing = true; [lastX,lastY] = [e.offsetX,e.offsetY]; &#125;);canvas.addEventListener(&#x27;mouseup&#x27;,()=&gt; isDrawing = false);canvas.addEventListener(&#x27;mouseout&#x27;,()=&gt; isDrawing = false); 事件處理方法 draw()，在最初就先判斷現在能不能作畫，不能的話(isDrawing = false)就直接返回。 ctx.beginPath() 用來建立一個新的作畫路徑。 ctx.moveTo() 用來移動路徑起始點的座標。 ctx.lineTo() 用來指定這條路徑的終點座標。 ctx.stroke() 將這條路徑描出來。 [lastX,lastY] = [e.offsetX,e.offset] 用來不斷更新&quot;此次&quot;按住滑鼠拖曳作畫過程中持續變動的路徑起始點。 1234567891011function draw(e)&#123; if(!isDrawing) return; ctx.beginPath(); //start from ctx.moveTo(lastX,lastY); //go to ctx.lineTo(e.offsetX,e.offsetY); ctx.stroke(); [lastX,lastY] = [e.offsetX,e.offsetY];&#125; HSL 的 H(Hue，色相角度)，是由 0~360 為止的色相循環，0是紅色、120是綠色、240是藍色，Hue 本身不加單位，詳細說明可以參考下方補充資料 CSS Coke 大大的文章。 宣告 hue 變數指定畫筆顏色，並持續的將 hue + 1，當 hue &gt;= 360時，代表顏色已經循環過一次，故將其重設為0。 宣告 direction 變數作為目前該加粗畫筆還是讓畫筆變細的判斷，direction 的初始值是 true 也就是讓畫筆變粗。第一個 if 判斷目前的畫筆粗細是不是 &gt;= 100 或 &lt;= 1，如果條件符合就將 direction 變為相反值(true 變 false)。在第二個的 if-else 判斷，如果 direction = true 就加粗畫筆、反之則讓畫筆變得更細。 123456789101112131415161718192021let hue = 0;let direction = true;function draw(e)&#123; /*.......省略*/ ctx.strokeStyle = `hsl($&#123;hue&#125;,100%,50%)`; /*.......省略*/ hue++; if(hue &gt;= 360)&#123; hue = 0; &#125; if(ctx.lineWidth &gt;= 100 || ctx.lineWidth &lt;= 1)&#123; direction = !direction; &#125; if(direction)&#123; ctx.lineWidth++; &#125;else&#123; ctx.lineWidth--; &#125;&#125; 最後來介紹一個特別的東西，ctx 的 globalCompositeOperation，主要用來處理疊圖(線段重疊)的情況，若將其設定為 ‘multiply’ 則將上層像素與相對應的下層像素相乘，整體效果是讓顏色更加趨於黑色。 1ctx.globalCompositeOperation = &#x27;multiply&#x27;; ¶補充資料: Canvas 基本用途 CanvasRenderingContext2D.strokeStyle CanvasRenderingContext2D.lineJoin CanvasRenderingContext2D.lineCap CanvasRenderingContext2D.lineWidth CanvasRenderingContext2D.beginPath() CanvasRenderingContext2D.moveTo() CanvasRenderingContext2D.lineTo() RGB、HSL、Hex 網頁色彩碼，看完這篇全懂了 JS一秒區分clientX,offsetX,screenX,pageX之間關係 CanvasRenderingContext2D.globalCompositeOperation ¶範例網頁請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第7天","slug":"ironman2021D7","date":"2021-09-07T06:35:50.000Z","updated":"2022-03-08T15:24:38.154Z","comments":true,"path":"2021/09/07/ironman2021D7/","link":"","permalink":"https://qi-xiang.github.io/2021/09/07/ironman2021D7/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 練習使用JS Array 的 some()、every()、find()、findIndex()。 ¶解析程式碼 ¶JS 部分 練習題使用到的資料: 1234567891011121314const people = [ &#123; name: &#x27;Wes&#x27;, year: 1988 &#125;, &#123; name: &#x27;Kait&#x27;, year: 1986 &#125;, &#123; name: &#x27;Irv&#x27;, year: 1970 &#125;, &#123; name: &#x27;Lux&#x27;, year: 2015 &#125;];const comments = [ &#123; text: &#x27;Love this!&#x27;, id: 523423 &#125;, &#123; text: &#x27;Super good&#x27;, id: 823423 &#125;, &#123; text: &#x27;You are the best&#x27;, id: 2039842 &#125;, &#123; text: &#x27;Ramen is my fav food ever&#x27;, id: 123523 &#125;, &#123; text: &#x27;Nice Nice Nice!&#x27;, id: 542328 &#125;]; ¶1. Is at least one person 19 or older? Array.prototype.some() some() 可以給定一個函式，測試陣列中是否至少有一個元素符合指定的條件，該方法回傳的是布林值。 Date 建立一個 JavaScript Date 物件來取得某個時間點。Date 物件是從世界標準時間（UTC） 1970 年 1 月 1 日開始算起。 第一題，我們檢查是否至少有一個 person 的年紀大於 19歲。指定一個 function 到 some() 中，在 function 裡面，我們宣告一個常數 currentYear來存放現在的年份，之後透過 if 判斷用現在的年份減去 person 的出生年，是否大於19，如果大於19就返回 true。 ¶基本版: 12345const isAdult = people.some(function(person)&#123; const currentYear = (new Date()).getFullYear(); if(currentYear - person.year &gt;= 19) return true;&#125;); ¶簡化版: 1234const isAdult = people.some(person =&gt; &#123; const currentYear = (new Date()).getFullYear(); return currentYear - person.year &gt; 19;&#125;); ¶更簡化版: 123const isAdult = people.some(person =&gt; (new Date().getFullYear()) - person.year &gt;= 19 );console.log(isAdult); ¶2. Is everyone 19 or older? Array.prototype.every() every() 方法會測試陣列中的所有元素是否都符合函式所指定的條件，若全部元素都符合則返回 true，反之則返回 false。 我們使用 every() 方法，將陣列元素一個個的拿出來做條件判斷，若是有其中一個元素經過計算不符合設定的規則就 return false。 123const allAdults = people.every(person =&gt; (new Date().getFullYear()) - person.year &gt;= 19 );console.log(allAdults); ¶3. Find the comment with the ID of 823423. Array.prototype.find() find() 方法會回傳第一個符合函式定義條件的元素值，若沒有元素符合條件就回傳undefined。 下面我們使用 find() 找出 comment id 是 823423 的 comment。這邊是用===而不是==進行相等運算，因為在 js 中使用 == 進行相等運算，js 會幫你偷偷地轉換型別再進行比較，例如: '99' == 99 的結果就會是 true。===則是嚴格的相等運算，js 不會偷偷的做資料轉型，兩邊資料型態只要不一致，自然就會回傳 false。 基本版: 12345const comment = comments.find(function(comment)&#123; if(comment.id === 823423)&#123; return true; &#125;&#125;); 簡化版: 123const comment = comments.find(comment =&gt; comment.id === 823423);console.log(comment); ¶4. Delete the comment with the ID of 823423. Array.prototype.findIndex() findIndex()方法將按照指定的函式，尋找陣列中第一個符合條件的元素，並回傳元素的 index（索引）。如果沒有找到符合的元素就回傳 -1 。 Array.prototype.slice() slice()方法會回傳一個新的陣列，它會切割出原陣列從索引 begin 至 end（不含 end）的元素。原本的陣列不會被影響。 我們使用 findIndex() 尋找到第一個 comment id 是 823423 的元素並取得該元素的索引值(index)。 透過 slice()將陣列進行切割，我們可以將找出的元素值從陣列中移除並宣告常數承接回傳的新陣列。(複習一下，前面說過...可以把陣列中的元素一個個地展開。) 1234567891011const index = comments.findIndex(comment =&gt; comment.id === 823423);console.log(index);const newComments = [ ...comments.slice(0,index), ...comments.slice(index + 1)];console.table(comments);console.table(newComments); ¶補充資料: 相等比較 ===、== Array.prototype.slice() Array.prototype.findIndex() Array.prototype.find() Array.prototype.every() Date Array.prototype.some()","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第6天","slug":"ironman2021D6","date":"2021-09-06T06:27:37.000Z","updated":"2022-03-08T15:24:29.755Z","comments":true,"path":"2021/09/06/ironman2021D6/","link":"","permalink":"https://qi-xiang.github.io/2021/09/06/ironman2021D6/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 利用 Fetch API 取得 JSON 格式的資料，隨著輸入關鍵字的不同，將特定資料篩選出來並呈現在網頁上。 ¶解析程式碼 ¶JS 部分 將要取得的資料來源網址放入 endpoint中，並建立一個空的city陣列。 123const endpoint = &#x27;https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json&#x27;;const cities = [];/*empty array*/ fetch() 是 Fetch API 的一個方法，主要用於發出資料的 request 並回傳 Promise，有點類似於XMLHttpRequest，但在使用上較有彈性。 Promise 物件代表的是一個將要完成或失敗的非同步操作，以及它所產生的值。 then() 方法最多需要兩個參數，分別作為 Promise 成功和失敗時的 callback function 並返回 Promise。 json() 方法會接收一個 response stream，在讀取完成之後返回一個解析成 JSON 格式的 Promise。 我們透過 fetch() 向 endpoint 發送 request，之後將 return 的 Promise 以 json 格式進行解構，最後將這些資料一筆筆的 push 到空的 cities 陣列中。...data的主要用意在於將原本的 data 陣列中的元素個別拆出來放進 cities 裡面，如果直接寫cities.push(data)則 data 會變成在 cities 內部的一個陣列型態元素。 123fetch(endpoint) .then(blob =&gt; blob.json()) .then(data =&gt; cities.push(...data)); findMatches() 需要用到兩個參數，wordToMatch 用來傳入要尋找的文字，cities 則是原本的資料陣列，最後回傳經過 filter() 過濾後的 cities 陣列。 在 filter() 裡，我們將 cities 的每一個元素用 RegExp 物件進行正規表示式的字元比對，之後將包含關鍵字的 city 或是 state回傳。 RegExp() 用來建立一個正規表達式的物件，wordToMatch 是要進行比對的內容，'gi'則是 flag，g 代表搜尋出所有符合比對的文字，而不是比對出第一筆就停止，i 代表比對時不分大小寫。 123456function findMatches(wordToMatch, cities)&#123; return cities.filter(place =&gt; &#123; const regex = new RegExp(wordToMatch,&#x27;gi&#x27;); return place.city.match(regex) || place.state.match(regex); &#125;)&#125; numberWithCommas() 主要用來幫我們在每三位數字加上逗號(ex.1,000)。toString() 可以幫我們將 x 轉成字串，之後利用 replace() 進行正規表示式的判斷並取代字元。 123function numberWithCommas(x)&#123; return x.toString().replace(/\\B(?=(\\d&#123;3&#125;)+(?!\\d))/g,&#x27;,&#x27;);&#125; 宣告 matchArray 並放入找到的結果陣列。接著，將陣列中的元素換成 HTML 的格式。再來宣告一個 Regex 物件，然後宣告兩個常數並各自以正規表示式判斷並取代(replace)原有的文字內容，改以 HTML 的方式呈現。 之後，透過 Template literals 的格式傳回一個&lt;li&gt;...&lt;/li&gt;。最後，使用 join() 將陣列中的所有元素以空字串為分隔，形成一個很長的字串再放入.suggestions的標籤中。 123456789101112131415function displayMatches()&#123; const matchArray = findMatches(this.value,cities); const html = matchArray.map(place =&gt;&#123; const regex = new RegExp(this.value, &#x27;gi&#x27;); const cityName = place.city.replace(regex,`&lt;span class=&quot;hl&quot;&gt;$&#123;this.value&#125;&lt;/span&gt;`); const stateName = place.state.replace(regex,`&lt;span class=&quot;hl&quot;&gt;$&#123;this.value&#125;&lt;/span&gt;`); return ` &lt;li&gt; &lt;span class=&quot;name&quot;&gt;$&#123;cityName&#125;, $&#123;stateName&#125;&lt;/span&gt; &lt;span class=&quot;ppulation&quot;&gt;$&#123;numberWithCommas(place.population)&#125;&lt;/span&gt; &lt;/li&gt; ` &#125;).join(&#x27;&#x27;); suggestions.innerHTML = html;&#125; 分別宣告常數 searchInput、suggestions 並取得 .search、.suggestions標籤。最後為搜尋欄(searchInput) 註冊change和keyup事件，當欄位數值發生改變或放開鍵盤的那個剎那都會觸發事件，兩個事件都是以 displayMatches() 進行事件處理。 12345const searchInput = document.querySelector(&#x27;.search&#x27;);const suggestions = document.querySelector(&#x27;.suggestions&#x27;);searchInput.addEventListener(&#x27;change&#x27;,displayMatches)searchInput.addEventListener(&#x27;keyup&#x27;,displayMatches); ¶補充資料: Promise 使用 Fetch Promise.prototype.then() Response.json() Spread syntax (…) RegExp() 比較 keydown, keypress, keyup 的差異 ¶實際效果請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第5天","slug":"ironman2021D5","date":"2021-09-05T06:27:31.000Z","updated":"2022-03-08T15:24:20.121Z","comments":true,"path":"2021/09/05/ironman2021D5/","link":"","permalink":"https://qi-xiang.github.io/2021/09/05/ironman2021D5/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 利用 flexbox、transition 等 CSS 屬性，搭配 JS 監聽 transitionend、click 事件，最終實作出一個美觀的 Image Gallery。 ¶解析程式碼 ¶HTML 部分 由最外層的.panels包覆住內部的5個.panel所形成的一個巢狀結構。 123456789101112131415161718192021222324252627&lt;div class=&quot;panels&quot;&gt; &lt;div class=&quot;panel panel1&quot;&gt; &lt;p&gt;Hey&lt;/p&gt; &lt;p&gt;Let&#x27;s&lt;/p&gt; &lt;p&gt;Dance&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel panel2&quot;&gt; &lt;p&gt;Give&lt;/p&gt; &lt;p&gt;Take&lt;/p&gt; &lt;p&gt;Receive&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel panel3&quot;&gt; &lt;p&gt;Experience&lt;/p&gt; &lt;p&gt;It&lt;/p&gt; &lt;p&gt;Today&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel panel4&quot;&gt; &lt;p&gt;Give&lt;/p&gt; &lt;p&gt;All&lt;/p&gt; &lt;p&gt;You can&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel panel5&quot;&gt; &lt;p&gt;Life&lt;/p&gt; &lt;p&gt;In&lt;/p&gt; &lt;p&gt;Motion&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; ¶CSS 部分 (僅說明影片中更動的部分) 先將最外層的 .panels 顯示類型設定為 flex，它同時也作為一個 flex-container 包覆住內部的五個 flex-items 也就是 .panel。 1234.panels &#123; /*其餘略過*/ display: flex;&#125; flex 是 flex-grow、flex-shrink、flex-basis 的簡寫，只有指定一個值給 flex 時，則代表設定的是 flex-grow，其餘屬性以預設值帶入。 flex-grow 可以指定 flex-container 的剩餘空間該如何分配，下面所有的 .panel 的 flex-grow 都是 1，也就是均勻分配剩餘空間。 接著，將每一個 .panel 的顯示類型都設定為 flex (此時的.panel 對下面的&lt;p&gt;&lt;/p&gt;來說就是 flex-container) 並將其下的 flex-item 在水平、鉛直方向都置中。 最後，設定 flex-direction 將 flex-box 的 main-axis 更改為直列。 1234567.panel &#123; flex: 1; /*將每個 flex-item 的大小都設為一樣並填滿*/ display: flex; justify-content: center; /*在水平方向置中*/ align-items: center;/*在鉛直方向置中*/ flex-direction: column; &#125; 將 .panel (flex-container)下的 &lt;p&gt;&lt;/p&gt; (flex-item) 的 flex 屬性設定為 1、0、auto，也就是均勻分配 flex-container 的剩餘空間、flex-item 長度超過 flex-container 時的收縮量設為 0、flex-item 在 flex container 的初始大小設為自動(auto)。 接著，也將&lt;p&gt;&lt;/p&gt;當作是一個 flex-container，設定顯示類型為 flex。透過 justify-content、align-items，將標籤內的文字(flex-item) 水平、鉛直置中排列。 1234567.panel &gt; * &#123; /*其餘省略*/ flex: 1 0 auto; display: flex; justify-content: center; align-items: center;&#125; 初始狀態，分別將在 .panel 上方和下方的 &lt;p&gt;&lt;/p&gt; 都各上移、下移 100% 以達到隱藏的效果。 123456.panel &gt; *:first-child&#123; transform: translateY(-100%);/*上移*/&#125;.panel &gt; *:last-child&#123; transform: translateY(100%);/*下移*/&#125; 接著設定當.panel上有open-active這個 class 時，就將原本隱藏的文字分別下移和上移顯示出來。 123456.panel.open-active &gt; *:first-child&#123; transform: translateY(0);&#125;.panel.open-active &gt; *:last-child&#123; transform: translateY(0);&#125; .panel開啟時，將內部文字放大為 40px 並將 flex-container 剩餘分配的位置變為原來的5倍。 1234.panel.open &#123; font-size: 40px; flex: 5;&#125; ¶補充資料: CSS flex 屬性 圖解 Flexbox 基本屬性 FLEXBOX FROGGY-學習 flexbox 的小遊戲 ¶JS 部分 取得所有的.panel 並放到 NodeList 'panels' 中。 1const panels = document.querySelectorAll(&#x27;.panel&#x27;); 為 panels 中的每一個.panel都註冊兩個事件監聽器，當 click 或 transitionend 事件發生時，就分別以 toggleOpen 和 toggleActive 方法進行事件處理。 12panels.forEach(panel =&gt; panel.addEventListener(&#x27;click&#x27;,toggleOpen));panels.forEach(panel =&gt; panel.addEventListener(&#x27;transitionend&#x27;,toggleActive)); 點擊任意一個.panel，toggleOpen() 方法會替觸發事件的.panel依照情況的不同，新增或是移除.open 這個 class，若是觸發事件的.panel原本沒有.open則新增，有的話則移除.open。 當 transitionend 事件發生，toggleActive() 會作出如同 toggleOpen() 一樣的判斷，決定新增還是移除.open-active這個 class。因為同時會被觸發的 transitionend 事件有很多個，我們決定在觸發 transitionend 事件的 CSS 屬性是 flex 時，才採取處理。為什麼不寫 e.propertyName == 'flex-grow' 是因為在 Safari 顯示的是 flex 而 Chrome、FireFox 顯示的是 flex-grow，為避免這個差異導致錯誤，我們可以使用 include(‘flex’)，當 propertyName 含有 flex 就進行事件處理。 123456789function toggleOpen()&#123; this.classList.toggle(&#x27;open&#x27;);&#125;function toggleActive(e)&#123; if(e.propertyName.includes(&#x27;flex&#x27;))&#123; this.classList.toggle(&#x27;open-active&#x27;); &#125;&#125; ¶補充資料: Element.classList String.prototype.includes() ¶實際效果請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第4天","slug":"ironman2021D4","date":"2021-09-04T06:23:16.000Z","updated":"2022-03-08T15:24:10.056Z","comments":true,"path":"2021/09/04/ironman2021D4/","link":"","permalink":"https://qi-xiang.github.io/2021/09/04/ironman2021D4/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 練習一些 Array 常用的方法，包括 filter()、sort()、map()、reduce()。 ¶解析程式碼 ¶JS 部分 前七個練習題要使用的資料如下: 12345678910111213141516171819202122232425262728/*JS*/// Get your shorts on - this is an array workout!// ## Array Cardio Day 1// Some data we can work withconst inventors = [ &#123; first: &#x27;Albert&#x27;, last: &#x27;Einstein&#x27;, year: 1879, passed: 1955 &#125;, &#123; first: &#x27;Isaac&#x27;, last: &#x27;Newton&#x27;, year: 1643, passed: 1727 &#125;, &#123; first: &#x27;Galileo&#x27;, last: &#x27;Galilei&#x27;, year: 1564, passed: 1642 &#125;, &#123; first: &#x27;Marie&#x27;, last: &#x27;Curie&#x27;, year: 1867, passed: 1934 &#125;, &#123; first: &#x27;Johannes&#x27;, last: &#x27;Kepler&#x27;, year: 1571, passed: 1630 &#125;, &#123; first: &#x27;Nicolaus&#x27;, last: &#x27;Copernicus&#x27;, year: 1473, passed: 1543 &#125;, &#123; first: &#x27;Max&#x27;, last: &#x27;Planck&#x27;, year: 1858, passed: 1947 &#125;, &#123; first: &#x27;Katherine&#x27;, last: &#x27;Blodgett&#x27;, year: 1898, passed: 1979 &#125;, &#123; first: &#x27;Ada&#x27;, last: &#x27;Lovelace&#x27;, year: 1815, passed: 1852 &#125;, &#123; first: &#x27;Sarah E.&#x27;, last: &#x27;Goode&#x27;, year: 1855, passed: 1905 &#125;, &#123; first: &#x27;Lise&#x27;, last: &#x27;Meitner&#x27;, year: 1878, passed: 1968 &#125;, &#123; first: &#x27;Hanna&#x27;, last: &#x27;Hammarström&#x27;, year: 1829, passed: 1909 &#125;];const people = [ &#x27;Bernhard, Sandra&#x27;, &#x27;Bethea, Erin&#x27;, &#x27;Becker, Carl&#x27;, &#x27;Bentsen, Lloyd&#x27;, &#x27;Beckett, Samuel&#x27;, &#x27;Blake, William&#x27;, &#x27;Berger, Ric&#x27;, &#x27;Beddoes, Mick&#x27;, &#x27;Beethoven, Ludwig&#x27;, &#x27;Belloc, Hilaire&#x27;, &#x27;Begin, Menachem&#x27;, &#x27;Bellow, Saul&#x27;, &#x27;Benchley, Robert&#x27;, &#x27;Blair, Robert&#x27;, &#x27;Benenson, Peter&#x27;, &#x27;Benjamin, Walter&#x27;, &#x27;Berlin, Irving&#x27;, &#x27;Benn, Tony&#x27;, &#x27;Benson, Leana&#x27;, &#x27;Bent, Silas&#x27;, &#x27;Berle, Milton&#x27;, &#x27;Berry, Halle&#x27;, &#x27;Biko, Steve&#x27;, &#x27;Beck, Glenn&#x27;, &#x27;Bergman, Ingmar&#x27;, &#x27;Black, Elk&#x27;, &#x27;Berio, Luciano&#x27;, &#x27;Berne, Eric&#x27;, &#x27;Berra, Yogi&#x27;, &#x27;Berry, Wendell&#x27;, &#x27;Bevan, Aneurin&#x27;, &#x27;Ben-Gurion, David&#x27;, &#x27;Bevel, Ken&#x27;, &#x27;Biden, Joseph&#x27;, &#x27;Bennington, Chester&#x27;, &#x27;Bierce, Ambrose&#x27;, &#x27;Billings, Josh&#x27;, &#x27;Birrell, Augustine&#x27;, &#x27;Blair, Tony&#x27;, &#x27;Beecher, Henry&#x27;, &#x27;Biondo, Frank&#x27;]; ¶1. Filter the list of inventors for those who were born in the 1500’s Array.prototype.filter() filter() 方法會透過指定的函式運算，決定保留哪些資料並形成一個新的陣列。 在 filter 裡 return true 代表要保留該筆資料，除此之外的資料都會被捨棄，我們沒必要再寫 else 去 return false。 filter() 的詳細內容 以下我們透過 filter() 過濾&quot;出生於16世紀的發明家&quot; 123456/*JS*/const fifteen = inventors.filter(function(inventor)&#123; if(inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt; 1600)&#123; return true; //keep it in the new array &#125;&#125;)/*除了有回傳true之外的東西都會被丟掉，不必再用else return false*/ 更簡潔的寫法: console.table()，可以將 Array 以表格的形式呈現出來。 123/*JS*/const fifteen = inventors.filter(inventor =&gt; (inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt; 1600));console.table(fifteen); ¶2. Give us an array of the inventors first and last names Array.prototype.map() map() 方法會建立一個和原陣列長度相同的陣列，其內容為原陣列的每一個元素經由指定的函式運算後所回傳的結果之集合。 map() 的詳細內容 以下我們使用 map() 方法，將發明家的 first name 和 last name 結合在一起，形成一個新的陣列。 123/*JS*/const fullNames = inventors.map(inventor =&gt; `$&#123;inventor.first&#125; $&#123;inventor.last&#125;`); /*Template literals*/console.table(fullNames); ¶3. Sort the inventors by birthdate, oldest to youngest Array.prototype.sort() sort() 方法會對一個陣列中的所有元素進行排序，並回傳此陣列，預設是以字串的 Unicode 編碼進行排序。 我們也可以指定一個 compareFunction ，用自訂的排序規則為陣列進行排序。 compareFunction(a, b)，回傳值小於0時，a 會被排在 b 的前面，反之若回傳值大於0時，a 會被排在 b 的後面。 sort() 的詳細內容 以下我們使用 sort()，將較早出生的發明家排在前面的位置。 1234567const ordered = inventors.sort(function(a,b)&#123; if(a.year &gt; b.year)&#123; return 1; /*a 往後排*/ &#125;else&#123; return -1; /*a 往前排*/ &#125;&#125;) 更簡潔的寫法: 12const ordered = inventors.sort((a,b) =&gt; a.year &gt; b.year ? 1 : -1);console.table(ordered); ¶4. How many years did all the inventors live all together? Array.prototype.reduce() reduce() 方法將一個累加器(accumulator)及陣列中每項元素傳入函式中進行運算，將陣列化為單一的值。 其中一種用法如下: 123Array.reduce((accumulator,currentValue) =&gt; &#123; return accumulator + currentValue; &#125;,initialValue); /*initialValue 是 accumulator 的初始值*/ reduce() 的詳細內容 12345const totalYears = inventors.reduce((total,inventor)=&gt;&#123; return total + (inventor.passed - inventor.year);&#125;,0);console.log(totalYears); ¶5. Sort the inventors by years lived 以下，我們將這些發明家依照壽命的長短由大到小進行排序。 透過 passed - year，我們可以很簡單的算出每一位發明家的壽命。 1234567const oldest = inventors.sort(function(a,b)&#123; const lastGuy = a.passed - a.year; const nextGuy = b.passed - b.year; return lastGuy &gt; nextGuy ? -1 : 1;&#125;);console.table(oldest) ¶6. Create a list of Boulevards in Paris that contain ‘de’ anywhere in the name 這題我們需要自行到 https://en.wikipedia.org/wiki/Category:Boulevards_in_Paris 右鍵檢查進入 console 進行解題。 Node.textContent Node.textContent 可以取得節點或其後代的文字內容。 textContent 的詳細內容 Array.prototype.includes() includes() 方法會判斷陣列是否包含特定的元素，並以此來回傳 true 或 false。 includes() 的詳細內容 Array.from() Array.from() 方法會從類陣列（array-like，例如: NodeList）或是可迭代（iterable）物件建立一個新的 Array 實體。 from() 的詳細內容 首先，我們取得包覆所有巴黎大道名稱的最上層 div 標籤(.mw-category)。接著，取得在其之下的所有連結(a)。最後，使用 map() 方法以所有連結的內部文字組成新陣列並透過 filter() 過濾出包含(include)'de’的所有大道名稱。 123456const category = document.querySelector(&#x27;.mw-category&#x27;);const links = Array.from(category.querySelectorAll(&#x27;a&#x27;));/*NodeList*/const de = links.map(link =&gt; link.textContent).filter(streetName =&gt; streetName.includes(&#x27;de&#x27;));console.table(de); ¶7. Sort the people alphabetically by last name String.prototype.split() split()方法可以使用指定的分隔字元(separator)將一個String分割成串列。 split() 的詳細說明 以下，用, (逗號和空格)作為分隔字元將 first name、last name 切開並放入一個陣列中，接下來就可以依照 aLast、bLast 的 Unicode 進行 last name 的排序(由小到大)。 12345const alpha = people.sort(function(lastOne,firstOne)&#123; const [aLast,aFirst] = lastOne.split(&#x27;, &#x27;); const [bLast,bFirst] = firstOne.split(&#x27;, &#x27;); return aLast &gt; bLast ? 1 : -1;&#125;); 另一種寫法: 12345const alpha = people.sort((lastOne,firstOne) =&gt; &#123; const [aLast,aFirst] = lastOne.split(&#x27;, &#x27;); const [bLast,bFirst] = firstOne.split(&#x27;, &#x27;); return aLast &gt; bLast ? 1 : -1;&#125;); ¶8. Sum up the instances of each of these 資料內容: 1const data = [&#x27;car&#x27;, &#x27;car&#x27;, &#x27;truck&#x27;, &#x27;truck&#x27;, &#x27;bike&#x27;, &#x27;walk&#x27;, &#x27;car&#x27;, &#x27;van&#x27;, &#x27;bike&#x27;, &#x27;walk&#x27;, &#x27;car&#x27;, &#x27;van&#x27;, &#x27;car&#x27;, &#x27;truck&#x27; ]; 一開始賦予累加器(obj)的初始值(initial value)為空物件({})，因為最初所有的 item 都不存在於 obj 中，所以透過 if 判斷當 obj[item] 不存在時，就建立 obj[item] 並賦予初始值0。其後就可正常將 item 持續累加至正確的交通工具分類中(obj[item]++)。 123456789const transportation = data.reduce(function(obj,item)&#123; if(!obj[item])&#123; obj[item] = 0; &#125; obj[item]++; return obj;&#125;,&#123;&#125;)console.table(transportation);","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第3天","slug":"ironman2021D3","date":"2021-09-03T05:39:53.000Z","updated":"2022-03-08T15:23:39.333Z","comments":true,"path":"2021/09/03/ironman2021D3/","link":"","permalink":"https://qi-xiang.github.io/2021/09/03/ironman2021D3/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 學習建立 CSS 變數並透過 JavaScript 監聽 mousemove、change 事件，接著主動去更新變數的值，讓使用者得以調整圖片框的大小和背景色、圖片的模糊程度等等…。 ¶解析程式碼 ¶HTML 部分 由最外層的代表控制列(.controls)的div元素包覆住內部用來調整圖片的三個 input 元素(#spacing、#blur、#base)。其中兩個 input 元素上有設定 data- 屬性，標明使用的單位。 1234567891011121314&lt;h2&gt;Update CSS Variables with &lt;span class=&#x27;hl&#x27;&gt;JS&lt;/span&gt;&lt;/h2&gt;&lt;div class=&quot;controls&quot;&gt; &lt;label for=&quot;spacing&quot;&gt;Spacing:&lt;/label&gt; &lt;input id=&quot;spacing&quot; type=&quot;range&quot; name=&quot;spacing&quot; min=&quot;10&quot; max=&quot;200&quot; value=&quot;10&quot; data-sizing=&quot;px&quot;&gt; &lt;label for=&quot;blur&quot;&gt;Blur:&lt;/label&gt; &lt;input id=&quot;blur&quot; type=&quot;range&quot; name=&quot;blur&quot; min=&quot;0&quot; max=&quot;25&quot; value=&quot;10&quot; data-sizing=&quot;px&quot;&gt; &lt;label for=&quot;base&quot;&gt;Base Color&lt;/label&gt; &lt;input id=&quot;base&quot; type=&quot;color&quot; name=&quot;base&quot; value=&quot;#ffc600&quot;&gt;&lt;/div&gt;&lt;img src=&quot;https://source.unsplash.com/7bwQXzbF6KE/800x500&quot;&gt; ¶CSS 部分 用--變數名稱的方式，宣告三個 CSS 的全域變數，並且是在根元素之下。 12345:root&#123; /*CSS 全域變數*/ --base: #ffc600; --spacing: 10px; --blur: 10px;&#125; 要使用 CSS 變數，我們可以利用var()並在裡面放入要使用的變數名稱。 123456789img&#123; padding: var(--spacing); /*使用關鍵字 var( )並在括號內填入想套用的變數名稱*/ background: var(--base); filter: blur(var(--blur)); /*套上帶有模糊效果的濾鏡*/&#125;.hl&#123; color: var(--base);&#125; ¶補充說明1: CSS 變數的補充資料 &gt;&gt;&gt; :root 根目錄選取器 - 叫你阿爸出來講 ¶補充說明2: 使用 CSS 的 filter 屬性，主要目的是套一層濾鏡到圖片上，常見的值除了有 blur 以外，還有 contrast、grayscale 等等…。 詳細見此 ¶JS部分 取得所有的 input 標籤，要注意的是這裡的資料型態是 NodeList 而不是 Array。 相較 Array 而言，NodeList 能用的方法少很多。 12/*JS*/const inputs = document.querySelectorAll(&#x27;.controls input&#x27;); /*取得所有的 input 元素，資料型態是 NodeList 不是 Array*/ 將每個取得的 input 標籤都分別註冊兩個事件監聽器，當 input 標籤的 value 屬性有變動(change)或是滑鼠有在 input 標籤的桿上移動時，就透過 handleUpdate() 方法進行事件處理。 123456function handleUpdate()&#123; &#125;inputs.forEach(input =&gt; input.addEventListener(&#x27;change&#x27;,handleUpdate)); /*當數值改變*/inputs.forEach(input =&gt; input.addEventListener(&#x27;mousemove&#x27;,handleUpdate)); /*當滑鼠移動*/ 在 handleUpdate() 方法內宣告 suffix 變數，透過 dataset.sizing 取得對應屬性的單位。當屬性沒有單位時，指定 suffix 為空字串，避免因為是 undefined 出現錯誤。 最後，藉著 document.documentElement.style 取得文件上&quot;根元素&quot;的 CSS 屬性，進一步使用 setProperty() 調整 CSS 屬性值(注意，有些屬性必須要加上單位)。 1234function handleUpdate()&#123; const suffix = this.dataset.sizing || &#x27;&#x27;; /*取得單位，當單位不存在時就指定為空字串*/ document.documentElement.style.setProperty(`--$&#123;this.name&#125;`,this.value + suffix); /*Template literals*/&#125; ¶補充說明1: NodeList 的補充資料 – JavaScript HTML DOM Node Lists ¶補充說明2: 透過 dataset 實際取得的 data-自訂名稱 屬性內容如下: 我們可以進一步使用 dataset.自訂名稱，取得裡面代表單位的&quot;px&quot;。 (圖片中的 sizing 等同於標籤上的 data-sizing) ¶實際效果請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第2天","slug":"ironman2021D2","date":"2021-09-02T05:29:18.000Z","updated":"2022-03-08T15:23:29.146Z","comments":true,"path":"2021/09/02/ironman2021D2/","link":"","permalink":"https://qi-xiang.github.io/2021/09/02/ironman2021D2/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 透過 JavaScript 的 Date 物件分別取得&quot;時&quot;、“分”、&quot;秒&quot;並計算出在圓上的相對應角度，最後搭配 CSS 的 transform 和 transition 屬性，製作出一個簡易的時鐘。 ¶解析程式碼 ¶HTML 部分 由最外層的&quot;clock&quot;部分包住內層的&quot;clock-face&quot;和其內部的&quot;時針&quot;、“分針”、“秒針”，形成一個完整的巢狀結構。 1234567&lt;div class=&quot;clock&quot;&gt; &lt;div class=&quot;clock-face&quot;&gt; &lt;div class=&quot;hand hour-hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hand min-hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hand second-hand&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; ¶CSS 部分 首先，將物件 transform 的基準點，更改為最右端。接著，將所有指針都預先固定在12點鐘方向。最後，透過 transition 屬性還有 transition-timing-function屬性，分別調整 CSS animation 效果變化速度和做出指針移動時的彈跳效果。 12345678910111213.hand &#123; width: 50%; height: 6px; background: black; position: absolute; top: 50%; /*以下是影片中教學的部分*/ transform-origin: 100%; /*改變 transform 的 x-axis*/ transform: rotate(90deg); /*初始位置從12點鐘出發*/ transition: all 0.05s; /*調整 CSS animation 變動的速度*/ transition-timing-function: cubic-bezier(0.1, 2.7, 0.58, 1);&#125; ¶補充說明1: transform 預設是以物件中心作為平移、旋轉、縮放、傾斜時的基準點。詳細內容見此 ¶補充說明2: transition timing function，可用來定義轉場發生的時間曲線，以四個參數的貝茲曲線代表。詳細內容見此 ¶JS 部分 首先，分別取得代表&quot;時針&quot;、“分針”、&quot;秒針&quot;的標籤。 1234/*JS*/const secondHand = document.querySelector(&#x27;.second-hand&#x27;);const minsHand = document.querySelector(&#x27;.min-hand&#x27;)const hourHand = document.querySelector(&#x27;.hour-hand&#x27;) 建立 Date 物件，取得&quot;時&quot;、“分”、&quot;秒&quot;的資料，以此算出所應旋轉的角度(注意，角度必須加上早先設定的90度，才會是正確的)，之後分別調整 CSS 的 transform 屬性。 最後用 setInterval() 方法，設定每1000毫秒(1秒)就執行 setDate() 方法一次，藉此動態改變 rotate 的值。 (時針、分針、秒針的原理都一樣，只是在角度計算上有所差異) 123456789101112/*JS*/function setDate()&#123; const now = new Date(); /*時針、分針、秒針的原理都一樣*/ const seconds = now.getSeconds(); const secondsDegrees = ((seconds/60)*360) + 90;/*旋轉的角度要加上預設的90度*/ secondHand.style.transform = `rotate($&#123;secondsDegrees&#125;deg)`;&#125; setInterval(setDate,1000) 分別設定完&quot;時針&quot;、“分針”、&quot;秒針&quot;後，setDate() 方法如下。 1234567891011121314151617/*JS*/function setDate()&#123; const now = new Date(); /*時針、分針、秒針的原理都一樣*/ const seconds = now.getSeconds() const secondsDegrees = ((seconds/60)*360) + 90;/*旋轉的角度要加上預設的90度*/ secondHand.style.transform = `rotate($&#123;secondsDegrees&#125;deg)`; const mins = now.getMinutes(); const minsDegrees = ((mins/60)*360) + 90; minsHand.style.transform = `rotate($&#123;minsDegrees&#125;deg)`; const hours = now.getHours(); const hoursDegrees = ((hours/12)*360) + 90; hourHand.style.transform = `rotate($&#123;hoursDegrees&#125;deg)`;&#125; 以上都完成後，一個簡單的時鐘就出現了。但仔細一看就會發現指針在某個時間點會突然倒轉一圈。 舉&quot;秒針&quot;為例，在59秒~0秒之間，數值上的角度會從444度變為90度(分針也是如此)，整整倒轉354度接近一圈，這就解釋了為什麼指針會有突然倒轉的現象。 而我們可以分別記錄時針和分針所走的圈數，並將原來計算出的度數加上360度*圈數，解決指針倒轉的問題。 用 if 判斷到 0 秒(分)時，就將圈數加1。 12345678910111213141516171819202122232425var secRound = 0; /*紀錄秒針所走圈數*/var minRound = 0; /*紀錄秒針所走圈數*/function setDate()&#123; const now = new Date(); /*時針、分針、秒針的原理都一樣*/ const seconds = now.getSeconds() if(seconds == 0)&#123;/*避免回彈*/ secRound += 1; &#125; const secondsDegrees = ((seconds/60)*360) + 360*secRound + 90;/*旋轉的角度要加上預設的90度*/ secondHand.style.transform = `rotate($&#123;secondsDegrees&#125;deg)`; const mins = now.getMinutes(); if(mins == 0)&#123;/*避免回彈*/ minRound += 1; &#125; const minsDegrees = ((mins/60)*360) + 360*minRound + 90; minsHand.style.transform = `rotate($&#123;minsDegrees&#125;deg)`; const hours = now.getHours(); const hoursDegrees = ((hours/12)*360) + 90; hourHand.style.transform = `rotate($&#123;hoursDegrees&#125;deg)`;&#125; 最後的最後，我們還可以讓指針的位置更加精準。一般而言，秒針每走一格，分針應該跟著移動一點，同理時針也是如此。 對分針而言移動每過一分鐘移動6度，我們可以用 (秒數/60)*6，算出實際上每過一秒鐘，分針應該要跟著移動多少度。 對時針而言移動每過一小時移動30度，我們可以用 (分鐘數/60)*30，算出實際上每過一分鐘，時針應該要跟著移動多少度。 12345678910const mins = now.getMinutes();if(mins == 0)&#123;/*避免回彈*/ minRound += 1;&#125;const minsDegrees = ((mins/60)*360) + 360*minRound + ((seconds/60)*6) + 90;minsHand.style.transform = `rotate($&#123;minsDegrees&#125;deg)`;const hours = now.getHours();const hoursDegrees = ((hours/12)*360) + ((mins/60)*30) + 90;hourHand.style.transform = `rotate($&#123;hoursDegrees&#125;deg)`; ¶補充說明1: rotate($&#123;hoursDegrees&#125;deg) 是 ES6 Template literals 的寫法。詳細介紹 Template literals ¶範例網頁請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"JS30 全攻略 第1天","slug":"ironman2021D1","date":"2021-08-31T16:20:35.000Z","updated":"2022-03-08T15:23:01.246Z","comments":true,"path":"2021/09/01/ironman2021D1/","link":"","permalink":"https://qi-xiang.github.io/2021/09/01/ironman2021D1/","excerpt":"","text":"¶前言 JS 30 是由加拿大的全端工程師 Wes Bos 免費提供的 JavaScript 簡單應用課程，課程主打 No Frameworks、No Compilers、No Libraries、No Boilerplate 在30天的30部教學影片裡，建立30個JavaScript的有趣小東西。 另外，Wes Bos 也很無私地在 Github 上公開了所有 JS 30 課程的程式碼，有興趣的話可以去 fork 或下載。 ¶本日目標 透過監聽 “transitionend 事件” 和 “keydown 事件”，調整 CSS 設定以及播放音效，最終建立一組爵士鼓並依照按下按鍵的不同播放不同的音效伴隨網頁上的 CSS 動畫效果。 ¶解析程式碼 ¶HTML 部分 基本結構是由最外層的 “keys” 包住內層9個 “key” 的巢狀結構，內層的 “key” 都有 data-key 屬性並有相異的數值，這些相異值在接下來判斷要播放哪個音檔和套用 CSS 設定到哪個 “key” 時很重要。 1234567891011121314151617181920212223242526272829303132333435363738&lt;div class=&quot;keys&quot;&gt; &lt;div data-key=&quot;65&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;A&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;clap&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;83&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;S&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;hihat&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;68&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;D&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;kick&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;70&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;F&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;openhat&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;71&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;G&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;boom&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;72&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;H&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;ride&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;74&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;J&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;snare&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;75&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;K&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;tom&lt;/span&gt; &lt;/div&gt; &lt;div data-key=&quot;76&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;L&lt;/kbd&gt; &lt;span class=&quot;sound&quot;&gt;tink&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; ¶補充說明1: HTML5 新增了 data-* 自定義屬性(data attributes)，讓我們能以 data- 為開頭，建立自訂的屬性和值並隨時可以讀寫在元素上的資料數值，而不會影響到整個版面。 程式碼中的 data-key 就是一個不錯的例子。 ¶補充說明2: &lt;kbd&gt; 是一個行內元素 (inline element) ，用來標示鍵盤符號。 ¶JS 部分 首先，我們先依照按下按鍵的 keyCode 取得特定的音檔和 div 標籤。 12345/*JS*/window.addEventListener(&quot;keydown&quot;,function()&#123; const audio = document.querySelector(`audio[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); const key = document.querySelector(`.key[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`);&#125;) 因為實際上會有作用的按鍵只有9個，按到沒作用的按鍵時，理論上我們應該要終止執行方法避免錯誤，所以新增 if 判斷是否成功取得音檔，沒有取得就終止方法的執行。 123456/*JS*/window.addEventListener(&quot;keydown&quot;,function()&#123; const audio = document.querySelector(`audio[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); const key = document.querySelector(`.key[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); if(!audio)return; /*如果keyCode不存在則中止執行方法*/&#125;) 接著是播放音檔的部分，如果只單用 audio.play()的話，則在連續按下同一按鍵時，會出現聲音不連貫的效果，此時需要將每次播放音檔的時間軸都設為0，讓每次播放都是從頭開始。 123456789/*JS*/window.addEventListener(&quot;keydown&quot;,function()&#123; const audio = document.querySelector(`audio[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); const key = document.querySelector(`.key[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); if(!audio)return; /*如果keyCode不存在則中止執行方法*/ audio.currentTime = 0; /*確保每一次按下鍵盤都從頭播放音檔*/ audio.play(); /*播放音檔*/&#125;) 最後處理 CSS 的動畫效果，我們會套用 .playing 的 CSS 設定到播放音檔的 div 標籤上。 123456/*CSS*/.playing &#123; transform: scale(1.1); /*讓 div 標籤變大1.1倍*/ border-color: #ffc600; /*改變 border 的顏色*/ box-shadow: 0 0 1rem #ffc600; /*產生陰影*/&#125; 1234567891011/*JS*/window.addEventListener(&quot;keydown&quot;,function()&#123; const audio = document.querySelector(`audio[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); const key = document.querySelector(`.key[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); if(!audio)return; /*如果keyCode不存在則中止執行方法*/ audio.currentTime = 0; /*確保每一次按下鍵盤都從頭播放音檔*/ audio.play(); /*播放音檔*/ key.classList.add(&#x27;playing&#x27;);&#125;) 一定時間後，我們必須拿掉 .playing 的 CSS 設定，讓 div 標籤回到未被按鍵觸發的狀態。因此我們可以在每個 key 上都註冊 “transitionend 事件” 的監聽器，並用 removeTransition() 處理該事件。 123456789/*JS*/function removeTransition(e)&#123; this.classList.remove(&#x27;playing&#x27;);&#125;/*取得所有的 key 標籤*/const keys = document.querySelectorAll(`.key`);/*在每個 key 上都註冊 &quot;transitionend 事件&quot; 的監聽器*/keys.forEach(key =&gt; key.addEventListener(&#x27;transitionend&#x27;,removeTransition)); 到這裡基本上就完成了，但是如果把 removeTransition() 的 “transitionend 事件” 印到 console，可以發現 “transitionend 事件” 不只有一個。 我們可以選擇以 transform 結束觸發的那個 “transitionend 事件”，作為移除 CSS 設定的時機點。 123456/*JS*//*當transform完成就移除.playing*/function removeTransition(e)&#123; if(e.propertyName != &#x27;transform&#x27;) return; this.classList.remove(&#x27;playing&#x27;);&#125; 整理後的完整JS如下: 1234567891011121314151617181920/*JS*/function playSound(e)&#123; const audio = document.querySelector(`audio[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); const key = document.querySelector(`.key[data-key=&quot;$&#123;e.keyCode&#125;&quot;]`); if(!audio)return; /*如果keyCode不存在則中止執行方法*/ audio.currentTime = 0; /*確保每一次按下鍵盤都從頭播放音檔*/ audio.play(); /*播放音檔*/ key.classList.add(&#x27;playing&#x27;); &#125; /*當transform完成就移除.playing*/function removeTransition(e)&#123; if(e.propertyName != &#x27;transform&#x27;) return; this.classList.remove(&#x27;playing&#x27;);&#125;const keys = document.querySelectorAll(`.key`);keys.forEach(key =&gt; key.addEventListener(&#x27;transitionend&#x27;,removeTransition));window.addEventListener(&quot;keydown&quot;,playSound) ¶補充說明: 上面 `.key` 的用法是 JavaScript ES6 中新增的模版字符串（template literals)。 在過去我們需要用以下寫法在JS 的字串中放入 HTML 內容: 1234567/*JS*/let component_es5 = &#x27;&lt;header&gt;\\n&#x27;+&#x27;&lt;div class=&quot;banner&quot;&gt;\\n&#x27;+&#x27;&lt;img src=&quot;img1.jpg&quot;\\n&#x27;+&#x27;&lt;/div&gt;\\n&#x27;+&#x27;&lt;/header&gt;&#x27; 上面的寫法相當冗長，而且不具備閱讀性。在 ES6 中我們可以用反引號快速的解決這樣的狀況： 12345678/*JS*/let component_es6 = `&lt;header&gt; &lt;div class=&#x27;banner&#x27;&gt; &lt;img src=&quot;img1.jpg&gt; &lt;/div&gt;&lt;/header&gt;` – 資料來源: [筆記] JavaScript ES6 中的模版字符串（template literals）和標籤模版（tagged template） ¶實際效果請按此","categories":[{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"}],"tags":[{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"}]},{"title":"Python 學習日記 EP 2 - 流程控制","slug":"流程控制","date":"2021-07-30T14:10:00.000Z","updated":"2022-03-08T16:41:54.833Z","comments":true,"path":"2021/07/30/流程控制/","link":"","permalink":"https://qi-xiang.github.io/2021/07/30/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"","text":"參考書目: Python自動化的樂趣: 搞定重複瑣碎&amp;單調無聊的工作 ¶布林值 True False ¶比較運算子 運算子 意思 == 等於 != 不等於 &lt; 小於 &gt; 大於 &lt;= 小於等於 &gt;= 大於等於 ¶布林運算子 ¶二元布林運算子 and : 所有條件成立才為 True or : 只要有一條件成立則為 True not : 得到相反的布林值 ¶混和運用布林、比較運算子 ¶if 判斷句 只能有其中一個條件成立並被執行 (例如: 第一個為True的條件判斷) ¶if-else ¶if-elif-else ¶while 迴圈判斷句 透過條件限制，持續執行某一程式區塊 ¶break 符合特定條件時，跳出迴圈 Hint: 若迴圈不只一層，則跳出內迴圈 ¶continue 跳回迴圈開始處，重新檢查迴圈條件 ¶for 迴圈和 range() 函式 range(起始值,終止值,遞移植)，但 “不包含” 終止值 ¶匯入模組 Hint: 用 sys.exit() 取代 break 跳出迴圈。","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Python 學習日記","slug":"Python-學習日記","permalink":"https://qi-xiang.github.io/tags/Python-%E5%AD%B8%E7%BF%92%E6%97%A5%E8%A8%98/"}]},{"title":"Python 學習日記 EP 1 - Python基礎","slug":"Python基礎","date":"2021-07-30T05:20:00.000Z","updated":"2022-03-08T16:37:03.012Z","comments":true,"path":"2021/07/30/Python基礎/","link":"","permalink":"https://qi-xiang.github.io/2021/07/30/Python%E5%9F%BA%E7%A4%8E/","excerpt":"","text":"參考書目: Python自動化的樂趣: 搞定重複瑣碎&amp;單調無聊的工作 ¶數學運算子 運算優先等級由高到低 運算子 功能 ** 指數 % 模數/餘數 // 整除/商數取整 / 除法 * 乘法 - 減法 * 加法 ¶整數、浮點數、字串 資料型別 舉例 整數 1、-1、3 浮點數 -1.33、0.0、1.45 字串 ‘b’、‘bb’、‘bbb’ ¶字串連接、複製 ¶將值存放到變數 ¶變數名稱命名規範 只能是1個字詞(中間不能有空格) 只能用英文字母、數字和底線(不能使用其他特殊符號) 不能以數字作為開頭 舉例: [O] variable [X] variable-1 [O] variable_1 [X] 1variable [O] _variable [X] 54 [O] VAR [X] var_$iable [O] variable1 [X] ‘variable’ [O] variAble [X] var iable ¶註解 單行註解 1# 單行註解 多行註解 1234&#x27;&#x27;&#x27;多行註解多行註解&#x27;&#x27;&#x27; ¶print() 函式 印出括號內字串 ¶type() 函式 回傳變數資料型態 ¶input() 函式 取得使用者輸入 ( 預設資料型別為 “str” ) ¶len() 函式 取得字串字元的個數 ¶資料轉型函式 str()，將傳入值變成字串 int()，將傳入值變成整數 float()，將傳入值變成浮點數","categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Python 學習日記","slug":"Python-學習日記","permalink":"https://qi-xiang.github.io/tags/Python-%E5%AD%B8%E7%BF%92%E6%97%A5%E8%A8%98/"}]}],"categories":[{"name":"技術類文章","slug":"技術類文章","permalink":"https://qi-xiang.github.io/categories/%E6%8A%80%E8%A1%93%E9%A1%9E%E6%96%87%E7%AB%A0/"},{"name":"2021 iThome 鐵人賽","slug":"2021-iThome-鐵人賽","permalink":"https://qi-xiang.github.io/categories/2021-iThome-%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"生活類文章","slug":"生活類文章","permalink":"https://qi-xiang.github.io/categories/%E7%94%9F%E6%B4%BB%E9%A1%9E%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"填坑系列","slug":"填坑系列","permalink":"https://qi-xiang.github.io/tags/%E5%A1%AB%E5%9D%91%E7%B3%BB%E5%88%97/"},{"name":"LineBot超入門","slug":"LineBot超入門","permalink":"https://qi-xiang.github.io/tags/LineBot%E8%B6%85%E5%85%A5%E9%96%80/"},{"name":"生活經驗分享","slug":"生活經驗分享","permalink":"https://qi-xiang.github.io/tags/%E7%94%9F%E6%B4%BB%E7%B6%93%E9%A9%97%E5%88%86%E4%BA%AB/"},{"name":"網頁基礎","slug":"網頁基礎","permalink":"https://qi-xiang.github.io/tags/%E7%B6%B2%E9%A0%81%E5%9F%BA%E7%A4%8E/"},{"name":"原子習慣","slug":"原子習慣","permalink":"https://qi-xiang.github.io/tags/%E5%8E%9F%E5%AD%90%E7%BF%92%E6%85%A3/"},{"name":"NLP自然語言處理","slug":"NLP自然語言處理","permalink":"https://qi-xiang.github.io/tags/NLP%E8%87%AA%E7%84%B6%E8%AA%9E%E8%A8%80%E8%99%95%E7%90%86/"},{"name":"區塊鏈","slug":"區塊鏈","permalink":"https://qi-xiang.github.io/tags/%E5%8D%80%E5%A1%8A%E9%8F%88/"},{"name":"財報狗挖好股精華","slug":"財報狗挖好股精華","permalink":"https://qi-xiang.github.io/tags/%E8%B2%A1%E5%A0%B1%E7%8B%97%E6%8C%96%E5%A5%BD%E8%82%A1%E7%B2%BE%E8%8F%AF/"},{"name":"JS30","slug":"JS30","permalink":"https://qi-xiang.github.io/tags/JS30/"},{"name":"Python 學習日記","slug":"Python-學習日記","permalink":"https://qi-xiang.github.io/tags/Python-%E5%AD%B8%E7%BF%92%E6%97%A5%E8%A8%98/"}]}